// Farm Economy Game Engine - Complete Version with TON Connect Only
export default {
    async fetch(request, env, ctx) {
        // إعداد CORS
        if (request.method === 'OPTIONS') {
            return new Response(null, {
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type, X-User-ID, X-Telegram-Data, X-Action, Authorization',
                }
            });
        }
        
        const url = new URL(request.url);
        const path = url.pathname;
        
        // ====== TON Connect Manifest ======
        if (path === '/tonconnect-manifest.json') {
            const origin = url.origin;
            return new Response(JSON.stringify({
                url: origin,
                name: "Farm Economy",
                iconUrl: `${origin}/icon.png`,
                description: "Buy machines, produce resources, earn TON"
            }), {
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
        }
        
        // التحقق من المسار
        const validPaths = ['/api', '/cron/hourly', '/deposit/status', '/deposit/verify'];
        if (!validPaths.includes(path)) {
            return new Response(JSON.stringify({
                success: false,
                error: 'Invalid endpoint'
            }), {
                status: 404,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        // ====== HOURLY PRODUCTION CRON ======
        if (path === '/cron/hourly') {
            // التحقق من المصادقة (CRON secret)
            const authHeader = request.headers.get('Authorization');
            if (authHeader !== `Bearer ${env.CRON_SECRET}`) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Unauthorized'
                }), {
                    status: 401,
                    headers: { 'Content-Type': 'application/json' }
                });
            }
            
            return handleHourlyProduction(env);
        }
        
        // التحقق من حالة الإيداع
        if (path === '/deposit/status') {
            return handleDepositStatus(request, env);
        }
        
        // التحقق من المعاملة على السلسلة
        if (path === '/deposit/verify') {
            return handleVerifyDeposit(request, env);
        }
        
        // للمسار /api - التحقق من المصادقة أولاً
        try {
            // استخراج بيانات Telegram من Authorization header
            const authHeader = request.headers.get('Authorization');
            
            // التحقق من وجود header المصادقة
            if (!authHeader?.startsWith('Telegram ')) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Telegram authentication required',
                    errorCode: 'AUTH_REQUIRED',
                    message: 'يجب فتح اللعبة داخل تطبيق Telegram'
                }), {
                    status: 401,
                    headers: { 
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
            }
            
            const initData = authHeader.replace('Telegram ', '');
            
            // التحقق من بيانات Telegram
            if (!validateTelegramInitData(initData, env.BOT_TOKEN)) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Invalid Telegram authentication',
                    errorCode: 'INVALID_TELEGRAM_AUTH',
                    message: 'مصادقة Telegram غير صالحة'
                }), {
                    status: 401,
                    headers: { 
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
            }
            
            // استخراج userId من بيانات Telegram
            const params = new URLSearchParams(initData);
            const userParam = params.get('user');
            if (!userParam) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'User data not found',
                    errorCode: 'USER_DATA_MISSING'
                }), {
                    status: 401,
                    headers: { 
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
            }
            
            const userData = JSON.parse(decodeURIComponent(userParam));
            const userId = String(userData.id);
            
            // استخراج البيانات من الطلب
            const requestData = await request.json();
            const action = request.headers.get('X-Action') || requestData.action;
            const data = requestData.data || {};
            
            console.log(`Request received: action=${action}, userId=${userId}`);
            
            // ====== معالجة الإجراءات الجديدة ======
            let result;
            switch (action) {
                // State
                case 'getState':
                    result = await handleGetState(env, userId);
                    break;
                
                // Machine Purchases
                case 'buyCow':
                    result = await handleBuyCow(env, userId, data);
                    break;
                    
                case 'buyChicken':
                    result = await handleBuyChicken(env, userId, data);
                    break;
                    
                case 'buyDiamondEngine':
                    result = await handleBuyDiamondEngine(env, userId, data);
                    break;
                
                // Production
                case 'startDiamondProduction':
                    result = await handleStartDiamondProduction(env, userId, data);
                    break;
                
                // Conversion
                case 'convertDiamond':
                    result = await handleConvertDiamond(env, userId, data);
                    break;
                
                // Market
                case 'createOrder':
                    result = await handleCreateOrder(env, userId, data);
                    break;
                    
                case 'buyOrder':
                    result = await handleBuyOrder(env, userId, data);
                    break;
                
                // Withdrawal
                case 'withdrawTON':
                    result = await handleWithdrawTON(env, userId, data);
                    break;
                
                // Deposit
                case 'deposit/init':
                    result = await handleInitDeposit(env, userId, data);
                    break;
                    
                case 'deposit/confirm':
                    result = await handleConfirmDeposit(env, userId, data);
                    break;
                    
                case 'deposit/verify':
                    result = await handleVerifyDepositAPI(env, userId, data);
                    break;
                
                // Referral
                case 'claimReferralEarnings':
                    result = await handleClaimReferralEarnings(env, userId);
                    break;
                
                // Initialize
                case 'initializeUser':
                    result = await initializeUserHandler(env, userId, data);
                    break;
                    
                default:
                    result = {
                        success: false,
                        error: 'Unknown action',
                        errorCode: 'UNKNOWN_ACTION'
                    };
            }
            
            // إرجاع النتيجة
            return new Response(JSON.stringify(result), {
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
            
        } catch (error) {
            console.error('Worker error:', error);
            
            return new Response(JSON.stringify({
                success: false,
                error: 'Internal server error',
                errorCode: 'INTERNAL_SERVER_ERROR',
                details: error.message
            }), {
                status: 500,
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
        }
    }
};

// ==================== GLOBAL CONSTANTS ====================
const GAME_CONSTANTS = {
    // Cow Machine
    COW_PRICE: 1,
    COW_GLOBAL_CAP: 1000,
    COW_PRODUCTION_RATE: 41,
    
    // Chicken Machine
    CHICKEN_PRICE: 1,
    CHICKEN_GLOBAL_CAP: 1000,
    CHICKEN_PRODUCTION_RATE: 41,
    
    // Diamond Engine
    DIAMOND_ENGINE_PRICE: 20,
    DIAMOND_PRODUCTION_COST_MILK: 20000,
    DIAMOND_PRODUCTION_COST_EGG: 20000,
    DIAMOND_PRODUCTION_YIELD: 1,
    
    // Market
    MIN_ORDER_AMOUNT_MILK: 100,
    MIN_ORDER_AMOUNT_EGG: 100,
    MARKET_SELLER_FEE_PERCENT: 5,
    MARKET_BUYER_FEE_PERCENT: 5,
    
    // Withdrawal
    MIN_WITHDRAW_AMOUNT: 0.5,
    WITHDRAW_FEE_PERCENT: 5,
    
    // Deposit
    MIN_DEPOSIT_AMOUNT: 0.1,
    
    // Referral
    REFERRAL_REWARD_PERCENT: 10
};

// ==================== INITIALIZATION ====================

async function initializeGlobalState(env) {
    const now = Date.now();
    const initialState = {
        // Machines
        cows_sold: 0,
        chickens_sold: 0,
        diamond_engines_sold: 0,
        
        // Unlock Status
        chicken_unlocked: false,
        diamond_unlocked: false,
        
        // Economy
        diamond_price: 5,
        
        // Production
        last_hourly_production: now,
        
        // Timestamps
        createdAt: now,
        lastUpdated: now
    };
    
    await handleDbSet(env, 'game/global', initialState);
    return initialState;
}

async function initializeUser(env, userId, referredBy = null) {
    const now = Date.now();
    const initialUser = {
        // Balances
        tonBalance: 0,
        milk: 0,
        eggs: 0,
        diamond: 0,
        
        // Machines Owned
        cows_owned: 0,
        chickens_owned: 0,
        diamond_engines_owned: 0,
        
        // Production Tracking
        lastProductionTimestamp: now,
        
        // Referral
        referralCode: generateReferralCode(userId),
        referredBy: referredBy,
        referralEarnings: 0,
        referralEarningsClaimed: 0,
        
        // Timestamps
        joinDate: now,
        lastUpdated: now
    };
    
    await handleDbSet(env, `users/${userId}`, initialUser);
    return initialUser;
}

async function initializeUserHandler(env, userId, data) {
    try {
        const { user, referredBy } = data;
        
        // Check if user already exists
        const existingUser = await handleDbGet(env, `users/${userId}`);
        if (existingUser.success && existingUser.data) {
            return {
                success: true,
                data: {
                    message: 'User already exists',
                    user: existingUser.data
                }
            };
        }
        
        // Create new user with referral
        const userData = await initializeUser(env, userId, referredBy || null);
        
        return {
            success: true,
            data: {
                message: 'User initialized successfully',
                user: userData
            }
        };
        
    } catch (error) {
        console.error('Initialize user error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'INITIALIZE_USER_ERROR'
        };
    }
}

// ==================== HOURLY PRODUCTION ====================

async function handleHourlyProduction(env) {
    try {
        console.log('Running hourly production...');
        
        // Get all users
        const usersResult = await handleDbGet(env, 'users');
        if (!usersResult.success || !usersResult.data) {
            return {
                success: true,
                data: { milkProduced: 0, eggsProduced: 0 }
            };
        }
        
        const users = usersResult.data;
        let totalMilkProduced = 0;
        let totalEggsProduced = 0;
        
        for (const [userId, user] of Object.entries(users)) {
            if (!user) continue;
            
            const updates = {};
            
            // Milk Production
            if (user.cows_owned > 0) {
                const milkProduced = user.cows_owned * GAME_CONSTANTS.COW_PRODUCTION_RATE;
                updates.milk = (user.milk || 0) + milkProduced;
                totalMilkProduced += milkProduced;
            }
            
            // Eggs Production
            if (user.chickens_owned > 0) {
                const eggsProduced = user.chickens_owned * GAME_CONSTANTS.CHICKEN_PRODUCTION_RATE;
                updates.eggs = (user.eggs || 0) + eggsProduced;
                totalEggsProduced += eggsProduced;
            }
            
            // Update timestamp
            updates.lastProductionTimestamp = Date.now();
            updates.lastUpdated = Date.now();
            
            if (Object.keys(updates).length > 0) {
                await handleDbUpdate(env, `users/${userId}`, updates);
            }
        }
        
        // Update global last production timestamp
        await handleDbUpdate(env, 'game/global', {
            last_hourly_production: Date.now()
        });
        
        console.log(`Hourly production complete. Milk: ${totalMilkProduced}, Eggs: ${totalEggsProduced}`);
        
        return new Response(JSON.stringify({
            success: true,
            data: {
                milkProduced: totalMilkProduced,
                eggsProduced: totalEggsProduced,
                timestamp: Date.now()
            }
        }), {
            headers: { 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error('Hourly production error:', error);
        return new Response(JSON.stringify({
            success: false,
            error: error.message
        }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
        });
    }
}

// ==================== MACHINE PURCHASES ====================

async function handleBuyCow(env, userId, data) {
    try {
        const { referredBy } = data;
        
        // Get user and global state
        const [userResult, globalResult] = await Promise.all([
            handleDbGet(env, `users/${userId}`),
            handleDbGet(env, 'game/global')
        ]);
        
        const user = userResult.data || await initializeUser(env, userId);
        const global = globalResult.data || await initializeGlobalState(env);
        
        // Check global cap
        if (global.cows_sold >= GAME_CONSTANTS.COW_GLOBAL_CAP) {
            return {
                success: false,
                error: 'All Cow machines are sold out!',
                errorCode: 'COW_SOLD_OUT'
            };
        }
        
        // Check user already bought
        if (user.cows_owned > 0) {
            return {
                success: false,
                error: 'You can only buy one Cow machine',
                errorCode: 'COW_ALREADY_OWNED'
            };
        }
        
        // Check balance
        if ((user.tonBalance || 0) < GAME_CONSTANTS.COW_PRICE) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        // Execute purchase
        const userUpdates = {
            cows_owned: 1,
            tonBalance: (user.tonBalance || 0) - GAME_CONSTANTS.COW_PRICE,
            lastUpdated: Date.now()
        };
        
        const globalUpdates = {
            cows_sold: (global.cows_sold || 0) + 1,
            lastUpdated: Date.now()
        };
        
        // Unlock chicken if cows reach cap
        if (globalUpdates.cows_sold >= GAME_CONSTANTS.COW_GLOBAL_CAP) {
            globalUpdates.chicken_unlocked = true;
        }
        
        // Apply updates
        await Promise.all([
            handleDbUpdate(env, `users/${userId}`, userUpdates),
            handleDbUpdate(env, 'game/global', globalUpdates)
        ]);
        
        // ===== REFERRAL SYSTEM =====
        let referralReward = 0;
        if (referredBy && referredBy !== userId) {
            const referrerResult = await handleDbGet(env, `users/${referredBy}`);
            if (referrerResult.success && referrerResult.data) {
                const referrer = referrerResult.data;
                referralReward = GAME_CONSTANTS.COW_PRICE * (GAME_CONSTANTS.REFERRAL_REWARD_PERCENT / 100);
                
                // Add to referrer's earnings
                await handleDbUpdate(env, `users/${referredBy}`, {
                    referralEarnings: (referrer.referralEarnings || 0) + referralReward,
                    lastUpdated: Date.now()
                });
                
                // Record referral
                await handleDbPush(env, `users/${referredBy}/referrals`, {
                    userId: userId,
                    type: 'cow',
                    amount: GAME_CONSTANTS.COW_PRICE,
                    reward: referralReward,
                    timestamp: Date.now()
                });
                
                userUpdates.referredBy = referredBy;
                await handleDbUpdate(env, `users/${userId}`, { referredBy: referredBy });
            }
        }
        
        // Record history
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'buy_cow',
            price: GAME_CONSTANTS.COW_PRICE,
            referredBy: referredBy || null,
            referralReward: referralReward,
            timestamp: Date.now()
        });
        
        return {
            success: true,
            data: {
                cows_owned: 1,
                newTonBalance: userUpdates.tonBalance,
                cows_sold: globalUpdates.cows_sold,
                chicken_unlocked: globalUpdates.chicken_unlocked || false,
                referralReward: referralReward
            }
        };
        
    } catch (error) {
        console.error('Buy cow error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'BUY_COW_ERROR'
        };
    }
}

async function handleBuyChicken(env, userId, data) {
    try {
        const { referredBy } = data;
        
        // Get user and global state
        const [userResult, globalResult] = await Promise.all([
            handleDbGet(env, `users/${userId}`),
            handleDbGet(env, 'game/global')
        ]);
        
        const user = userResult.data;
        const global = globalResult.data;
        
        if (!user || !global) {
            return {
                success: false,
                error: 'User or global state not found',
                errorCode: 'STATE_NOT_FOUND'
            };
        }
        
        // Check if chicken is unlocked
        if (!global.chicken_unlocked && global.cows_sold < GAME_CONSTANTS.COW_GLOBAL_CAP) {
            return {
                success: false,
                error: 'Chicken machines are not unlocked yet',
                errorCode: 'CHICKEN_LOCKED'
            };
        }
        
        // Check global cap
        if (global.chickens_sold >= GAME_CONSTANTS.CHICKEN_GLOBAL_CAP) {
            return {
                success: false,
                error: 'All Chicken machines are sold out!',
                errorCode: 'CHICKEN_SOLD_OUT'
            };
        }
        
        // Check user already bought
        if (user.chickens_owned > 0) {
            return {
                success: false,
                error: 'You can only buy one Chicken machine',
                errorCode: 'CHICKEN_ALREADY_OWNED'
            };
        }
        
        // Check balance
        if ((user.tonBalance || 0) < GAME_CONSTANTS.CHICKEN_PRICE) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        // Execute purchase
        const userUpdates = {
            chickens_owned: 1,
            tonBalance: (user.tonBalance || 0) - GAME_CONSTANTS.CHICKEN_PRICE,
            lastUpdated: Date.now()
        };
        
        const globalUpdates = {
            chickens_sold: (global.chickens_sold || 0) + 1,
            lastUpdated: Date.now()
        };
        
        // Unlock diamond if chickens reach cap
        if (globalUpdates.chickens_sold >= GAME_CONSTANTS.CHICKEN_GLOBAL_CAP) {
            globalUpdates.diamond_unlocked = true;
        }
        
        // Apply updates
        await Promise.all([
            handleDbUpdate(env, `users/${userId}`, userUpdates),
            handleDbUpdate(env, 'game/global', globalUpdates)
        ]);
        
        // ===== REFERRAL SYSTEM =====
        let referralReward = 0;
        if (user.referredBy) {
            const referrerResult = await handleDbGet(env, `users/${user.referredBy}`);
            if (referrerResult.success && referrerResult.data) {
                const referrer = referrerResult.data;
                referralReward = GAME_CONSTANTS.CHICKEN_PRICE * (GAME_CONSTANTS.REFERRAL_REWARD_PERCENT / 100);
                
                await handleDbUpdate(env, `users/${user.referredBy}`, {
                    referralEarnings: (referrer.referralEarnings || 0) + referralReward,
                    lastUpdated: Date.now()
                });
                
                await handleDbPush(env, `users/${user.referredBy}/referrals`, {
                    userId: userId,
                    type: 'chicken',
                    amount: GAME_CONSTANTS.CHICKEN_PRICE,
                    reward: referralReward,
                    timestamp: Date.now()
                });
            }
        }
        
        // Record history
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'buy_chicken',
            price: GAME_CONSTANTS.CHICKEN_PRICE,
            referralReward: referralReward,
            timestamp: Date.now()
        });
        
        return {
            success: true,
            data: {
                chickens_owned: 1,
                newTonBalance: userUpdates.tonBalance,
                chickens_sold: globalUpdates.chickens_sold,
                diamond_unlocked: globalUpdates.diamond_unlocked || false,
                referralReward: referralReward
            }
        };
        
    } catch (error) {
        console.error('Buy chicken error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'BUY_CHICKEN_ERROR'
        };
    }
}

async function handleBuyDiamondEngine(env, userId, data) {
    try {
        const { referredBy } = data;
        
        // Get user and global state
        const [userResult, globalResult] = await Promise.all([
            handleDbGet(env, `users/${userId}`),
            handleDbGet(env, 'game/global')
        ]);
        
        const user = userResult.data;
        const global = globalResult.data;
        
        if (!user || !global) {
            return {
                success: false,
                error: 'User or global state not found',
                errorCode: 'STATE_NOT_FOUND'
            };
        }
        
        // Check if diamond is unlocked
        if (!global.diamond_unlocked) {
            return {
                success: false,
                error: 'Diamond Engines are not unlocked yet',
                errorCode: 'DIAMOND_LOCKED'
            };
        }
        
        // Check user already bought
        if (user.diamond_engines_owned > 0) {
            return {
                success: false,
                error: 'You can only buy one Diamond Engine',
                errorCode: 'DIAMOND_ALREADY_OWNED'
            };
        }
        
        // Check balance
        if ((user.tonBalance || 0) < GAME_CONSTANTS.DIAMOND_ENGINE_PRICE) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        // Execute purchase
        const userUpdates = {
            diamond_engines_owned: 1,
            tonBalance: (user.tonBalance || 0) - GAME_CONSTANTS.DIAMOND_ENGINE_PRICE,
            lastUpdated: Date.now()
        };
        
        const globalUpdates = {
            diamond_engines_sold: (global.diamond_engines_sold || 0) + 1,
            lastUpdated: Date.now()
        };
        
        // Apply updates
        await Promise.all([
            handleDbUpdate(env, `users/${userId}`, userUpdates),
            handleDbUpdate(env, 'game/global', globalUpdates)
        ]);
        
        // ===== REFERRAL SYSTEM =====
        let referralReward = 0;
        if (user.referredBy) {
            const referrerResult = await handleDbGet(env, `users/${user.referredBy}`);
            if (referrerResult.success && referrerResult.data) {
                const referrer = referrerResult.data;
                referralReward = GAME_CONSTANTS.DIAMOND_ENGINE_PRICE * (GAME_CONSTANTS.REFERRAL_REWARD_PERCENT / 100);
                
                await handleDbUpdate(env, `users/${user.referredBy}`, {
                    referralEarnings: (referrer.referralEarnings || 0) + referralReward,
                    lastUpdated: Date.now()
                });
                
                await handleDbPush(env, `users/${user.referredBy}/referrals`, {
                    userId: userId,
                    type: 'diamond_engine',
                    amount: GAME_CONSTANTS.DIAMOND_ENGINE_PRICE,
                    reward: referralReward,
                    timestamp: Date.now()
                });
            }
        }
        
        // Record history
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'buy_diamond_engine',
            price: GAME_CONSTANTS.DIAMOND_ENGINE_PRICE,
            referralReward: referralReward,
            timestamp: Date.now()
        });
        
        return {
            success: true,
            data: {
                diamond_engines_owned: 1,
                newTonBalance: userUpdates.tonBalance,
                diamond_engines_sold: globalUpdates.diamond_engines_sold,
                referralReward: referralReward
            }
        };
        
    } catch (error) {
        console.error('Buy diamond engine error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'BUY_DIAMOND_ENGINE_ERROR'
        };
    }
}

// ==================== DIAMOND PRODUCTION ====================

async function handleStartDiamondProduction(env, userId, data) {
    try {
        // Get user
        const userResult = await handleDbGet(env, `users/${userId}`);
        const user = userResult.data;
        
        if (!user) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        // Check if user owns diamond engine
        if (!user.diamond_engines_owned || user.diamond_engines_owned < 1) {
            return {
                success: false,
                error: 'You need a Diamond Engine first',
                errorCode: 'NO_DIAMOND_ENGINE'
            };
        }
        
        // Check resources
        if ((user.milk || 0) < GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK) {
            return {
                success: false,
                error: `Insufficient Milk. Need ${GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK} Milk`,
                errorCode: 'INSUFFICIENT_MILK'
            };
        }
        
        if ((user.eggs || 0) < GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG) {
            return {
                success: false,
                error: `Insufficient Eggs. Need ${GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG} Eggs`,
                errorCode: 'INSUFFICIENT_EGGS'
            };
        }
        
        // Execute production
        const userUpdates = {
            milk: (user.milk || 0) - GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK,
            eggs: (user.eggs || 0) - GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG,
            diamond: (user.diamond || 0) + GAME_CONSTANTS.DIAMOND_PRODUCTION_YIELD,
            lastUpdated: Date.now()
        };
        
        await handleDbUpdate(env, `users/${userId}`, userUpdates);
        
        // Record history
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'diamond_production',
            milkUsed: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK,
            eggsUsed: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG,
            diamondProduced: GAME_CONSTANTS.DIAMOND_PRODUCTION_YIELD,
            timestamp: Date.now()
        });
        
        return {
            success: true,
            data: {
                diamondProduced: 1,
                newMilk: userUpdates.milk,
                newEggs: userUpdates.eggs,
                newDiamond: userUpdates.diamond
            }
        };
        
    } catch (error) {
        console.error('Diamond production error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DIAMOND_PRODUCTION_ERROR'
        };
    }
}

// ==================== DIAMOND CONVERSION ====================

async function handleConvertDiamond(env, userId, data) {
    try {
        const { amount } = data;
        const diamondsToConvert = parseInt(amount);
        
        if (!diamondsToConvert || diamondsToConvert <= 0) {
            return {
                success: false,
                error: 'Invalid amount',
                errorCode: 'INVALID_AMOUNT'
            };
        }
        
        // Get user and global state
        const [userResult, globalResult] = await Promise.all([
            handleDbGet(env, `users/${userId}`),
            handleDbGet(env, 'game/global')
        ]);
        
        const user = userResult.data;
        const global = globalResult.data;
        
        if (!user || !global) {
            return {
                success: false,
                error: 'User or global state not found',
                errorCode: 'STATE_NOT_FOUND'
            };
        }
        
        // Check diamond balance
        if ((user.diamond || 0) < diamondsToConvert) {
            return {
                success: false,
                error: 'Insufficient diamonds',
                errorCode: 'INSUFFICIENT_DIAMOND'
            };
        }
        
        // Get current diamond price
        const diamondPrice = global.diamond_price || 5;
        const tonToReceive = diamondsToConvert * diamondPrice;
        
        // Execute conversion
        const userUpdates = {
            diamond: (user.diamond || 0) - diamondsToConvert,
            tonBalance: (user.tonBalance || 0) + tonToReceive,
            lastUpdated: Date.now()
        };
        
        await handleDbUpdate(env, `users/${userId}`, userUpdates);
        
        // Record history
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'diamond_conversion',
            diamondsUsed: diamondsToConvert,
            diamondPrice: diamondPrice,
            tonReceived: tonToReceive,
            timestamp: Date.now()
        });
        
        return {
            success: true,
            data: {
                diamondsConverted: diamondsToConvert,
                diamondPrice: diamondPrice,
                tonReceived: tonToReceive,
                newDiamond: userUpdates.diamond,
                newTonBalance: userUpdates.tonBalance
            }
        };
        
    } catch (error) {
        console.error('Diamond conversion error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DIAMOND_CONVERSION_ERROR'
        };
    }
}

// ==================== REFERRAL SYSTEM ====================

async function handleClaimReferralEarnings(env, userId) {
    try {
        const userResult = await handleDbGet(env, `users/${userId}`);
        const user = userResult.data;
        
        if (!user) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const earnings = user.referralEarnings || 0;
        
        if (earnings <= 0) {
            return {
                success: false,
                error: 'No referral earnings to claim',
                errorCode: 'NO_EARNINGS'
            };
        }
        
        // Transfer earnings to TON balance
        const userUpdates = {
            tonBalance: (user.tonBalance || 0) + earnings,
            referralEarnings: 0,
            referralEarningsClaimed: (user.referralEarningsClaimed || 0) + earnings,
            lastUpdated: Date.now()
        };
        
        await handleDbUpdate(env, `users/${userId}`, userUpdates);
        
        // Record history
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'claim_referral',
            amount: earnings,
            timestamp: Date.now()
        });
        
        return {
            success: true,
            data: {
                claimedAmount: earnings,
                newTonBalance: userUpdates.tonBalance
            }
        };
        
    } catch (error) {
        console.error('Claim referral earnings error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'CLAIM_REFERRAL_ERROR'
        };
    }
}

// ==================== GET STATE ====================

async function handleGetState(env, userId) {
    try {
        const [globalResult, userResult] = await Promise.all([
            handleDbGet(env, 'game/global'),
            handleDbGet(env, `users/${userId}`)
        ]);
        
        const global = globalResult.data || await initializeGlobalState(env);
        const user = userResult.data || await initializeUser(env, userId);
        
        // Check for pending deposits
        const pendingDeposits = await checkPendingDeposits(env, userId);
        
        // Get market stats
        const marketStats = await getMarketStats(env);
        
        // Get referral stats
        const referralStats = await getReferralStats(env, userId);
        
        // Calculate hourly production rates
        const milkPerHour = (user.cows_owned || 0) * GAME_CONSTANTS.COW_PRODUCTION_RATE;
        const eggsPerHour = (user.chickens_owned || 0) * GAME_CONSTANTS.CHICKEN_PRODUCTION_RATE;
        
        // Time until next production
        const lastProduction = user.lastProductionTimestamp || Date.now();
        const nextProduction = lastProduction + (60 * 60 * 1000); // 1 hour
        const secondsUntilNext = Math.max(0, Math.floor((nextProduction - Date.now()) / 1000));
        
        return {
            success: true,
            data: {
                user: {
                    tonBalance: user.tonBalance || 0,
                    milk: user.milk || 0,
                    eggs: user.eggs || 0,
                    diamond: user.diamond || 0,
                    
                    cows_owned: user.cows_owned || 0,
                    chickens_owned: user.chickens_owned || 0,
                    diamond_engines_owned: user.diamond_engines_owned || 0,
                    
                    milkPerHour: milkPerHour,
                    eggsPerHour: eggsPerHour,
                    secondsUntilNext: secondsUntilNext,
                    
                    referralCode: user.referralCode,
                    referredBy: user.referredBy,
                    referralEarnings: user.referralEarnings || 0,
                    referralEarningsClaimed: user.referralEarningsClaimed || 0
                },
                global: {
                    cows_sold: global.cows_sold || 0,
                    cows_cap: GAME_CONSTANTS.COW_GLOBAL_CAP,
                    cows_remaining: Math.max(0, GAME_CONSTANTS.COW_GLOBAL_CAP - (global.cows_sold || 0)),
                    
                    chickens_sold: global.chickens_sold || 0,
                    chickens_cap: GAME_CONSTANTS.CHICKEN_GLOBAL_CAP,
                    chickens_remaining: Math.max(0, GAME_CONSTANTS.CHICKEN_GLOBAL_CAP - (global.chickens_sold || 0)),
                    
                    chicken_unlocked: global.chicken_unlocked || false,
                    diamond_unlocked: global.diamond_unlocked || false,
                    
                    diamond_price: global.diamond_price || 5,
                    diamond_engines_sold: global.diamond_engines_sold || 0,
                    
                    last_hourly_production: global.last_hourly_production || Date.now()
                },
                constants: {
                    COW_PRICE: GAME_CONSTANTS.COW_PRICE,
                    COW_PRODUCTION_RATE: GAME_CONSTANTS.COW_PRODUCTION_RATE,
                    CHICKEN_PRICE: GAME_CONSTANTS.CHICKEN_PRICE,
                    CHICKEN_PRODUCTION_RATE: GAME_CONSTANTS.CHICKEN_PRODUCTION_RATE,
                    DIAMOND_ENGINE_PRICE: GAME_CONSTANTS.DIAMOND_ENGINE_PRICE,
                    DIAMOND_PRODUCTION_COST_MILK: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK,
                    DIAMOND_PRODUCTION_COST_EGG: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG,
                    MIN_WITHDRAW_AMOUNT: GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT,
                    WITHDRAW_FEE_PERCENT: GAME_CONSTANTS.WITHDRAW_FEE_PERCENT,
                    MIN_DEPOSIT_AMOUNT: GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT,
                    REFERRAL_REWARD_PERCENT: GAME_CONSTANTS.REFERRAL_REWARD_PERCENT
                },
                market: marketStats,
                referral: referralStats,
                pendingDeposits: pendingDeposits
            }
        };
        
    } catch (error) {
        console.error('Get state error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_STATE_ERROR'
        };
    }
}

// ==================== MARKET SYSTEM ====================

async function handleCreateOrder(env, userId, data) {
    try {
        const { type, resource, price, amount } = data;
        
        // Validate resource type
        if (!['milk', 'eggs'].includes(resource)) {
            return {
                success: false,
                error: 'Invalid resource. Must be milk or eggs',
                errorCode: 'INVALID_RESOURCE'
            };
        }
        
        // Validate order type
        if (!['sell', 'buy'].includes(type)) {
            return {
                success: false,
                error: 'Invalid order type',
                errorCode: 'INVALID_ORDER_TYPE'
            };
        }
        
        // Validate price
        if (!price || parseFloat(price) <= 0) {
            return {
                success: false,
                error: 'Invalid price',
                errorCode: 'INVALID_PRICE'
            };
        }
        
        // Validate amount
        const minAmount = resource === 'milk' 
            ? GAME_CONSTANTS.MIN_ORDER_AMOUNT_MILK 
            : GAME_CONSTANTS.MIN_ORDER_AMOUNT_EGG;
            
        if (!amount || parseInt(amount) < minAmount) {
            return {
                success: false,
                error: `Minimum order amount is ${minAmount} ${resource}`,
                errorCode: 'INVALID_AMOUNT'
            };
        }
        
        const orderAmount = parseInt(amount);
        
        // Get user
        const userResult = await handleDbGet(env, `users/${userId}`);
        const user = userResult.data;
        
        if (!user) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        // Check balance based on order type
        if (type === 'sell') {
            // Selling resources
            const userBalance = resource === 'milk' ? (user.milk || 0) : (user.eggs || 0);
            if (userBalance < orderAmount) {
                return {
                    success: false,
                    error: `Insufficient ${resource}`,
                    errorCode: 'INSUFFICIENT_BALANCE'
                };
            }
            
            // Freeze resources
            const updates = {};
            if (resource === 'milk') {
                updates.milk = (user.milk || 0) - orderAmount;
            } else {
                updates.eggs = (user.eggs || 0) - orderAmount;
            }
            updates.lastUpdated = Date.now();
            
            await handleDbUpdate(env, `users/${userId}`, updates);
            
        } else {
            // Buying resources
            const totalCost = orderAmount * parseFloat(price);
            if ((user.tonBalance || 0) < totalCost) {
                return {
                    success: false,
                    error: 'Insufficient TON balance',
                    errorCode: 'INSUFFICIENT_TON'
                };
            }
            
            // Freeze TON
            await handleDbUpdate(env, `users/${userId}`, {
                tonBalance: (user.tonBalance || 0) - totalCost,
                lastUpdated: Date.now()
            });
        }
        
        // Create order
        const orderId = `order_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const orderData = {
            id: orderId,
            userId: userId,
            type: type,
            resource: resource,
            price: parseFloat(price),
            amount: orderAmount,
            remaining: orderAmount,
            status: 'active',
            createdAt: Date.now(),
            lastUpdated: Date.now()
        };
        
        await handleDbSet(env, `market/orders/${orderId}`, orderData);
        
        // Record frozen assets
        await handleDbSet(env, `users/${userId}/frozenAssets/${orderId}`, {
            type: type,
            resource: resource,
            amount: orderAmount,
            price: parseFloat(price),
            frozenAt: Date.now()
        });
        
        return {
            success: true,
            data: {
                orderId: orderId,
                order: orderData
            }
        };
        
    } catch (error) {
        console.error('Create order error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'CREATE_ORDER_ERROR'
        };
    }
}

async function handleBuyOrder(env, userId, data) {
    try {
        const { orderId, amount } = data;
        
        // Get order
        const orderResult = await handleDbGet(env, `market/orders/${orderId}`);
        if (!orderResult.success || !orderResult.data) {
            return {
                success: false,
                error: 'Order not found',
                errorCode: 'ORDER_NOT_FOUND'
            };
        }
        
        const order = orderResult.data;
        
        // Validate order
        if (order.status !== 'active') {
            return {
                success: false,
                error: 'Order is not active',
                errorCode: 'ORDER_NOT_ACTIVE'
            };
        }
        
        if (order.type !== 'sell') {
            return {
                success: false,
                error: 'Can only buy from sell orders',
                errorCode: 'INVALID_ORDER_TYPE'
            };
        }
        
        const buyAmount = parseInt(amount) || order.remaining;
        if (buyAmount > order.remaining) {
            return {
                success: false,
                error: 'Order does not have enough remaining',
                errorCode: 'INSUFFICIENT_ORDER_AMOUNT'
            };
        }
        
        // Get buyer and seller
        const [buyerResult, sellerResult] = await Promise.all([
            handleDbGet(env, `users/${userId}`),
            handleDbGet(env, `users/${order.userId}`)
        ]);
        
        const buyer = buyerResult.data;
        const seller = sellerResult.data;
        
        if (!buyer || !seller) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        // Calculate costs and fees
        const totalCost = buyAmount * order.price;
        const sellerFee = totalCost * (GAME_CONSTANTS.MARKET_SELLER_FEE_PERCENT / 100);
        const buyerFee = buyAmount * (GAME_CONSTANTS.MARKET_BUYER_FEE_PERCENT / 100);
        
        const sellerReceives = totalCost - sellerFee;
        const buyerReceives = buyAmount - buyerFee;
        
        // Check buyer balance
        if ((buyer.tonBalance || 0) < totalCost) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        // Execute trade
        const buyerUpdates = {
            tonBalance: (buyer.tonBalance || 0) - totalCost,
            lastUpdated: Date.now()
        };
        
        const sellerUpdates = {
            tonBalance: (seller.tonBalance || 0) + sellerReceives,
            lastUpdated: Date.now()
        };
        
        // Add resources to buyer
        if (order.resource === 'milk') {
            buyerUpdates.milk = (buyer.milk || 0) + buyerReceives;
        } else {
            buyerUpdates.eggs = (buyer.eggs || 0) + buyerReceives;
        }
        
        // Update order
        const newRemaining = order.remaining - buyAmount;
        const orderUpdates = {
            remaining: newRemaining,
            status: newRemaining > 0 ? 'active' : 'filled',
            lastUpdated: Date.now()
        };
        
        // Apply updates
        await Promise.all([
            handleDbUpdate(env, `users/${userId}`, buyerUpdates),
            handleDbUpdate(env, `users/${order.userId}`, sellerUpdates),
            handleDbUpdate(env, `market/orders/${orderId}`, orderUpdates)
        ]);
        
        // Remove frozen assets if order is filled
        if (newRemaining <= 0) {
            await handleDbSet(env, `users/${order.userId}/frozenAssets/${orderId}`, null);
        }
        
        // Record transaction
        const txId = `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        await Promise.all([
            handleDbPush(env, `users/${userId}/history`, {
                type: 'market_buy',
                orderId: orderId,
                resource: order.resource,
                amount: buyerReceives,
                tonPaid: totalCost,
                buyerFee: buyerFee,
                sellerId: order.userId,
                timestamp: Date.now(),
                txId: txId
            }),
            
            handleDbPush(env, `users/${order.userId}/history`, {
                type: 'market_sell',
                orderId: orderId,
                resource: order.resource,
                amount: buyAmount,
                tonReceived: sellerReceives,
                sellerFee: sellerFee,
                buyerId: userId,
                timestamp: Date.now(),
                txId: txId
            })
        ]);
        
        return {
            success: true,
            data: {
                txId: txId,
                resource: order.resource,
                amount: buyerReceives,
                tonPaid: totalCost,
                fees: {
                    buyerFee: buyerFee,
                    sellerFee: sellerFee
                },
                newBuyerBalance: buyerUpdates.tonBalance,
                newBuyerResource: order.resource === 'milk' ? buyerUpdates.milk : buyerUpdates.eggs,
                orderRemaining: newRemaining,
                orderStatus: orderUpdates.status
            }
        };
        
    } catch (error) {
        console.error('Buy order error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'BUY_ORDER_ERROR'
        };
    }
}

async function getMarketStats(env) {
    try {
        const ordersResult = await handleDbGet(env, 'market/orders');
        const allOrders = ordersResult.data || {};
        
        let milkBuyOrders = 0;
        let milkSellOrders = 0;
        let eggBuyOrders = 0;
        let eggSellOrders = 0;
        
        let bestMilkBuyPrice = 0;
        let bestMilkSellPrice = Infinity;
        let bestEggBuyPrice = 0;
        let bestEggSellPrice = Infinity;
        
        for (const order of Object.values(allOrders)) {
            if (order.status === 'active') {
                if (order.resource === 'milk') {
                    if (order.type === 'buy') {
                        milkBuyOrders++;
                        if (order.price > bestMilkBuyPrice) {
                            bestMilkBuyPrice = order.price;
                        }
                    } else {
                        milkSellOrders++;
                        if (order.price < bestMilkSellPrice) {
                            bestMilkSellPrice = order.price;
                        }
                    }
                } else {
                    if (order.type === 'buy') {
                        eggBuyOrders++;
                        if (order.price > bestEggBuyPrice) {
                            bestEggBuyPrice = order.price;
                        }
                    } else {
                        eggSellOrders++;
                        if (order.price < bestEggSellPrice) {
                            bestEggSellPrice = order.price;
                        }
                    }
                }
            }
        }
        
        if (bestMilkSellPrice === Infinity) bestMilkSellPrice = 0;
        if (bestEggSellPrice === Infinity) bestEggSellPrice = 0;
        
        return {
            milk: {
                buyOrders: milkBuyOrders,
                sellOrders: milkSellOrders,
                bestBuyPrice: bestMilkBuyPrice,
                bestSellPrice: bestMilkSellPrice
            },
            eggs: {
                buyOrders: eggBuyOrders,
                sellOrders: eggSellOrders,
                bestBuyPrice: bestEggBuyPrice,
                bestSellPrice: bestEggSellPrice
            }
        };
        
    } catch (error) {
        return {
            milk: { buyOrders: 0, sellOrders: 0, bestBuyPrice: 0, bestSellPrice: 0 },
            eggs: { buyOrders: 0, sellOrders: 0, bestBuyPrice: 0, bestSellPrice: 0 }
        };
    }
}

// ==================== REFERRAL STATS ====================

async function getReferralStats(env, userId) {
    try {
        const referralsResult = await handleDbGet(env, `users/${userId}/referrals`);
        const referrals = referralsResult.data || {};
        
        let totalReferrals = 0;
        let totalRewards = 0;
        let lastReferral = null;
        
        const referralList = Object.values(referrals);
        totalReferrals = referralList.length;
        
        referralList.forEach(ref => {
            totalRewards += ref.reward || 0;
            if (!lastReferral || ref.timestamp > lastReferral) {
                lastReferral = ref.timestamp;
            }
        });
        
        return {
            totalReferrals: totalReferrals,
            totalRewards: totalRewards,
            lastReferral: lastReferral,
            referralList: referralList.slice(-5) // Last 5 referrals
        };
        
    } catch (error) {
        return {
            totalReferrals: 0,
            totalRewards: 0,
            lastReferral: null,
            referralList: []
        };
    }
}

// ==================== WITHDRAWAL ====================

async function handleWithdrawTON(env, userId, data) {
    try {
        const { amount, address } = data;
        const withdrawAmount = parseFloat(amount);
        
        // Validate amount
        if (!withdrawAmount || withdrawAmount < GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT) {
            return {
                success: false,
                error: `Minimum withdrawal amount is ${GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT} TON`,
                errorCode: 'INVALID_WITHDRAW_AMOUNT'
            };
        }
        
        // Validate address
        if (!address || address.trim().length === 0) {
            return {
                success: false,
                error: 'TON address is required',
                errorCode: 'ADDRESS_REQUIRED'
            };
        }
        
        // Get user
        const userResult = await handleDbGet(env, `users/${userId}`);
        const user = userResult.data;
        
        if (!user) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        // Calculate fee
        const fee = withdrawAmount * (GAME_CONSTANTS.WITHDRAW_FEE_PERCENT / 100);
        const netAmount = withdrawAmount - fee;
        
        // Check balance
        if ((user.tonBalance || 0) < withdrawAmount) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        // Update user balance
        await handleDbUpdate(env, `users/${userId}`, {
            tonBalance: (user.tonBalance || 0) - withdrawAmount,
            lastUpdated: Date.now()
        });
        
        // Create withdrawal request
        const withdrawalId = `withdraw_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        const withdrawalData = {
            id: withdrawalId,
            userId: userId,
            amount: withdrawAmount,
            fee: fee,
            netAmount: netAmount,
            address: address,
            status: 'pending',
            createdAt: Date.now(),
            lastUpdated: Date.now()
        };
        
        await handleDbSet(env, `withdrawals/pending/${withdrawalId}`, withdrawalData);
        
        // Record history
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'withdraw_request',
            amount: withdrawAmount,
            fee: fee,
            netAmount: netAmount,
            address: address,
            status: 'pending',
            timestamp: Date.now(),
            withdrawalId: withdrawalId
        });
        
        return {
            success: true,
            data: {
                withdrawalId: withdrawalId,
                amount: withdrawAmount,
                fee: fee,
                netAmount: netAmount,
                newBalance: (user.tonBalance || 0) - withdrawAmount,
                message: 'Withdrawal request submitted. Will be processed within 24 hours.'
            }
        };
        
    } catch (error) {
        console.error('Withdraw TON error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'WITHDRAW_TON_ERROR'
        };
    }
}

// ==================== DEPOSIT SYSTEM ====================

async function handleInitDeposit(env, userId, data) {
    try {
        const { amount, wallet_address } = data;
        
        // Validate amount
        if (!amount || amount < GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT) {
            return {
                success: false,
                error: `Minimum deposit amount is ${GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT} TON`,
                errorCode: 'MIN_DEPOSIT_AMOUNT'
            };
        }
        
        // Validate wallet address
        if (!wallet_address || wallet_address.length < 5) {
            return {
                success: false,
                error: 'Valid wallet address is required',
                errorCode: 'INVALID_WALLET_ADDRESS'
            };
        }
        
        // Get deposit address from environment
        const depositAddress = env.DEPOSIT_WALLET_ADDRESS || "UQBnwSS4Kox3ZZmF69KxWLfvfCc2-dLV8sT5nJe-aV7HfCyG";
        
        // Create deposit record
        const depositId = `deposit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        const depositData = {
            id: depositId,
            userId: userId,
            amount: amount,
            walletAddress: wallet_address,
            status: 'pending',
            createdAt: Date.now(),
            lastUpdated: Date.now()
        };
        
        await handleDbSet(env, `deposits/pending/${depositId}`, depositData);
        
        return {
            success: true,
            data: {
                address: depositAddress,
                amount: amount,
                depositId: depositId,
                message: 'Send the exact amount with comment containing your User ID only',
                comment: userId // يجب إضافة User ID في الـ Comment
            }
        };
        
    } catch (error) {
        console.error('Init deposit error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'INIT_DEPOSIT_ERROR'
        };
    }
}

async function handleConfirmDeposit(env, userId, data) {
    try {
        const { txHash, amount, user_address, comment } = data;
        
        // Validate required fields
        if (!txHash || !amount) {
            return {
                success: false,
                error: 'Transaction hash and amount are required',
                errorCode: 'MISSING_REQUIRED_FIELDS'
            };
        }
        
        // التحقق من أن الـ comment يحتوي فقط على User ID
        if (!comment || comment.toString() !== userId) {
            return {
                success: false,
                error: 'Invalid comment. Comment must contain only your User ID',
                errorCode: 'INVALID_COMMENT'
            };
        }
        
        const depositAmount = parseFloat(amount);
        
        // Check minimum amount
        if (depositAmount < GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT) {
            return {
                success: false,
                error: `Minimum deposit amount is ${GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT} TON`,
                errorCode: 'MIN_DEPOSIT_NOT_MET'
            };
        }
        
        // Check for duplicate transaction
        const existingTx = await handleDbGet(env, `transactions/${txHash}`);
        if (existingTx.success && existingTx.data) {
            return {
                success: false,
                error: 'Transaction already processed',
                errorCode: 'DUPLICATE_TRANSACTION'
            };
        }
        
        // Record transaction (pending verification)
        const now = Date.now();
        const depositRecord = {
            userId: userId,
            amount: depositAmount,
            fromAddress: user_address || 'TON Connect',
            toAddress: env.DEPOSIT_WALLET_ADDRESS,
            txHash: txHash,
            comment: comment,
            status: 'verifying',
            verified: false,
            processedAt: now,
            method: 'TON Connect',
            depositId: `dep_${now}_${userId}_${txHash.substring(0, 8)}`
        };
        
        await handleDbSet(env, `transactions/${txHash}`, depositRecord);
        
        // Add to pending verification
        await handleDbSet(env, `deposits/verifying/${txHash}`, depositRecord);
        
        return {
            success: true,
            data: {
                amount: depositAmount,
                txHash: txHash,
                timestamp: now,
                status: 'verifying',
                message: 'Transaction received. Verification in progress. Your balance will be updated within 1-3 minutes.'
            }
        };
        
    } catch (error) {
        console.error('Confirm deposit error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'CONFIRM_DEPOSIT_ERROR'
        };
    }
}

// ✅ التحقق من المعاملة على السلسلة (مع التحقق من Comment)
async function verifyOnChainTransaction(env, txHash, fromAddress, amount, expectedUserId) {
    try {
        // هنا يتم التحقق من المعاملة على البلوكشين
        // هذا يعتمد على الـ API المستخدم (toncenter, tonapi.io, etc.)
        
        console.log('Verifying transaction:', txHash);
        
        // التحقق من أن المعاملة موجودة
        if (!txHash || !expectedUserId) {
            return false;
        }
        
        // TODO: استدعاء TON API للتحقق من المعاملة
        // يجب التأكد من:
        // 1. المبلغ صحيح
        // 2. عنوان المستلم صحيح
        // 3. الـ comment يحتوي فقط على User ID
        
        // للاختبار، نقبل المعاملة
        return true;
        
    } catch (error) {
        console.error('Transaction verification error:', error);
        return false;
    }
}

async function handleVerifyDeposit(request, env) {
    try {
        const { txHash, userId } = await request.json();
        
        if (!txHash || !userId) {
            return new Response(JSON.stringify({
                success: false,
                error: 'Transaction hash and user ID required'
            }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        // Get transaction record
        const txResult = await handleDbGet(env, `transactions/${txHash}`);
        if (!txResult.success || !txResult.data) {
            return new Response(JSON.stringify({
                success: false,
                error: 'Transaction not found'
            }), {
                status: 404,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        const transaction = txResult.data;
        
        // Check if already verified
        if (transaction.status === 'completed') {
            return new Response(JSON.stringify({
                success: true,
                data: {
                    status: 'completed',
                    amount: transaction.amount,
                    verified: true,
                    timestamp: transaction.processedAt
                }
            }), {
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        // Verify on blockchain
        const verified = await verifyOnChainTransaction(
            env, 
            txHash, 
            transaction.fromAddress, 
            transaction.amount,
            transaction.comment
        );
        
        if (verified) {
            // Update transaction status
            const now = Date.now();
            
            await handleDbUpdate(env, `transactions/${txHash}`, {
                status: 'completed',
                verified: true,
                processedAt: now
            });
            
            // Update user balance
            const userResult = await handleDbGet(env, `users/${userId}`);
            if (userResult.success && userResult.data) {
                const user = userResult.data;
                await handleDbUpdate(env, `users/${userId}`, {
                    tonBalance: (user.tonBalance || 0) + transaction.amount,
                    lastUpdated: now
                });
            }
            
            // Remove from verifying
            await handleDbSet(env, `deposits/verifying/${txHash}`, null);
            
            // Record in history
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'deposit',
                amount: transaction.amount,
                txHash: txHash,
                timestamp: now
            });
            
            return new Response(JSON.stringify({
                success: true,
                data: {
                    status: 'completed',
                    amount: transaction.amount,
                    verified: true,
                    timestamp: now
                }
            }), {
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        return new Response(JSON.stringify({
            success: true,
            data: {
                status: 'verifying',
                amount: transaction.amount,
                verified: false,
                timestamp: transaction.processedAt
            }
        }), {
            headers: { 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error('Verify deposit error:', error);
        return new Response(JSON.stringify({
            success: false,
            error: error.message
        }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
        });
    }
}

async function handleVerifyDepositAPI(env, userId, data) {
    try {
        const { txHash, depositId } = data;
        
        if (!txHash && !depositId) {
            return {
                success: false,
                error: 'Transaction hash or deposit ID required',
                errorCode: 'MISSING_IDENTIFIER'
            };
        }
        
        let depositRecord;
        
        // Find by transaction hash
        if (txHash) {
            const txResult = await handleDbGet(env, `transactions/${txHash}`);
            if (txResult.success && txResult.data) {
                depositRecord = txResult.data;
            }
        }
        
        // Find by deposit ID
        if (!depositRecord && depositId) {
            const depositResult = await handleDbGet(env, `deposits/pending/${depositId}`);
            if (depositResult.success && depositResult.data) {
                depositRecord = depositResult.data;
            }
        }
        
        if (!depositRecord) {
            return {
                success: false,
                error: 'Deposit record not found',
                errorCode: 'DEPOSIT_NOT_FOUND'
            };
        }
        
        // Check ownership
        if (depositRecord.userId !== userId) {
            return {
                success: false,
                error: 'Unauthorized access to deposit',
                errorCode: 'UNAUTHORIZED_ACCESS'
            };
        }
        
        return {
            success: true,
            data: {
                status: depositRecord.status || 'pending',
                amount: depositRecord.amount,
                verified: depositRecord.verified || false,
                timestamp: depositRecord.processedAt || depositRecord.createdAt
            }
        };
        
    } catch (error) {
        console.error('Verify deposit error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_DEPOSIT_ERROR'
        };
    }
}

async function handleDepositStatus(request, env) {
    try {
        const url = new URL(request.url);
        const txHash = url.searchParams.get('tx');
        const depositId = url.searchParams.get('id');
        
        if (!txHash && !depositId) {
            return new Response(JSON.stringify({
                success: false,
                error: 'Transaction hash or deposit ID required'
            }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        let depositRecord;
        
        if (txHash) {
            const txResult = await handleDbGet(env, `transactions/${txHash}`);
            if (txResult.success && txResult.data) {
                depositRecord = txResult.data;
            }
        }
        
        if (!depositRecord && depositId) {
            const depositResult = await handleDbGet(env, `deposits/pending/${depositId}`);
            if (depositResult.success && depositResult.data) {
                depositRecord = depositResult.data;
            }
        }
        
        if (!depositRecord) {
            return new Response(JSON.stringify({
                success: false,
                error: 'Deposit not found'
            }), {
                status: 404,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        return new Response(JSON.stringify({
            success: true,
            data: {
                status: depositRecord.status || 'pending',
                amount: depositRecord.amount,
                fromAddress: depositRecord.fromAddress || depositRecord.walletAddress,
                toAddress: depositRecord.toAddress || depositRecord.depositAddress,
                txHash: depositRecord.txHash,
                createdAt: depositRecord.createdAt,
                processedAt: depositRecord.processedAt,
                verified: depositRecord.verified || false
            }
        }), {
            headers: { 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error('Deposit status error:', error);
        return new Response(JSON.stringify({
            success: false,
            error: error.message
        }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
        });
    }
}

async function checkPendingDeposits(env, userId) {
    try {
        const depositsResult = await handleDbGet(env, `users/${userId}/deposits`);
        const deposits = depositsResult.data || {};
        
        const pending = [];
        
        for (const [key, deposit] of Object.entries(deposits)) {
            if (deposit.status === 'pending' || deposit.status === 'verifying') {
                pending.push({
                    depositId: key,
                    amount: deposit.amount,
                    timestamp: deposit.timestamp || deposit.createdAt,
                    status: deposit.status,
                    txHash: deposit.txHash
                });
            }
        }
        
        return pending;
        
    } catch (error) {
        console.error('Check pending deposits error:', error);
        return [];
    }
}

// ==================== HELPER FUNCTIONS ====================

function generateReferralCode(userId) {
    return `FARM_${userId.substring(0, 8).toUpperCase()}_${Math.random().toString(36).substr(2, 4).toUpperCase()}`;
}

function validateTelegramInitData(initData, botToken) {
    try {
        // في الإنتاج، يجب التحقق من HMAC-SHA256
        return true; // للاختبار
        
    } catch (error) {
        console.error('Telegram validation error:', error);
        return false;
    }
}

// ==================== DATABASE FUNCTIONS ====================

async function getFirebaseUrl(env, path) {
    const baseUrl = env.FIREBASE_DATABASE_URL.replace(/\/$/, '');
    const cleanPath = path.replace(/^\//, '');
    const apiKey = env.FIREBASE_API_KEY;
    
    if (!apiKey) {
        throw new Error('FIREBASE_API_KEY is not configured');
    }
    
    return `${baseUrl}/${cleanPath}.json?key=${apiKey}`;
}

async function handleDbGet(env, path) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        const response = await fetch(firebaseUrl);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        
        return {
            success: true,
            data: data
        };
    } catch (error) {
        console.error('Database GET error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_GET_ERROR'
        };
    }
}

async function handleDbSet(env, path, data) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error('Database SET error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_SET_ERROR'
        };
    }
}

async function handleDbUpdate(env, path, updates) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updates)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error('Database UPDATE error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_UPDATE_ERROR'
        };
    }
}

async function handleDbPush(env, path, data) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: { name: result.name }
        };
    } catch (error) {
        console.error('Database PUSH error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_PUSH_ERROR'
        };
    }
}

// ==================== END OF WORKER CODE ====================
