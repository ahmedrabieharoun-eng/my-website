// Cloudflare Worker Ù„Ù€ GLX Galaxy
export default {
    async fetch(request, env, ctx) {
        // Ø¥Ø¹Ø¯Ø§Ø¯ CORS
        if (request.method === 'OPTIONS') {
            return new Response(null, {
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type, X-User-ID, X-Telegram-Data, X-Action, X-Device-Fingerprint, X-Client-IP',
                }
            });
        }
        
        const url = new URL(request.url);
        const path = url.pathname;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø³Ø§Ø±
        if (path !== '/api') {
            return new Response(JSON.stringify({
                success: false,
                error: 'Invalid endpoint'
            }), {
                status: 404,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        try {
            // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ø§Ù„Ø·Ù„Ø¨
            const requestData = await request.json();
            const action = request.headers.get('X-Action') || requestData.action;
            const data = requestData.data || {};
            const userId = request.headers.get('X-User-ID');
            const telegramData = request.headers.get('X-Telegram-Data');
            const deviceFingerprint = request.headers.get('X-Device-Fingerprint') || data.deviceFingerprint;
            const clientIp = request.headers.get('X-Client-IP') || request.headers.get('CF-Connecting-IP') || 'Unknown';
            
            console.log(`Request received: action=${action}, userId=${userId}, clientIp=${clientIp}`);
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©
            if (!userId || !telegramData) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Authentication required',
                    errorCode: 'AUTH_REQUIRED'
                }), {
                    status: 401,
                    headers: { 'Content-Type': 'application/json' }
                });
            }
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Telegram
            if (!isValidTelegramData(telegramData, userId)) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Invalid Telegram data',
                    errorCode: 'INVALID_TELEGRAM_DATA'
                }), {
                    status: 401,
                    headers: { 'Content-Type': 'application/json' }
                });
            }
            
            // ==================== Ù†Ø¸Ø§Ù… Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø² Ø§Ù„Ù…Ø­Ø³Ù† Ø¨Ø¯ÙˆÙ† IP ====================
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø² ÙÙ‚Ø· Ù„Ø¥Ø¬Ø±Ø§Ø¡ initializeUser
            if (action === 'initializeUser') {
                // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£ÙˆÙ„Ø§Ù‹ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¬Ø¯ÙŠØ¯Ù‹Ø§
                const userResult = await handleDbGet(env, `users/${userId}`);
                const userData = userResult.data;
                
                // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯Ù‹Ø§ (Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª) Ø£Ùˆ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙ‡ Ø¨ØµÙ…Ø© Ø¬Ù‡Ø§Ø²
                if ((!userResult.success || !userData || !userData.deviceFingerprint) && deviceFingerprint) {
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø² Ù…Ø³ØªØ®Ø¯Ù…Ø© Ø¨Ø§Ù„ÙØ¹Ù„
                    const fingerprintCheck = await checkDeviceFingerprintWithoutIP(env, deviceFingerprint, userId);
                    
                    if (fingerprintCheck.deviceAlreadyUsed) {
                        // Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù‡Ùˆ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯ØŒ ÙŠØªÙ… Ø­Ø¸Ø±Ù‡ Ù„Ø£Ù†Ù‡ Ù„ÙŠØ³ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆÙ„
                        await applyBlock(env, userId, {
                            reason: 'Device multi-account violation - New account detected',
                            violation: 'DEVICE_MULTI_ACCOUNT',
                            action: 'initializeUser',
                            details: `Device fingerprint ${deviceFingerprint} already used by ${fingerprintCheck.existingAccounts.length} other accounts`,
                            timestamp: Date.now(),
                            permanent: true,
                            deviceFingerprint: deviceFingerprint,
                            isNewAccount: true
                        });
                        
                        return new Response(JSON.stringify({
                            success: false,
                            error: 'ACCOUNT_BLOCKED',
                            errorCode: 'DEVICE_MULTI_ACCOUNT_BLOCKED',
                            data: {
                                deviceAlreadyUsed: true,
                                existingAccounts: fingerprintCheck.existingAccounts,
                                violationType: 'DEVICE_MULTI_ACCOUNT',
                                accountsBlocked: fingerprintCheck.newAccountsBlocked,
                                currentAccountBlocked: true,
                                blockedMessage: `ğŸš« Account Blocked\n\nReason: Device multi-account violation\nViolation: DEVICE_MULTI_ACCOUNT\n\nThis decision is final.`,
                                redirectToBlockPage: true
                            }
                        }), {
                            status: 403,
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }
                    
                    // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ø§Ù„Ø¨ØµÙ…Ø© Ù…Ø³ØªØ®Ø¯Ù…Ø©ØŒ Ø³Ù†Ù‚ÙˆÙ… Ø¨Ø­ÙØ¸Ù‡Ø§ Ù„Ø§Ø­Ù‚Ù‹Ø§ ÙÙŠ handleInitializeUser
                    data.deviceFingerprint = deviceFingerprint;
                }
            }
            // ==================== Ù†Ù‡Ø§ÙŠØ© Ù†Ø¸Ø§Ù… Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø² ====================
            
            // ==================== Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ø¸Ø± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ====================
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø± Ù‚Ø¨Ù„ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙŠ Ø·Ù„Ø¨
            const blockCheck = await checkUserBlocked(env, userId);
            if (blockCheck && blockCheck.isBlocked) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'ACCOUNT_BLOCKED',
                    errorCode: 'ACCOUNT_BLOCKED',
                    data: {
                        isBlocked: true,
                        blockDetails: {
                            reason: blockCheck.reason,
                            violation: blockCheck.violation,
                            appliedAt: blockCheck.appliedAt,
                            permanent: blockCheck.permanent,
                            details: blockCheck.details,
                            blockType: blockCheck.permanent ? 'PERMANENT_BLOCK' : 'TEMPORARY_BLOCK'
                        },
                        blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\nDetails: ${blockCheck.details}\n\nThis decision is final.`,
                        redirectToBlockPage: true
                    }
                }), {
                    status: 403,
                    headers: { 
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
            }
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø·Ù„Ø¨
            const validationResult = await validateRequest(env, userId, action, data, requestData.timestamp);
            if (!validationResult.valid) {
                // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø®Ø§Ù„ÙØ© ÙˆØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ø¸Ø± Ø§Ù„ÙÙˆØ±ÙŠ Ø¨Ø¹Ø¯ Ù…Ø®Ø§Ù„ÙØ© ÙˆØ§Ø­Ø¯Ø©
                if (validationResult.shouldBlock !== false) {
                    await recordViolation(env, userId, {
                        action: action,
                        violation: validationResult.violation,
                        details: validationResult.details,
                        timestamp: Date.now(),
                        deviceFingerprint: deviceFingerprint
                    });
                    
                    // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ø¸Ø± Ø§Ù„ÙÙˆØ±ÙŠ Ø¨Ø¹Ø¯ Ù…Ø®Ø§Ù„ÙØ© ÙˆØ§Ø­Ø¯Ø©
                    await applyBlock(env, userId, {
                        reason: 'System violation detected',
                        violation: validationResult.violation,
                        action: action,
                        details: validationResult.details,
                        timestamp: Date.now(),
                        permanent: true,
                        deviceFingerprint: deviceFingerprint
                    });
                    
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'ACCOUNT_BLOCKED',
                        errorCode: 'REQUEST_VALIDATION_FAILED',
                        data: {
                            isBlocked: true,
                            blockDetails: {
                                reason: 'System violation detected',
                                violation: validationResult.violation,
                                details: validationResult.details,
                                permanent: true
                            },
                            blockedMessage: `ğŸš« Account Blocked\n\nReason: System violation detected\nViolation: ${validationResult.violation}\n\nThis decision is final.`,
                            redirectToBlockPage: true
                        }
                    }), {
                        status: 400,
                        headers: { 'Content-Type': 'application/json' }
                    });
                } else {
                    // Ø±ÙØ¶ Ø§Ù„Ø·Ù„Ø¨ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø­Ø¸Ø±
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'REQUEST_VALIDATION_FAILED',
                        errorCode: validationResult.violation,
                        data: {
                            details: validationResult.details,
                            noBlock: true,
                            message: 'Request validation failed. Please try again.'
                        }
                    }), {
                        status: 400,
                        headers: { 'Content-Type': 'application/json' }
                    });
                }
            }
            
            // ==================== Ù†Ù‡Ø§ÙŠØ© Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ø¸Ø± ====================
            
            // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª
            let result;
            switch (action) {
                case 'initializeUser':
                    result = await handleInitializeUser(env, userId, data, telegramData);
                    break;
                    
                case 'getCompetitionData':
                    result = await handleGetCompetitionData(env, userId);
                    break;
                    
                case 'dbSet':
                    result = await handleDbSet(env, data.path, data.data);
                    break;
                    
                case 'dbGet':
                    result = await handleDbGet(env, data.path);
                    break;
                    
                case 'dbUpdate':
                    result = await handleDbUpdate(env, data.path, data.updates);
                    break;
                    
                case 'dbPush':
                    result = await handleDbPush(env, data.path, data.data);
                    break;
                    
                case 'dbTransaction':
                    result = await handleDbTransaction(env, data.path, data.transactionFunction);
                    break;
                    
                case 'dbIncrement':
                    result = await handleDbIncrement(env, data.path, data.key, data.amount);
                    break;
                    
                case 'getConfig':
                    result = await handleGetConfig();
                    break;
                    
                case 'executeSwap':
                    result = await handleExecuteSwap(env, userId, data);
                    break;
                    
                case 'verifyDeposit':
                    result = await handleVerifyDeposit(env, userId, data);
                    break;
                    
                case 'buyTickets':
                    result = await handleBuyTickets(env, userId, data);
                    break;
                    
                case 'getCompetitionLeaderboard':
                    result = await handleGetCompetitionLeaderboard(env);
                    break;
                    
                case 'getPreviousWinners':
                    result = await handleGetPreviousWinners(env);
                    break;
                    
                case 'flipCoin':
                    result = await handleFlipCoin(env, userId, data);
                    break;
                    
                case 'redeemPromoCode':
                    result = await handleRedeemPromoCode(env, userId, data);
                    break;
                    
                case 'createTask':
                    result = await handleCreateTask(env, userId, data);
                    break;
                    
                case 'verifyTaskPayment':
                    result = await handleVerifyTaskPayment(env, data.taskId);
                    break;
                    
                case 'verifyTaskChannel':
                    result = await handleVerifyTaskChannel(env, userId, data);
                    break;
                    
                case 'spinSlots':
                    result = await handleSpinSlots(env, userId);
                    break;
                    
                case 'addExtraSpin':
                    result = await handleAddExtraSpin(env, userId);
                    break;
                    
                case 'claimDailyBonus':
                    result = await handleClaimDailyBonus(env, userId);
                    break;
                    
                case 'getTransactionHistory':
                    result = await handleGetTransactionHistory(env, userId, data.limit);
                    break;
                    
                case 'getUserWithdrawals':
                    result = await handleGetUserWithdrawals(env, userId);
                    break;
                    
                case 'getWithdrawalHistory':
                    result = await handleGetWithdrawalHistory(env);
                    break;
                    
                case 'getWithdrawalStats':
                    result = await handleGetWithdrawalStats(env);
                    break;
                    
                case 'getReferredUsers':
                    result = await handleGetReferredUsers(env, userId);
                    break;
                    
                case 'getTasks':
                    result = await handleGetTasks(env, userId);
                    break;
                    
                case 'verifyTaskCompletion':
                    result = await handleVerifyTaskCompletion(env, userId, data);
                    break;
                    
                case 'handleReferral':
                    result = await handleReferral(env, data.userId, data.referrerId);
                    break;
                    
                case 'handleAdClick':
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø± Ù‚Ø¨Ù„ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†
                    const adBlockCheck = await checkUserBlocked(env, userId);
                    if (adBlockCheck && adBlockCheck.isBlocked) {
                        return new Response(JSON.stringify({
                            success: false,
                            error: 'ACCOUNT_BLOCKED',
                            errorCode: 'ACCOUNT_BLOCKED',
                            data: {
                                isBlocked: true,
                                blockDetails: adBlockCheck,
                                blockedMessage: `ğŸš« Account Blocked\n\nReason: ${adBlockCheck.reason}\nViolation: ${adBlockCheck.violation}\n\nThis decision is final.`,
                                redirectToBlockPage: true
                            }
                        }), {
                            status: 403,
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø·Ù„Ø¨ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†
                    const adValidation = await validateAdRequest(env, userId, data);
                    if (!adValidation.valid) {
                        // Ø­Ø¸Ø± ÙÙˆØ±ÙŠ Ù„Ø·Ù„Ø¨ Ø¥Ø¹Ù„Ø§Ù† ØºÙŠØ± ØµØ§Ù„Ø­ - Ù…Ø®Ø§Ù„ÙØ© ÙˆØ§Ø­Ø¯Ø©
                        await applyBlock(env, userId, {
                            reason: 'Invalid ad request - System violation',
                            violation: adValidation.violation,
                            action: 'handleAdClick',
                            details: adValidation.details,
                            timestamp: Date.now(),
                            permanent: true,
                            deviceFingerprint: deviceFingerprint
                        });
                        
                        return new Response(JSON.stringify({
                            success: false,
                            error: 'ACCOUNT_BLOCKED',
                            errorCode: 'AD_VALIDATION_FAILED',
                            data: {
                                isBlocked: true,
                                blockDetails: {
                                    reason: 'Invalid ad request - System violation',
                                    violation: adValidation.violation,
                                    permanent: true
                                },
                                blockedMessage: `ğŸš« Account Blocked\n\nReason: Invalid ad request\nViolation: ${adValidation.violation}\n\nThis decision is final.`,
                                redirectToBlockPage: true
                            }
                        }), {
                            status: 400,
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }
                    
                    result = await handleAdClick(env, userId, data.adType, data.reward);
                    break;
                    
                case 'submitWithdrawal':
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ù„Ù„Ø³Ø­ÙˆØ¨Ø§Øª
                    const dailyLimitCheck = await checkDailyWithdrawalLimit(env, userId);
                    if (dailyLimitCheck.limitReached) {
                        return new Response(JSON.stringify({
                            success: false,
                            error: 'DAILY_WITHDRAWAL_LIMIT_REACHED',
                            errorCode: 'DAILY_WITHDRAWAL_LIMIT_REACHED',
                            data: {
                                message: `Daily withdrawal limit reached! You can only make ${dailyLimitCheck.dailyLimit} withdrawals per day.`,
                                todayWithdrawals: dailyLimitCheck.todayWithdrawals,
                                dailyLimit: dailyLimitCheck.dailyLimit,
                                remaining: dailyLimitCheck.remaining,
                                resetTime: dailyLimitCheck.resetTime
                            }
                        }), {
                            status: 400,
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }
                    
                    result = await handleSubmitWithdrawal(env, userId, data);
                    break;
                    
                case 'getDailyWithdrawalInfo':
                    result = await handleGetDailyWithdrawalInfo(env, userId);
                    break;
                    
                case 'getLeaderboard':
                    result = await handleGetLeaderboard(env);
                    break;
                    
                case 'testFirebase':
                    result = await handleTestFirebase(env);
                    break;
                    
                case 'getUserData':
                    result = await handleGetUserData(env, userId);
                    break;
                    
                case 'refreshCompetition':
                    result = await handleRefreshCompetition(env);
                    break;
                    
                case 'verifyTelegramMembership':
                    result = await handleVerifyTelegramMembership(env, userId, data);
                    break;
                    
                case 'syncUserCompetitionTickets':
                    result = await handleSyncUserCompetitionTickets(env, userId);
                    break;
                    
                case 'checkDeviceFingerprint':
                    result = await handleCheckDeviceFingerprint(env, userId, data);
                    break;
                    
                case 'saveDeviceFingerprint':
                    result = await handleSaveDeviceFingerprint(env, userId, data);
                    break;
                    
                case 'periodicDeviceCheck':
                    result = await handlePeriodicDeviceCheck(env, userId, data);
                    break;
                    
                case 'getClientIP':
                    result = await handleGetClientIP(clientIp);
                    break;
                    
                case 'testTelegramApi':
                    result = await handleTestTelegramApi(env, userId, data);
                    break;
                    
                case 'migrateWithdrawals':
                    result = await migrateWithdrawals(env);
                    break;
                    
                case 'getAllPromoCodes':
                    result = await handleGetAllPromoCodes(env);
                    break;
                    
                case 'getActivePromoCodes':
                    result = await handleGetActivePromoCodes(env);
                    break;
                    
                case 'createPromoCode':
                    result = await handleCreatePromoCode(env, userId, data);
                    break;
                    
                case 'verifyMandatoryChannels':
                    result = await handleVerifyMandatoryChannels(env, userId);
                    break;
                    
                default:
                    result = {
                        success: false,
                        error: 'Unknown action',
                        errorCode: 'UNKNOWN_ACTION'
                    };
            }
            
            // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù†ØªÙŠØ¬Ø©
            return new Response(JSON.stringify(result), {
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
            
        } catch (error) {
            console.error('Worker error:', error);
            
            return new Response(JSON.stringify({
                success: false,
                error: 'Internal server error',
                errorCode: 'INTERNAL_SERVER_ERROR',
                details: error.message,
                stack: error.stack
            }), {
                status: 500,
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
        }
    }
};

// ==================== Ù†Ø¸Ø§Ù… Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø² Ø§Ù„Ù…Ø­Ø³Ù† Ø¨Ø¯ÙˆÙ† Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¹Ù„Ù‰ IP ====================

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø² Ù…Ø³ØªØ®Ø¯Ù…Ø© Ù…Ø³Ø¨Ù‚Ù‹Ø§ (Ø¨Ø¯ÙˆÙ† Ø§Ù„Ù†Ø¸Ø± Ø¥Ù„Ù‰ Ø§Ù„Ù€ IP)
async function checkDeviceFingerprintWithoutIP(env, deviceFingerprint, currentUserId = null) {
    try {
        if (!deviceFingerprint) {
            return { deviceAlreadyUsed: false };
        }
        
        // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¹Ù† Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø²
        const usersResult = await handleDbGet(env, 'users');
        const usersData = usersResult.data || {};
        
        let existingAccounts = [];
        let oldestAccount = null;
        let oldestJoinDate = Infinity;
        let newAccountsBlocked = 0;
        
        // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ù†ÙØ³ Ø§Ù„Ø¬Ù‡Ø§Ø²
        for (const [userId, userData] of Object.entries(usersData)) {
            // ØªØ®Ø·ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§
            if (currentUserId && userId === currentUserId) continue;
            
            if (userData.deviceFingerprint === deviceFingerprint) {
                const accountInfo = {
                    userId: userId,
                    name: userData.name || 'Anonymous User',
                    photoUrl: userData.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                    joinDate: userData.joinDate,
                    lastLogin: userData.lastLogin,
                    isBlocked: userData.isBlocked || false
                };
                
                existingAccounts.push(accountInfo);
                
                // ØªØ­Ø¯ÙŠØ¯ Ø£Ù‚Ø¯Ù… Ø­Ø³Ø§Ø¨
                if (userData.joinDate && userData.joinDate < oldestJoinDate) {
                    oldestJoinDate = userData.joinDate;
                    oldestAccount = userId;
                }
            }
        }
        
        if (existingAccounts.length > 0) {
            console.log(`Found ${existingAccounts.length} existing accounts for device ${deviceFingerprint}`);
            console.log(`Oldest account: ${oldestAccount} with join date: ${new Date(oldestJoinDate).toISOString()}`);
            
            // Ø­Ø¸Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙÙ‚Ø· (Ø¹Ø¯Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆÙ„/Ø§Ù„Ø£Ù‚Ø¯Ù…)
            for (const account of existingAccounts) {
                // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù‡Ùˆ Ø§Ù„Ø£Ù‚Ø¯Ù… ÙˆÙ„Ù… ÙŠÙƒÙ† Ù…Ø­Ø¸ÙˆØ±Ù‹Ø§ Ø¨Ø§Ù„ÙØ¹Ù„
                if (account.userId !== oldestAccount && !account.isBlocked) {
                    await applyBlock(env, account.userId, {
                        reason: 'Device multi-account violation - Secondary account detected',
                        violation: 'DEVICE_MULTI_ACCOUNT',
                        action: 'deviceFingerprintCheck',
                        details: `Device fingerprint ${deviceFingerprint} already used by primary account ${oldestAccount}`,
                        timestamp: Date.now(),
                        permanent: true,
                        deviceFingerprint: deviceFingerprint,
                        isNewAccount: true
                    });
                    
                    newAccountsBlocked++;
                    console.log(`Blocked secondary account: ${account.userId}`);
                }
            }
            
            return {
                deviceAlreadyUsed: true,
                existingAccounts: existingAccounts,
                primaryAccount: oldestAccount,
                newAccountsBlocked: newAccountsBlocked,
                violationType: 'DEVICE_MULTI_ACCOUNT',
                accountsCount: existingAccounts.length,
                primaryAccountProtected: true
            };
        }
        
        return { deviceAlreadyUsed: false };
    } catch (error) {
        console.error('Error checking device fingerprint:', error);
        return { deviceAlreadyUsed: false };
    }
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø² (ØªÙ†Ø³ÙŠÙ‚ SHA-256)
function validateFingerprintFormat(fingerprint) {
    if (!fingerprint || typeof fingerprint !== 'string') {
        return { valid: false, error: 'Fingerprint is required' };
    }
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ (SHA-256: 64 Ø­Ø±ÙØ§Ù‹ hex)
    const sha256Regex = /^[a-f0-9]{64}$/i;
    if (!sha256Regex.test(fingerprint)) {
        return { valid: false, error: 'Invalid fingerprint format. Must be 64-character SHA-256 hash' };
    }
    
    return { valid: true };
}

// Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø²
async function handleCheckDeviceFingerprint(env, userId, data) {
    try {
        const { deviceFingerprint } = data;
        
        if (!deviceFingerprint) {
            return {
                success: false,
                error: 'Device fingerprint is required',
                errorCode: 'DEVICE_FINGERPRINT_REQUIRED'
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙ†Ø³ÙŠÙ‚
        const formatValidation = validateFingerprintFormat(deviceFingerprint);
        if (!formatValidation.valid) {
            return {
                success: false,
                error: formatValidation.error,
                errorCode: 'INVALID_FINGERPRINT_FORMAT'
            };
        }
        
        const fingerprintCheck = await checkDeviceFingerprintWithoutIP(env, deviceFingerprint, userId);
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¬Ù‡Ø§Ø² Ù…Ø³ØªØ®Ø¯Ù…Ù‹Ø§ØŒ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ Ù‡Ùˆ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆÙ„
        if (fingerprintCheck.deviceAlreadyUsed) {
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„ÙŠØ³ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆÙ„ØŒ ÙŠØªÙ… Ø­Ø¸Ø±Ù‡
            if (fingerprintCheck.primaryAccount !== userId) {
                await applyBlock(env, userId, {
                    reason: 'Device multi-account violation - New account detected',
                    violation: 'DEVICE_MULTI_ACCOUNT',
                    action: 'checkDeviceFingerprint',
                    details: `Device fingerprint ${deviceFingerprint} already used by ${fingerprintCheck.existingAccounts.length} other accounts`,
                    timestamp: Date.now(),
                    permanent: true,
                    deviceFingerprint: deviceFingerprint,
                    isNewAccount: true
                });
                
                return {
                    success: false,
                    error: 'ACCOUNT_BLOCKED',
                    errorCode: 'DEVICE_MULTI_ACCOUNT_BLOCKED',
                    data: {
                        deviceAlreadyUsed: true,
                        existingAccounts: fingerprintCheck.existingAccounts,
                        primaryAccount: fingerprintCheck.primaryAccount,
                        isPrimaryAccount: false,
                        violationType: 'DEVICE_MULTI_ACCOUNT',
                        accountsBlocked: fingerprintCheck.newAccountsBlocked + 1,
                        currentAccountBlocked: true,
                        blockedMessage: `ğŸš« Account Blocked\n\nReason: Device multi-account violation\nViolation: DEVICE_MULTI_ACCOUNT\n\nThis decision is final.`,
                        redirectToBlockPage: true
                    }
                };
            } else {
                // Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ Ù‡Ùˆ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆÙ„ØŒ Ù„Ø§ ÙŠØªÙ… Ø­Ø¸Ø±Ù‡
                return {
                    success: true,
                    data: {
                        deviceAlreadyUsed: true,
                        existingAccounts: fingerprintCheck.existingAccounts,
                        primaryAccount: fingerprintCheck.primaryAccount,
                        isPrimaryAccount: true,
                        newAccountsBlocked: fingerprintCheck.newAccountsBlocked,
                        message: 'You are the primary account on this device. Your account is protected.'
                    }
                };
            }
        }
        
        return {
            success: true,
            data: fingerprintCheck
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'DEVICE_CHECK_ERROR'
        };
    }
}

// Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­ÙØ¸ Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø²
async function handleSaveDeviceFingerprint(env, userId, data) {
    try {
        const { deviceFingerprint } = data;
        
        if (!deviceFingerprint) {
            return {
                success: false,
                error: 'Device fingerprint is required',
                errorCode: 'DEVICE_FINGERPRINT_REQUIRED'
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙ†Ø³ÙŠÙ‚
        const formatValidation = validateFingerprintFormat(deviceFingerprint);
        if (!formatValidation.valid) {
            return {
                success: false,
                error: formatValidation.error,
                errorCode: 'INVALID_FINGERPRINT_FORMAT'
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¨ØµÙ…Ø© Ù…Ø³ØªØ®Ø¯Ù…Ø© Ø¨Ø§Ù„ÙØ¹Ù„ Ù…Ù† Ù‚Ø¨Ù„ Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±
        const fingerprintCheck = await checkDeviceFingerprintWithoutIP(env, deviceFingerprint, userId);
        
        if (fingerprintCheck.deviceAlreadyUsed) {
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„ÙŠØ³ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆÙ„ØŒ ÙŠØªÙ… Ø­Ø¸Ø±Ù‡
            if (fingerprintCheck.primaryAccount !== userId) {
                // Ø­Ø¸Ø± Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙÙˆØ±Ù‹Ø§
                await applyBlock(env, userId, {
                    reason: 'Device multi-account violation',
                    violation: 'DEVICE_MULTI_ACCOUNT',
                    action: 'saveDeviceFingerprint',
                    details: 'Attempt to use device registered with another account',
                    timestamp: Date.now(),
                    permanent: true,
                    deviceFingerprint: deviceFingerprint,
                    isNewAccount: true
                });
                
                return {
                    success: false,
                    error: 'ACCOUNT_BLOCKED',
                    errorCode: 'DEVICE_MULTI_ACCOUNT_BLOCKED',
                    data: {
                        deviceAlreadyUsed: true,
                        existingAccounts: fingerprintCheck.existingAccounts,
                        primaryAccount: fingerprintCheck.primaryAccount,
                        isPrimaryAccount: false,
                        violationType: 'DEVICE_MULTI_ACCOUNT',
                        accountsBlocked: fingerprintCheck.newAccountsBlocked + 1,
                        currentAccountBlocked: true,
                        blockedMessage: `ğŸš« Account Blocked\n\nReason: Device multi-account violation\nViolation: DEVICE_MULTI_ACCOUNT\n\nThis decision is final.`,
                        redirectToBlockPage: true
                    }
                };
            }
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø¥Ø¶Ø§ÙØ© Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø²
        const updateData = {
            deviceFingerprint: deviceFingerprint,
            deviceRegisteredAt: Date.now(),
            lastDeviceCheck: Date.now(),
            deviceInfo: data.deviceInfo || {},
            deviceLoginCount: (userData.deviceLoginCount || 0) + 1,
            lastUpdated: Date.now()
        };
        
        await handleDbUpdate(env, `users/${userId}`, updateData);
        
        // Ø­ÙØ¸ ÙÙŠ Ø³Ø¬Ù„ Ø§Ù„Ø£Ø¬Ù‡Ø²Ø©
        await handleDbPush(env, 'devices/registry', {
            deviceFingerprint: deviceFingerprint,
            userId: userId,
            registeredAt: Date.now(),
            userAgent: data.userAgent || 'Unknown',
            deviceInfo: data.deviceInfo || {}
        });
        
        return {
            success: true,
            data: {
                message: 'Device fingerprint saved successfully',
                deviceRegisteredAt: Date.now(),
                deviceValidated: true
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'DEVICE_SAVE_ERROR'
        };
    }
}

// Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙØ­Øµ Ø§Ù„Ø¯ÙˆØ±ÙŠ Ù„Ù„Ø¬Ù‡Ø§Ø²
async function handlePeriodicDeviceCheck(env, userId, data) {
    try {
        const { deviceFingerprint } = data;
        
        if (!deviceFingerprint) {
            return {
                success: false,
                error: 'Device fingerprint is required',
                errorCode: 'DEVICE_FINGERPRINT_REQUIRED'
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙ†Ø³ÙŠÙ‚
        const formatValidation = validateFingerprintFormat(deviceFingerprint);
        if (!formatValidation.valid) {
            return {
                success: false,
                error: formatValidation.error,
                errorCode: 'INVALID_FINGERPRINT_FORMAT'
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø²
        const fingerprintCheck = await checkDeviceFingerprintWithoutIP(env, deviceFingerprint, userId);
        
        if (fingerprintCheck.deviceAlreadyUsed) {
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„ÙŠØ³ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆÙ„ØŒ ÙŠØªÙ… Ø­Ø¸Ø±Ù‡
            if (fingerprintCheck.primaryAccount !== userId) {
                // Ø­Ø¸Ø± Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙÙˆØ±Ù‹Ø§
                await applyBlock(env, userId, {
                    reason: 'Session multi-account violation',
                    violation: 'PERIODIC_DEVICE_MULTI_ACCOUNT',
                    action: 'periodicDeviceCheck',
                    details: 'Multiple accounts detected from same device during session',
                    timestamp: Date.now(),
                    permanent: true,
                    deviceFingerprint: deviceFingerprint,
                    isNewAccount: true
                });
                
                return {
                    success: true,
                    data: {
                        securityViolation: true,
                        deviceAlreadyUsed: true,
                        existingAccounts: fingerprintCheck.existingAccounts,
                        primaryAccount: fingerprintCheck.primaryAccount,
                        isPrimaryAccount: false,
                        violationType: 'SESSION_MULTI_ACCOUNT_DETECTED',
                        actionRequired: 'SESSION_TERMINATION',
                        currentAccountBlocked: true,
                        blockedMessage: `ğŸš« Account Blocked\n\nReason: Session multi-account violation\nViolation: PERIODIC_DEVICE_MULTI_ACCOUNT\n\nThis decision is final.`,
                        redirectToBlockPage: true
                    }
                };
            }
        }
        
        // ØªØ­Ø¯ÙŠØ« ÙˆÙ‚Øª Ø¢Ø®Ø± ÙØ­Øµ
        await handleDbUpdate(env, `users/${userId}`, {
            lastPeriodicCheck: Date.now(),
            deviceCheckCount: (data.deviceCheckCount || 0) + 1,
            lastUpdated: Date.now()
        });
        
        return {
            success: true,
            data: {
                securityViolation: false,
                lastCheck: Date.now()
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'PERIODIC_CHECK_ERROR'
        };
    }
}

// ==================== Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ====================

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ©
async function checkMandatorySubscriptions(env, userId) {
    try {
        const requiredChannels = [
            'earnmoney174688',
            'earnmoney1685', 
            'earnmoney139482',
            'EarnMoneyWithRedone'
        ];
        
        const subscriptionStatus = {};
        const missingChannels = [];
        
        for (const channel of requiredChannels) {
            try {
                const isMember = await checkTelegramMembershipDirect(env, userId, channel);
                subscriptionStatus[channel] = isMember;
                
                if (!isMember) {
                    missingChannels.push(channel);
                    // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
                    await logSubscriptionAttempt(env, userId, channel, false);
                }
            } catch (error) {
                console.error(`Error checking channel ${channel}:`, error);
                subscriptionStatus[channel] = false;
                missingChannels.push(channel);
            }
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø´ØªØ±ÙƒØ§Ù‹ ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§Øª
        const allSubscribed = Object.values(subscriptionStatus).every(status => status === true);
        
        return {
            success: allSubscribed,
            allSubscribed: allSubscribed,
            subscriptionStatus: subscriptionStatus,
            missingChannels: missingChannels
        };
    } catch (error) {
        console.error('Error in mandatory subscription check:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ù…Ù† Ø¹Ø¶ÙˆÙŠØ© Telegram
async function checkTelegramMembershipDirect(env, userId, channelUsername) {
    try {
        const botToken = env.TELEGRAM_BOT_TOKEN || '7066931017:AAHwuXbgaKHNrHrbf6jaoC8LDk0lSCPimgI';
        
        if (!botToken) {
            console.error('Bot token not configured');
            return false;
        }
        
        // ØªÙ†Ø¸ÙŠÙ Ø§Ø³Ù… Ø§Ù„Ù‚Ù†Ø§Ø©
        let cleanChannelUsername = channelUsername;
        
        if (cleanChannelUsername.includes('t.me/')) {
            cleanChannelUsername = cleanChannelUsername.split('t.me/')[1];
        }
        
        if (cleanChannelUsername.startsWith('@')) {
            cleanChannelUsername = cleanChannelUsername.substring(1);
        }
        
        const chatMemberUrl = `https://api.telegram.org/bot${botToken}/getChatMember`;
        
        const response = await fetch(chatMemberUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: `@${cleanChannelUsername}`,
                user_id: parseInt(userId)
            })
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error(`Telegram API error for ${cleanChannelUsername}:`, errorText);
            return false;
        }
        
        const result = await response.json();
        
        return result.ok && 
            (result.result.status === 'member' || 
             result.result.status === 'administrator' || 
             result.result.status === 'creator');
        
    } catch (error) {
        console.error('Telegram membership check error:', error);
        return false;
    }
}

// ØªØ³Ø¬ÙŠÙ„ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
async function logSubscriptionAttempt(env, userId, channel, success) {
    try {
        await handleDbPush(env, `subscriptionAttempts/${userId}`, {
            channel: channel,
            success: success,
            timestamp: Date.now(),
            userId: userId
        });
        return true;
    } catch (error) {
        console.error('Error logging subscription attempt:', error);
        return false;
    }
}

// Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ©
async function handleVerifyMandatoryChannels(env, userId) {
    try {
        const subscriptionCheck = await checkMandatorySubscriptions(env, userId);
        
        if (!subscriptionCheck.allSubscribed) {
            return {
                success: false,
                error: 'MANDATORY_SUBSCRIPTION_REQUIRED',
                errorCode: 'SUBSCRIPTION_REQUIRED',
                data: {
                    subscriptionRequired: true,
                    missingChannels: subscriptionCheck.missingChannels,
                    message: 'You must subscribe to all required channels first',
                    requiredChannels: [
                        { name: 'Earn Money', username: 'earnmoney174688' },
                        { name: 'Earn Money 2', username: 'earnmoney1685' },
                        { name: 'Earn Money 3', username: 'earnmoney139482' },
                        { name: 'Earn Money Redone', username: 'EarnMoneyWithRedone' }
                    ]
                }
            };
        }
        
        return {
            success: true,
            data: {
                allSubscribed: true,
                message: 'You are subscribed to all required channels',
                subscriptionStatus: subscriptionCheck.subscriptionStatus
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_MANDATORY_CHANNELS_ERROR'
        };
    }
}

// ==================== Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ø¸Ø± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø§Ù„Ù…Ø­Ø³Ù† ====================

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø·Ù„Ø¨
async function validateRequest(env, userId, action, data, requestTimestamp) {
    const now = Date.now();
    const MAX_TIME_DIFF = 120000; // 2 Ø¯Ù‚ÙŠÙ‚Ø© ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰ Ù„Ù„ÙØ±Ù‚ Ø§Ù„Ø²Ù…Ù†ÙŠ
    
    // 1. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø·Ø§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠ ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§
    if (requestTimestamp) {
        const timeDiff = Math.abs(now - parseInt(requestTimestamp));
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙØ±Ù‚ ÙƒØ¨ÙŠØ±Ù‹Ø§ Ø¬Ø¯Ù‹Ø§ (Ø£ÙƒØ«Ø± Ù…Ù† 2 Ø¯Ù‚ÙŠÙ‚Ø©)ØŒ Ù†Ø±ÙØ¶ Ø§Ù„Ø·Ù„Ø¨ Ù„ÙƒÙ† Ø¨Ø¯ÙˆÙ† Ø­Ø¸Ø±
        if (timeDiff > MAX_TIME_DIFF) {
            return {
                valid: false,
                violation: 'TIMESTAMP_EXPIRED',
                details: `Timestamp difference too large: ${timeDiff}ms (max ${MAX_TIME_DIFF}ms)`,
                shouldBlock: false // Ù„Ø§ Ø­Ø¸Ø±ØŒ ÙÙ‚Ø· Ø±ÙØ¶ Ø§Ù„Ø·Ù„Ø¨
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†ÙØ³ Ø§Ù„Ø·Ø§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠ Ù…Ø³Ø¨Ù‚Ù‹Ø§
        const isDuplicate = await checkDuplicateTimestamp(env, userId, requestTimestamp);
        if (isDuplicate) {
            // Ø§Ù„Ø­Ø¸Ø± ÙÙ‚Ø· Ù„Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†Ø§ØªØŒ Ù„Ù„Ø¨Ø§Ù‚ÙŠ Ø®Ø·Ø£ ÙÙ‚Ø·
            if (action === 'handleAdClick') {
                return {
                    valid: false,
                    violation: 'DUPLICATE_TIMESTAMP',
                    details: 'Timestamp already used - potential replay attack',
                    shouldBlock: true // Ù‡Ø°Ø§ ÙÙ‚Ø· Ø§Ù„Ø°ÙŠ ÙŠØ³ØªØ­Ù‚ Ø§Ù„Ø­Ø¸Ø±
                };
            } else {
                return {
                    valid: false,
                    violation: 'DUPLICATE_TIMESTAMP',
                    details: 'Timestamp already used - please try again',
                    shouldBlock: false // Ø®Ø·Ø£ ÙÙ‚Ø·
                };
            }
        }
    }
    
    // 2. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‚ÙŠÙ… Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡
    if (action === 'handleAdClick') {
        return await validateAdRequest(env, userId, data);
    }
    
    if (action === 'redeemPromoCode') {
        return await validatePromoCodeRequest(env, userId, data);
    }
    
    if (action === 'verifyTaskCompletion') {
        return await validateTaskRequest(env, userId, data);
    }
    
    if (action === 'buyTickets') {
        return await validateTicketPurchase(env, userId, data);
    }
    
    if (action === 'flipCoin') {
        return await validateCoinFlip(env, userId, data);
    }
    
    if (action === 'spinSlots') {
        return await validateSlotSpin(env, userId);
    }
    
    if (action === 'claimDailyBonus') {
        return await validateDailyBonus(env, userId);
    }
    
    // 3. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù…Ù‡Ø§Ù… ÙˆØ§Ù„Ù…ÙƒØ§ÙØ¢Øª
    if (action === 'verifyTaskCompletion' || action === 'verifyTaskChannel') {
        return await validateTaskReward(env, userId, data, action);
    }
    
    // 4. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…ØªØ·Ù„Ø¨Ø§Øª Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³Ø©
    if (action === 'submitWithdrawal') {
        return await validateWithdrawalRequest(env, userId, data);
    }
    
    if (action === 'executeSwap') {
        return await validateSwapRequest(env, userId, data);
    }
    
    if (action === 'verifyDeposit') {
        return await validateDepositRequest(env, userId, data);
    }
    
    return { valid: true };
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø·Ù„Ø¨ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†
async function validateAdRequest(env, userId, data) {
    const { adType, reward } = data;
    
    // Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„ØµØ­ÙŠØ­Ø©
    const configResult = await handleGetConfig();
    const settings = configResult.data?.settings || {};
    
    // Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡Ø§ Ù„ÙƒÙ„ Ù†ÙˆØ¹ Ø¥Ø¹Ù„Ø§Ù† (Ø¬Ù…ÙŠØ¹Ù‡Ø§ 500 Ø¹Ù…Ù„Ø© ÙÙ‚Ø·)
    const allowedRewards = {
        'monetag': 500,
        'giga': 500,
        'adsgram': 500
    };
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†
    if (!allowedRewards[adType]) {
        return {
            valid: false,
            violation: 'INVALID_AD_TYPE',
            details: `Invalid ad type: ${adType}`
        };
    }
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© (ÙŠØ¬Ø¨ Ø£Ù† ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ù‚ÙŠÙ…Ø© ÙÙŠ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ø§Ù„Ø¶Ø¨Ø·)
    const allowedReward = allowedRewards[adType];
    const requestedReward = parseInt(reward);
    
    if (requestedReward !== allowedReward) {
        return {
            valid: false,
            violation: 'REWARD_MANIPULATION',
            details: `Ad reward manipulation: Expected ${allowedReward}, got ${requestedReward}`
        };
    }
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø¥Ø¹Ù„Ø§Ù†Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
    const userResult = await handleDbGet(env, `users/${userId}`);
    if (userResult.success && userResult.data) {
        const userData = userResult.data;
        const adCountField = `ads${adType.charAt(0).toUpperCase() + adType.slice(1)}`;
        
        // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
        const adLimitField = `limit${adType.charAt(0).toUpperCase() + adType.slice(1)}`;
        const limit = settings[adLimitField] || 50;
        
        if (userData[adCountField] >= limit) {
            return {
                valid: false,
                violation: 'AD_LIMIT_EXCEEDED',
                details: `Ad limit exceeded for ${adType}`
            };
        }
    }
    
    return { valid: true };
}

// ==================== Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ù„Ù„Ø³Ø­ÙˆØ¨Ø§Øª ====================

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ù„Ù„Ø³Ø­ÙˆØ¨Ø§Øª
async function checkDailyWithdrawalLimit(env, userId) {
    try {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);
        
        // Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø³Ø­ÙˆØ¨Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
        const withdrawalsResult = await handleDbGet(env, 'withdrawals/pending');
        const completedResult = await handleDbGet(env, 'withdrawals/completed');
        
        const pendingData = withdrawalsResult.data || {};
        const completedData = completedResult.data || {};
        
        let todayWithdrawals = 0;
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø­ÙˆØ¨Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø© Ø§Ù„ÙŠÙˆÙ…
        for (const [key, withdrawal] of Object.entries(pendingData)) {
            if (withdrawal.userId === userId && 
                withdrawal.timestamp >= today.getTime() && 
                withdrawal.timestamp < tomorrow.getTime()) {
                todayWithdrawals++;
            }
        }
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø­ÙˆØ¨Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© Ø§Ù„ÙŠÙˆÙ…
        for (const [key, withdrawal] of Object.entries(completedData)) {
            if (withdrawal.userId === userId && 
                withdrawal.timestamp >= today.getTime() && 
                withdrawal.timestamp < tomorrow.getTime() &&
                withdrawal.status === 'completed') {
                todayWithdrawals++;
            }
        }
        
        const dailyLimit = 2; // Ø³Ø­Ø¨ØªÙŠÙ† ÙÙŠ Ø§Ù„ÙŠÙˆÙ…
        
        return {
            todayWithdrawals: todayWithdrawals,
            dailyLimit: dailyLimit,
            limitReached: todayWithdrawals >= dailyLimit,
            remaining: Math.max(0, dailyLimit - todayWithdrawals),
            resetTime: tomorrow.getTime()
        };
    } catch (error) {
        console.error('Error checking daily withdrawal limit:', error);
        return {
            todayWithdrawals: 0,
            dailyLimit: 2,
            limitReached: false,
            remaining: 2,
            resetTime: Date.now() + 86400000
        };
    }
}

// Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø­Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ù„Ù„Ø³Ø­ÙˆØ¨Ø§Øª
async function handleGetDailyWithdrawalInfo(env, userId) {
    try {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const limitInfo = await checkDailyWithdrawalLimit(env, userId);
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);
        
        return {
            success: true,
            data: {
                todayWithdrawals: limitInfo.todayWithdrawals,
                dailyLimit: limitInfo.dailyLimit,
                remaining: limitInfo.remaining,
                resetTime: tomorrow.toLocaleString(),
                resetTimestamp: tomorrow.getTime(),
                resetIn: tomorrow.getTime() - Date.now(),
                canWithdraw: limitInfo.remaining > 0
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_DAILY_WITHDRAWAL_INFO_ERROR'
        };
    }
}

// ==================== Ø¯ÙˆØ§Ù„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ§Ù„Ù…ÙƒØ§ÙØ¢Øª Ø§Ù„Ù…Ø¹Ø¯Ù„Ø© ====================

async function handleGetConfig() {
    try {
        const settings = {
            // Ù…ÙƒØ§ÙØ¢Øª Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†Ø§Øª - Ø¬Ù…ÙŠØ¹Ù‡Ø§ 500 Ø¹Ù…Ù„Ø© ÙÙ‚Ø·
            adRewardMonetag: 500,
            adRewardGiga: 500,
            adRewardAdsgram: 500,
            
            // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
            limitMonetag: 50,
            limitGiga: 300,
            limitAdsgram: 300,
            
            // Ø³Ø¹Ø± Ø§Ù„ØªØ°ÙƒØ±Ø©
            ticketPrice: 10000, // Ø³Ø¹Ø± Ø§Ù„ØªØ°ÙƒØ±Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø© = 10,000 GLX
            maxTicketsPerPurchase: 100,
            minTicketsPerPurchase: 1,
            
            // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø³Ø­Ø¨
            minTonWithdrawal: 0.05,
            minFaucetPayWithdrawal: 0.0001,
            
            // Ù†Ø¸Ø§Ù… Ø§Ù„Ø¥Ø­Ø§Ù„Ø© - 100,000 GLX
            referralReward: 100000,
            
            // Ø£Ø³Ø¹Ø§Ø± Ø£Ø®Ø±Ù‰
            pricePerClick: 0.0015,
            
            // Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª
            botUsername: '@testtt1257bot',
            botWallet: 'UQB2IqqJtC8NtRgxksq80c_FC8RqShxpGDKA3e4aJFwjvwgv',
            botToken: '7066931017:AAHwuXbgaKHNrHrbf6jaoC8LDk0lSCPimgI',
            
            // Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ø¸Ø±
            maxTimestampDiff: 120000, // 2 Ø¯Ù‚ÙŠÙ‚Ø© ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰
            maxViolations: 1, // Ù…Ø®Ø§Ù„ÙØ© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø· Ù„Ù„Ø­Ø¸Ø±
            blockDuration: 0, // Ø­Ø¸Ø± Ø¯Ø§Ø¦Ù…
            instantBlock: true, // Ø­Ø¸Ø± ÙÙˆØ±ÙŠ Ø¨Ø¹Ø¯ Ù…Ø®Ø§Ù„ÙØ© ÙˆØ§Ø­Ø¯Ø©
            
            // Coin Flip limits
            coinFlipMinBet: 1000, // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø±Ù‡Ø§Ù†
            coinFlipMaxBet: 100000, // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø±Ù‡Ø§Ù†
            coinFlipDailyLimit: 1000000, // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ù„Ù„Ù…ÙƒØ§Ø³Ø¨
            
            // Ù…ÙƒØ§ÙØ¢Øª Ø§Ù„Ù…Ù‡Ø§Ù…
            taskChannelReward: 2000, // Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ù„Ù‚Ù†Ø§Ø©
            maxTaskReward: 20000, // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ù…Ù‡Ù…Ø©
            
            // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯
            maxPromoReward: 10000, // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯
            
            // Ù†Ø¸Ø§Ù… Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø²
            enableDeviceFingerprint: true, // ØªÙØ¹ÙŠÙ„ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø²
            allowMultipleDevices: false, // Ø¹Ø¯Ù… Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø£Ø¬Ù‡Ø²Ø© Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            deviceCheckRequired: true, // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¬Ù‡Ø§Ø² Ù…Ø·Ù„ÙˆØ¨ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¬Ø¯Ø¯
            
            // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ù…Ø§Ù†
            periodicDeviceCheckInterval: 30000, // ÙØ­Øµ Ø¯ÙˆØ±ÙŠ ÙƒÙ„ 30 Ø«Ø§Ù†ÙŠØ©
            enableIpTracking: false, // Ø¥ÙŠÙ‚Ø§Ù ØªØªØ¨Ø¹ Ø¹Ù†Ø§ÙˆÙŠÙ† IP
            multiAccountDetection: true, // ÙƒØ´Ù Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
            multiAccountAutoBlock: true, // Ø­Ø¸Ø± ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
            protectPrimaryAccount: true, // Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆÙ„ ÙÙ‚Ø·
            
            // Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ù„Ù„Ø³Ø­ÙˆØ¨Ø§Øª
            dailyWithdrawalLimit: 2, // Ø³Ø­Ø¨ØªÙŠÙ† ÙÙŠ Ø§Ù„ÙŠÙˆÙ…
            withdrawalLimitEnabled: true, // ØªÙØ¹ÙŠÙ„ Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠ
            
            // Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ©
            mandatoryChannels: [
                'earnmoney174688',
                'earnmoney1685', 
                'earnmoney139482',
                'EarnMoneyWithRedone'
            ]
        };
        
        return {
            success: true,
            data: { settings }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_CONFIG_ERROR'
        };
    }
}

// ==================== Ø¯Ø§Ù„Ø© initializeUser Ø§Ù„Ù…Ø¹Ø¯Ù„Ø© ====================

async function handleInitializeUser(env, userId, data, telegramData) {
    try {
        const { user, skipSubscriptionCheck } = data;
        const deviceFingerprint = data.deviceFingerprint;
        const fullName = `${user.first_name} ${user.last_name || ''}`.trim();
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return {
                success: false,
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: {
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        // ==================== Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ====================
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£ÙˆÙ„Ø§Ù‹ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¬Ø¯ÙŠØ¯Ø§Ù‹
        const userResult = await handleDbGet(env, `users/${userId}`);
        const existingUserData = userResult.data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ ÙÙ‚Ø· Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¬Ø¯Ø¯ (Ø§Ù„Ø°ÙŠÙ† Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù‡Ù…) ÙˆÙ„Ù… ÙŠØªÙ… ØªØ¬Ø§ÙˆØ²Ù‡
        if ((!userResult.success || !existingUserData) && !skipSubscriptionCheck) {
            const subscriptionCheck = await checkMandatorySubscriptions(env, userId);
            
            if (!subscriptionCheck.allSubscribed) {
                return {
                    success: false,
                    error: 'MANDATORY_SUBSCRIPTION_REQUIRED',
                    errorCode: 'SUBSCRIPTION_REQUIRED',
                    data: {
                        subscriptionRequired: true,
                        missingChannels: subscriptionCheck.missingChannels,
                        message: 'You must subscribe to all required channels first',
                        requiredChannels: [
                            { name: 'Earn Money', username: 'earnmoney174688' },
                            { name: 'Earn Money 2', username: 'earnmoney1685' },
                            { name: 'Earn Money 3', username: 'earnmoney139482' },
                            { name: 'Earn Money Redone', username: 'EarnMoneyWithRedone' }
                        ]
                    }
                };
            }
        }
        
        // ==================== Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø² ====================
        if (deviceFingerprint) {
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¨ØµÙ…Ø©
            const formatValidation = validateFingerprintFormat(deviceFingerprint);
            if (!formatValidation.valid) {
                return {
                    success: false,
                    error: formatValidation.error,
                    errorCode: 'INVALID_FINGERPRINT_FORMAT'
                };
            }
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø² Ù…Ø³ØªØ®Ø¯Ù…Ø© Ø¨Ø§Ù„ÙØ¹Ù„ Ù…Ù† Ù‚Ø¨Ù„ Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±
            const fingerprintCheck = await checkDeviceFingerprintWithoutIP(env, deviceFingerprint, userId);
            
            if (fingerprintCheck.deviceAlreadyUsed) {
                // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„ÙŠØ³ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆÙ„ØŒ ÙŠØªÙ… Ø­Ø¸Ø±Ù‡
                if (fingerprintCheck.primaryAccount !== userId) {
                    // Ø­Ø¸Ø± Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙÙˆØ±Ù‹Ø§
                    await applyBlock(env, userId, {
                        reason: 'Device multi-account violation during initialization',
                        violation: 'DEVICE_MULTI_ACCOUNT',
                        action: 'initializeUser',
                        details: 'Attempt to create new account with device registered to another account',
                        timestamp: Date.now(),
                        permanent: true,
                        deviceFingerprint: deviceFingerprint,
                        isNewAccount: true
                    });
                    
                    return {
                        success: false,
                        error: 'ACCOUNT_BLOCKED',
                        errorCode: 'DEVICE_MULTI_ACCOUNT_BLOCKED',
                        data: {
                            deviceAlreadyUsed: true,
                            existingAccounts: fingerprintCheck.existingAccounts,
                            primaryAccount: fingerprintCheck.primaryAccount,
                            isPrimaryAccount: false,
                            violationType: 'DEVICE_MULTI_ACCOUNT',
                            accountsBlocked: fingerprintCheck.newAccountsBlocked + 1,
                            currentAccountBlocked: true,
                            blockedMessage: `ğŸš« Account Blocked\n\nReason: Device multi-account violation\nViolation: DEVICE_MULTI_ACCOUNT\n\nThis decision is final.`,
                            redirectToBlockPage: true
                        }
                    };
                }
            }
        }
        // ==================== Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø² ====================
        
        // 1. Ø£ÙˆÙ„Ø§Ù‹: Ø¶Ù…Ø§Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ø´Ø·Ø© ÙˆØ¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§ØªÙ‡Ø§
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to initialize competition',
                errorCode: 'COMPETITION_INIT_ERROR'
            };
        }
        
        // 2. Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const userResult2 = await handleDbGet(env, `users/${userId}`);
        let userData = userResult2.data;
        
        // Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„ØªØ°Ø§ÙƒØ± Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ù…Ù† Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©
        const realTicketCount = competitionData.userTicketCount || 0;
        
        // Ø§Ø³ØªØ®Ø±Ø§Ø¬ ØµÙˆØ±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Telegram
        let photoUrl = 'https://i.ibb.co/tTkJX1Qy/logo.png'; // ØµÙˆØ±Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
        
        try {
            const params = new URLSearchParams(telegramData);
            const userParam = params.get('user');
            
            if (userParam) {
                const telegramUserData = JSON.parse(decodeURIComponent(userParam));
                // ØµÙˆØ±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Telegram
                if (telegramUserData.photo_url) {
                    photoUrl = telegramUserData.photo_url;
                } else if (telegramUserData.username) {
                    // Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… ØµÙˆØ±Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
                    photoUrl = `https://ui-avatars.com/api/?name=${encodeURIComponent(telegramUserData.username)}&background=random&color=fff`;
                }
            }
        } catch (photoError) {
            console.log('Could not extract user photo:', photoError);
        }
        
        if (!userData) {
            // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯
            userData = {
                id: userId,
                name: fullName,
                photoUrl: photoUrl,
                dogsBalance: 500,
                tonBalance: 0.00,
                adsWatched: 0,
                adsMonetag: 0,
                adsGiga: 0,
                adsAdsgram: 0,
                completedTasks: {},
                history: {},
                referrals: 0,
                dailyStreak: 0,
                lastDailyClaim: 0,
                extraSpins: 1,
                referredUsers: [],
                usedPromoCodes: [],
                joinDate: Date.now(),
                lastLogin: Date.now(),
                lastAdDate: new Date().toDateString(),
                competitionTickets: realTicketCount,
                lastTicketSync: Date.now(),
                isBlocked: false,
                blockReason: null,
                blockedAt: null,
                violationCount: 0,
                lastUpdated: Date.now(),
                // Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ù…Ø§Ù†
                ...(deviceFingerprint && {
                    deviceFingerprint: deviceFingerprint,
                    deviceRegisteredAt: Date.now(),
                    lastDeviceCheck: Date.now(),
                    deviceInfo: data.deviceInfo || {},
                    deviceLoginCount: 1
                }),
                // Ø³Ø¬Ù„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ
                mandatoryChannelsSubscribed: true,
                subscriptionVerifiedAt: Date.now()
            };
            
            await handleDbSet(env, `users/${userId}`, userData);
            
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'earn',
                description: 'Welcome Bonus',
                amount: 500,
                currency: 'GLX',
                date: new Date().toISOString(),
                securityCheck: 'initialized',
                mandatoryChannelsVerified: true
            });
            
            console.log(`New user created: ${userId} with device fingerprint: ${deviceFingerprint ? 'Yes' : 'No'}`);
        } else {
            // ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯
            const updates = {
                name: fullName,
                lastLogin: Date.now(),
                lastUpdated: Date.now()
            };
            
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙˆØ±Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø© Ø£Ùˆ Ù…Ø®ØªÙ„ÙØ©
            if (!userData.photoUrl || userData.photoUrl === 'https://i.ibb.co/tTkJX1Qy/logo.png') {
                updates.photoUrl = photoUrl;
            }
            
            // ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø¯ ØªØ°Ø§ÙƒØ± Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ù…Ù† Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
            if (userData.competitionTickets !== realTicketCount) {
                updates.competitionTickets = realTicketCount;
                updates.lastTicketSync = Date.now();
                console.log(`Updating user ${userId} tickets from ${userData.competitionTickets} to ${realTicketCount}`);
            }
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø± ÙÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            if (userData.isBlocked) {
                const blockStatus = await checkUserBlocked(env, userId);
                if (blockStatus && blockStatus.isBlocked) {
                    return {
                        success: false,
                        error: 'ACCOUNT_BLOCKED',
                        errorCode: 'ACCOUNT_BLOCKED',
                        data: { 
                            isBlocked: true,
                            blockDetails: blockStatus,
                            blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockStatus.reason}\nViolation: ${blockStatus.violation}\n\nThis decision is final.`,
                            redirectToBlockPage: true
                        }
                    };
                } else {
                    updates.isBlocked = false;
                    updates.blockReason = null;
                    updates.blockedAt = null;
                }
            }
            
            // ØªØ­Ø¯ÙŠØ« Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø² Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø© ÙˆÙƒØ§Ù†Øª Ù…ØªÙˆÙØ±Ø©
            if (!userData.deviceFingerprint && deviceFingerprint) {
                updates.deviceFingerprint = deviceFingerprint;
                updates.deviceRegisteredAt = Date.now();
                updates.lastDeviceCheck = Date.now();
                updates.deviceInfo = data.deviceInfo || {};
                updates.deviceLoginCount = (userData.deviceLoginCount || 0) + 1;
            } else if (deviceFingerprint) {
                // ØªØ­Ø¯ÙŠØ« Ø¢Ø®Ø± ÙØ­Øµ Ù„Ù„Ø¬Ù‡Ø§Ø²
                updates.lastDeviceCheck = Date.now();
                updates.deviceLoginCount = (userData.deviceLoginCount || 0) + 1;
            }
            
            if (Object.keys(updates).length > 0) {
                await handleDbUpdate(env, `users/${userId}`, updates);
            }
            
            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†Ø§Øª Ø¥Ø°Ø§ ØªØºÙŠØ± Ø§Ù„ÙŠÙˆÙ…
            const today = new Date().toDateString();
            if (userData.lastAdDate !== today) {
                const resetData = {
                    adsWatched: 0,
                    adsMonetag: 0,
                    adsGiga: 0,
                    adsAdsgram: 0,
                    lastAdDate: today,
                    lastUpdated: Date.now()
                };
                
                await handleDbUpdate(env, `users/${userId}`, resetData);
            }
            
            // ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø¹Ø¯ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
            const updatedResult = await handleDbGet(env, `users/${userId}`);
            userData = updatedResult.data || userData;
            
            console.log(`Existing user logged in: ${userId} with device fingerprint: ${deviceFingerprint ? 'Yes' : 'No'}`);
        }
        
        // Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
        const settingsResult = await handleGetConfig();
        const settings = settingsResult.data?.settings || {};
        
        // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø¹Ø¯Ø¯ Ø§Ù„ØªØ°Ø§ÙƒØ± ÙŠØ¹ÙƒØ³ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©
        const userTickets = realTicketCount;
        
        return {
            success: true,
            data: {
                userData: {
                    ...userData,
                    competitionTickets: userTickets,
                    deviceFingerprint: deviceFingerprint || userData.deviceFingerprint,
                    mandatoryChannelsSubscribed: userData.mandatoryChannelsSubscribed || true
                },
                settings: settings,
                contest: {
                    yourTickets: userTickets,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    isActive: competitionData.isActiveNow,
                    endTime: competitionData.endTime,
                    startTime: competitionData.startTime,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted || '24:00:00'
                },
                securityInfo: {
                    deviceVerified: !!deviceFingerprint,
                    mandatoryChannelsVerified: userData.mandatoryChannelsSubscribed || true,
                    multiAccountCheck: true
                },
                subscriptionInfo: {
                    required: true,
                    verified: userData.mandatoryChannelsSubscribed || true
                }
            }
        };
    } catch (error) {
        console.error('Initialize user error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'INITIALIZE_USER_ERROR'
        };
    }
}

// ==================== Ø¯Ø§Ù„Ø© handleAdClick Ø§Ù„Ù…Ø¹Ø¯Ù„Ø© (500 Ø¹Ù…Ù„Ø© ÙÙ‚Ø·) ====================

async function handleAdClick(env, userId, adType, reward) {
    try {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        const adCountField = `ads${capitalizeFirstLetter(adType)}`;
        const currentCount = userData[adCountField] || 0;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ù‡ÙŠ 500 ÙÙ‚Ø·
        const expectedReward = 500;
        if (parseInt(reward) !== expectedReward) {
            return {
                success: false,
                error: 'Invalid reward amount',
                errorCode: 'INVALID_AD_REWARD',
                data: {
                    expected: expectedReward,
                    received: reward
                }
            };
        }
        
        const updates = {
            [adCountField]: currentCount + 1,
            adsWatched: (userData.adsWatched || 0) + 1,
            dogsBalance: (userData.dogsBalance || 0) + expectedReward,
            lastUpdated: Date.now(),
            lastActivity: Date.now()
        };
        
        await handleDbUpdate(env, `users/${userId}`, updates);
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: `${adType} Ad Reward`,
            amount: expectedReward,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || { ...userData, ...updates };
        
        return {
            success: true,
            data: {
                [adCountField]: currentCount + 1,
                adsWatched: updates.adsWatched,
                newBalance: updatedUserData.dogsBalance,
                reward: expectedReward,
                updatedUserData: updatedUserData
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'HANDLE_AD_CLICK_ERROR'
        };
    }
}

// ==================== Ø¯Ø§Ù„Ø© submitWithdrawal Ø§Ù„Ù…Ø¹Ø¯Ù„Ø© Ù…Ø¹ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„ÙŠÙˆÙ…ÙŠ ====================

async function handleSubmitWithdrawal(env, userId, data) {
    try {
        const { method, account, amount, maskedAccount, memo } = data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ù„Ù„Ø³Ø­ÙˆØ¨Ø§Øª
        const limitCheck = await checkDailyWithdrawalLimit(env, userId);
        if (limitCheck.limitReached) {
            return { 
                success: false, 
                error: 'DAILY_WITHDRAWAL_LIMIT_REACHED',
                errorCode: 'DAILY_WITHDRAWAL_LIMIT_REACHED',
                data: {
                    message: `Daily withdrawal limit reached! You can only make ${limitCheck.dailyLimit} withdrawals per day.`,
                    todayWithdrawals: limitCheck.todayWithdrawals,
                    dailyLimit: limitCheck.dailyLimit,
                    remaining: limitCheck.remaining,
                    resetTime: limitCheck.resetTime
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        // Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø³Ø­Ø¨
        const configResult = await handleGetConfig();
        const settings = configResult.data?.settings || {};
        
        let minAmount = 0.05; // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ
        if (method === 'ton') {
            minAmount = settings.minTonWithdrawal || 0.05;
        } else if (method === 'faucetpay') {
            minAmount = settings.minFaucetPayWithdrawal || 0.0001;
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø³Ø­Ø¨
        if (parseFloat(amount) < minAmount) {
            return { 
                success: false, 
                error: `Minimum withdrawal amount is ${minAmount} ${method === 'ton' ? 'TON' : 'USD'}`,
                errorCode: 'MINIMUM_WITHDRAWAL_AMOUNT',
                data: { 
                    minAmount: minAmount,
                    requestedAmount: amount,
                    method: method
                }
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„ÙƒØ§ÙÙŠ
        if ((userData.tonBalance || 0) < parseFloat(amount)) {
            return { 
                success: false, 
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON_BALANCE',
                data: {
                    currentBalance: userData.tonBalance || 0,
                    requiredAmount: parseFloat(amount),
                    difference: parseFloat(amount) - (userData.tonBalance || 0)
                }
            };
        }
        
        // Ø®ØµÙ… Ø§Ù„Ù…Ø¨Ù„Øº Ù…Ù† Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const newBalance = (userData.tonBalance || 0) - parseFloat(amount);
        await handleDbUpdate(env, `users/${userId}`, { 
            tonBalance: newBalance,
            lastUpdated: Date.now(),
            lastWithdrawal: Date.now()
        });
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¹Ø±Ù ÙØ±ÙŠØ¯ Ù„Ù„Ø³Ø­Ø¨
        const withdrawalId = `withdrawal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø­Ø¨ Ù…Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙƒØ§Ù…Ù„Ø©
        const withdrawalData = {
            userId: userId,
            account: account,
            maskedAccount: maskedAccount || account,
            amount: parseFloat(amount),
            method: method,
            memo: memo || '',
            status: 'pending',
            timestamp: Date.now(),
            processed: false,
            // Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©
            username: userData.username || userData.name || 'Unknown',
            first_name: userData.first_name || userData.name?.split(' ')[0] || 'Unknown',
            last_name: userData.last_name || userData.name?.split(' ').slice(1).join(' ') || '',
            userData: {
                name: userData.name || 'Unknown',
                photoUrl: userData.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                joinDate: userData.joinDate,
                totalEarnings: userData.dogsBalance || 0,
                tonBalance: newBalance,
                referrals: userData.referrals || 0
            }
        };
        
        // Ø­ÙØ¸ Ø§Ù„Ø³Ø­Ø¨ ÙÙŠ Ù…Ø¬Ù„Ø¯ pending
        await handleDbSet(env, `withdrawals/pending/${withdrawalId}`, withdrawalData);
        
        // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙÙŠ Ø³Ø¬Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'withdraw',
            description: `${method === 'ton' ? 'TON Wallet' : 'FaucetPay'} Withdrawal`,
            amount: parseFloat(amount),
            currency: 'TON',
            date: new Date().toISOString(),
            withdrawalId: withdrawalId,
            status: 'pending',
            account: maskedAccount || account
        });
        
        // ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø³Ø­ÙˆØ¨Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
        await handleDbUpdate(env, `users/${userId}`, {
            dailyWithdrawals: limitCheck.todayWithdrawals + 1,
            lastWithdrawalDate: Date.now(),
            lastUpdated: Date.now()
        });
        
        // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        return {
            success: true,
            data: {
                newBalance: newBalance,
                withdrawalId: withdrawalId,
                withdrawalData: withdrawalData,
                updatedUserData: updatedUserData,
                dailyWithdrawals: limitCheck.todayWithdrawals + 1,
                dailyLimit: limitCheck.dailyLimit,
                remainingToday: Math.max(0, limitCheck.dailyLimit - (limitCheck.todayWithdrawals + 1)),
                message: 'Withdrawal request submitted successfully. It will be processed within 24 hours.'
            }
        };
    } catch (error) {
        console.error('Submit withdrawal error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'SUBMIT_WITHDRAWAL_ERROR'
        };
    }
}

// ==================== Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ====================

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Telegram
function isValidTelegramData(telegramData, userId) {
    try {
        const params = new URLSearchParams(telegramData);
        const userParam = params.get('user');
        
        if (!userParam) return false;
        
        const userData = JSON.parse(decodeURIComponent(userParam));
        return userData.id.toString() === userId;
        
    } catch (error) {
        console.error('Telegram data validation error:', error);
        return false;
    }
}

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø£ÙˆÙ„ Ø­Ø±Ù Ø¥Ù„Ù‰ ÙƒØ¨ÙŠØ±
function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
async function checkUserBlocked(env, userId) {
    try {
        const blockResult = await handleDbGet(env, `blocks/${userId}`);
        if (blockResult.success && blockResult.data) {
            const blockData = blockResult.data;
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ø¯Ø© Ø§Ù„Ø­Ø¸Ø±
            if (blockData.expiresAt && blockData.expiresAt > Date.now()) {
                return {
                    isBlocked: true,
                    reason: blockData.reason || 'Account blocked',
                    violation: blockData.violation || 'UNKNOWN',
                    appliedAt: blockData.appliedAt,
                    expiresAt: blockData.expiresAt,
                    permanent: blockData.permanent || false,
                    details: blockData.details || 'No details provided',
                    blockType: 'TEMPORARY_BLOCK'
                };
            } else if (blockData.permanent) {
                return {
                    isBlocked: true,
                    reason: blockData.reason || 'Permanently blocked',
                    violation: blockData.violation || 'UNKNOWN',
                    appliedAt: blockData.appliedAt,
                    permanent: true,
                    details: blockData.details || 'Account permanently blocked',
                    blockType: 'PERMANENT_BLOCK'
                };
            }
            
            // Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Øª Ù…Ø¯Ø© Ø§Ù„Ø­Ø¸Ø± Ø§Ù„Ù…Ø¤Ù‚ØªØŒ Ø¥Ø²Ø§Ù„ØªÙ‡
            if (blockData.expiresAt && blockData.expiresAt <= Date.now()) {
                await handleDbSet(env, `blocks/${userId}`, null);
                await handleDbUpdate(env, `users/${userId}`, {
                    isBlocked: false,
                    blockReason: null,
                    blockedAt: null
                });
                return false;
            }
        }
        
        return false;
    } catch (error) {
        console.error('Error checking user block:', error);
        return false;
    }
}

// ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ø¸Ø±
async function applyBlock(env, userId, blockData) {
    try {
        const blockInfo = {
            userId: userId,
            reason: blockData.reason || 'System violation detected',
            violation: blockData.violation || 'UNKNOWN',
            appliedAt: Date.now(),
            expiresAt: null, // Ø­Ø¸Ø± Ø¯Ø§Ø¦Ù… Ø¨Ø¹Ø¯ Ù…Ø®Ø§Ù„ÙØ© ÙˆØ§Ø­Ø¯Ø©
            permanent: true, // Ø­Ø¸Ø± Ø¯Ø§Ø¦Ù…
            blockData: blockData,
            action: blockData.action || 'UNKNOWN',
            details: blockData.details || 'No details',
            deviceFingerprint: blockData.deviceFingerprint || 'Unknown',
            isNewAccount: blockData.isNewAccount || false
        };
        
        // Ø­ÙØ¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø­Ø¸Ø±
        await handleDbSet(env, `blocks/${userId}`, blockInfo);
        
        // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        await handleDbUpdate(env, `users/${userId}`, {
            isBlocked: true,
            blockReason: blockInfo.reason,
            blockedAt: Date.now(),
            violationCount: 1,
            lastViolation: Date.now(),
            lastUpdated: Date.now()
        });
        
        // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø­Ø¸Ø± ÙÙŠ Ø³Ø¬Ù„ Ø§Ù„Ø­Ø¸Ø± Ø§Ù„Ø¹Ø§Ù…
        await handleDbPush(env, 'system/blocks', {
            userId: userId,
            reason: blockInfo.reason,
            violation: blockInfo.violation,
            appliedAt: Date.now(),
            permanent: true,
            action: blockData.action,
            details: blockData.details,
            deviceFingerprint: blockData.deviceFingerprint,
            isNewAccount: blockData.isNewAccount || false
        });
        
        console.log(`User ${userId} permanently blocked: ${blockInfo.reason}, New Account: ${blockData.isNewAccount || false}`);
        
        return true;
    } catch (error) {
        console.error('Error applying block:', error);
        return false;
    }
}

// ØªØ³Ø¬ÙŠÙ„ Ù…Ø®Ø§Ù„ÙØ©
async function recordViolation(env, userId, violationData) {
    try {
        // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø®Ø§Ù„ÙØ©
        await handleDbPush(env, `violations/${userId}`, violationData);
        
        // Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø®Ø§Ù„ÙØ§Øª
        const violationsResult = await handleDbGet(env, `violationCounts/${userId}`);
        const currentCount = violationsResult.data?.count || 0;
        const newCount = currentCount + 1;
        
        await handleDbSet(env, `violationCounts/${userId}`, {
            count: newCount,
            lastViolation: Date.now(),
            userId: userId,
            violationDetails: violationData
        });
        
        console.log(`Violation recorded for user ${userId}: ${violationData.violation}`);
        
        return true;
    } catch (error) {
        console.error('Error recording violation:', error);
        return false;
    }
}

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø§Ø¨Ø· Firebase
async function getFirebaseUrl(env, path) {
    const baseUrl = env.FIREBASE_DATABASE_URL.replace(/\/$/, '');
    const cleanPath = path.replace(/^\//, '');
    const apiKey = env.FIREBASE_API_KEY;
    
    if (!apiKey) {
        throw new Error('FIREBASE_API_KEY is not configured');
    }
    
    return `${baseUrl}/${cleanPath}.json?key=${apiKey}`;
}

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø¶Ù…Ø§Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ø´Ø·Ø© ÙˆØ¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§ØªÙ‡Ø§
async function ensureAndGetCompetition(env, userId = null) {
    try {
        // Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        const competitionResult = await handleDbGet(env, 'competition/current');
        let competitionData = competitionResult.data || {};
        
        const now = Date.now();
        const ONE_DAY_MS = 24 * 60 * 60 * 1000;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠØ¬Ø¨ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø©
        const shouldCreateNew = 
            !competitionData ||
            Object.keys(competitionData).length === 0 ||
            !competitionData.isActive || 
            !competitionData.endTime || 
            now > competitionData.endTime;
        
        if (shouldCreateNew) {
            console.log('Creating new competition... Current time:', now);
            
            // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‡Ù†Ø§Ùƒ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù‚Ø¯ÙŠÙ…Ø©ØŒ Ø­ÙØ¸ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ†
            if (competitionData && competitionData.userTickets && Object.keys(competitionData.userTickets).length > 0) {
                await saveCompetitionWinners(env, competitionData);
            }
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø©
            competitionData = {
                isActive: true,
                startTime: now,
                endTime: now + ONE_DAY_MS, // 24 Ø³Ø§Ø¹Ø© Ù…Ù† Ø§Ù„Ø¢Ù†
                totalTickets: 0,
                prizePool: 0,
                userTickets: {},
                winners: [],
                lastUpdated: now
            };
            
            // Ø­ÙØ¸ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            await handleDbSet(env, 'competition/current', competitionData);
            console.log('New competition created. End time:', new Date(competitionData.endTime).toISOString());
        } else {
            console.log('Existing competition found. End time:', new Date(competitionData.endTime).toISOString());
        }
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
        competitionData.timeRemaining = Math.max(0, competitionData.endTime - now);
        competitionData.isActiveNow = competitionData.isActive && competitionData.timeRemaining > 0;
        
        // Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©ØŒ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø©
        if (competitionData.timeRemaining <= 0 && competitionData.isActive) {
            console.log('Competition ended, creating new one...');
            competitionData.isActive = false;
            await handleDbSet(env, 'competition/current', competitionData);
            return await ensureAndGetCompetition(env, userId);
        }
        
        // Ø¥Ø°Ø§ ØªÙ… ØªÙ…Ø±ÙŠØ± userIdØŒ Ø­Ø³Ø§Ø¨ ØªØ°Ø§ÙƒØ±Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
        if (userId) {
            competitionData.userTickets = competitionData.userTickets || {};
            competitionData.userTicketCount = competitionData.userTickets[userId] || 0;
            console.log(`User ${userId} tickets in competition:`, competitionData.userTicketCount);
            
            // ØªØ­Ø¯ÙŠØ« ØªØ°Ø§ÙƒØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            await syncUserCompetitionTickets(env, userId, competitionData.userTicketCount);
        }
        
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø²Ù…Ù†ÙŠ Ù„Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
        competitionData.timeRemainingFormatted = formatTimeRemaining(competitionData.timeRemaining);
        
        return competitionData;
    } catch (error) {
        console.error('Error ensuring competition:', error);
        return null;
    }
}

// Ø¯Ø§Ù„Ø© Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
function formatTimeRemaining(ms) {
    if (ms <= 0) return '00:00:00';
    
    const hours = Math.floor(ms / (1000 * 60 * 60));
    const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((ms % (1000 * 60)) / 1000);
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// Ø¯Ø§Ù„Ø© Ù„Ø­ÙØ¸ Ø§Ù„ÙØ§Ø¦Ø²ÙŠÙ† ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
async function saveCompetitionWinners(env, competitionData) {
    try {
        if (!competitionData.userTickets || Object.keys(competitionData.userTickets).length === 0) {
            return;
        }
        
        const userIds = Object.keys(competitionData.userTickets);
        const totalTickets = competitionData.totalTickets || 0;
        
        if (totalTickets > 0) {
            // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ§Ø¦Ø² (Ø§Ù„Ø°ÙŠ Ù„Ø¯ÙŠÙ‡ Ø£ÙƒØ¨Ø± Ø¹Ø¯Ø¯ ØªØ°Ø§ÙƒØ±)
            let winnerId = userIds[0];
            let maxTickets = competitionData.userTickets[winnerId] || 0;
            
            for (const userId of userIds) {
                const tickets = competitionData.userTickets[userId] || 0;
                if (tickets > maxTickets) {
                    maxTickets = tickets;
                    winnerId = userId;
                }
            }
            
            // Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙØ§Ø¦Ø²
            const winnerData = {
                userId: winnerId,
                tickets: maxTickets,
                prize: competitionData.prizePool || 0,
                timestamp: Date.now(),
                competitionEndTime: competitionData.endTime
            };
            
            await handleDbPush(env, 'competition/winners', winnerData);
            
            // Ù…Ù†Ø­ Ø§Ù„Ø¬Ø§Ø¦Ø²Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙØ§Ø¦Ø²
            const userResult = await handleDbGet(env, `users/${winnerId}`);
            if (userResult.success && userResult.data) {
                const userData = userResult.data;
                const newBalance = (userData.tonBalance || 0) + (competitionData.prizePool || 0);
                await handleDbUpdate(env, `users/${winnerId}`, { 
                    tonBalance: newBalance 
                });
                
                await handleDbPush(env, `users/${winnerId}/history`, {
                    type: 'earn',
                    description: 'Competition Prize',
                    amount: competitionData.prizePool || 0,
                    currency: 'TON',
                    date: new Date().toISOString()
                });
                
                console.log(`Prize awarded to user ${winnerId}: ${competitionData.prizePool} TON`);
            }
        }
    } catch (error) {
        console.error('Error saving competition winners:', error);
    }
}

// Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø¯ÙŠØ« ØªØ°Ø§ÙƒØ± Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
async function syncUserCompetitionTickets(env, userId, ticketCount) {
    try {
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£ÙˆÙ„Ø§Ù‹
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            console.log(`User ${userId} not found for ticket sync`);
            return false;
        }
        
        const userData = userResult.data;
        const currentTickets = userData.competitionTickets || 0;
        
        // ØªØ­Ø¯ÙŠØ« ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ÙŠÙ…Ø© Ù…Ø®ØªÙ„ÙØ©
        if (currentTickets !== ticketCount) {
            console.log(`Syncing tickets for user ${userId}: ${currentTickets} -> ${ticketCount}`);
            await handleDbUpdate(env, `users/${userId}`, {
                competitionTickets: ticketCount,
                lastTicketSync: Date.now(),
                lastUpdated: Date.now()
            });
            return true;
        }
        
        return false;
    } catch (error) {
        console.error('Error syncing user competition tickets:', error);
        return false;
    }
}

// ==================== ÙˆØ¸Ø§Ø¦Ù Ø¥Ø¯Ø§Ø±Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ====================

async function handleDbSet(env, path, data) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error('Database SET error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_SET_ERROR'
        };
    }
}

async function handleDbGet(env, path) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        
        return {
            success: true,
            data: data
        };
    } catch (error) {
        console.error('Database GET error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_GET_ERROR'
        };
    }
}

async function handleDbUpdate(env, path, updates) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updates)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error('Database UPDATE error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_UPDATE_ERROR'
        };
    }
}

async function handleDbPush(env, path, data) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: { name: result.name }
        };
    } catch (error) {
        console.error('Database PUSH error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_PUSH_ERROR'
        };
    }
}

async function handleDbTransaction(env, path, transactionFunction) {
    try {
        const currentData = await handleDbGet(env, path);
        
        if (!currentData.success) {
            return currentData;
        }
        
        const func = new Function('currentValue', `return ${transactionFunction}(currentValue)`);
        const newValue = func(currentData.data || null);
        
        const updateResult = await handleDbSet(env, path, newValue);
        
        return updateResult;
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_TRANSACTION_ERROR'
        };
    }
}

async function handleDbIncrement(env, path, key, amount) {
    try {
        const currentData = await handleDbGet(env, path);
        
        if (!currentData.success) {
            return currentData;
        }
        
        const currentValue = currentData.data[key] || 0;
        const newValue = currentValue + amount;
        
        const updates = { [key]: newValue };
        const updateResult = await handleDbUpdate(env, path, updates);
        
        return updateResult;
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_INCREMENT_ERROR'
        };
    }
}

// ==================== Ø¨Ø§Ù‚ÙŠ Ø§Ù„ÙˆØ¸Ø§Ø¦Ù ÙƒÙ…Ø§ Ù‡ÙŠ Ù…Ø¹ ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¨Ø³ÙŠØ·Ø© ====================

// ÙˆØ¸ÙŠÙØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ IP Ø§Ù„Ø¹Ù…ÙŠÙ„ (Ù…ØªØ¨Ù‚ÙŠØ© Ù„Ù„ØªÙˆØ§ÙÙ‚ ÙÙ‚Ø·)
async function handleGetClientIP(clientIp) {
    return {
        success: true,
        data: {
            clientIp: clientIp,
            timestamp: Date.now()
        }
    };
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†ÙØ³ Ø§Ù„Ø·Ø§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠ Ù…Ø³Ø¨Ù‚Ù‹Ø§
async function checkDuplicateTimestamp(env, userId, timestamp) {
    try {
        const timestampsResult = await handleDbGet(env, `users/${userId}/requestTimestamps`);
        const timestamps = timestampsResult.data || {};
        
        // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø·Ø§Ø¨Ø¹ Ø²Ù…Ù†ÙŠ Ù…Ø·Ø§Ø¨Ù‚
        for (const [key, tsData] of Object.entries(timestamps)) {
            if (tsData.timestamp === timestamp) {
                return true;
            }
        }
        
        // Ø­ÙØ¸ Ø§Ù„Ø·Ø§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠ Ø§Ù„Ø¬Ø¯ÙŠØ¯
        await handleDbPush(env, `users/${userId}/requestTimestamps`, {
            timestamp: timestamp,
            recordedAt: Date.now()
        });
        
        // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ø£Ù‚Ø¯Ù… Ù…Ù† 5 Ø¯Ù‚Ø§Ø¦Ù‚)
        const cleanTimestamps = {};
        const fiveMinutesAgo = Date.now() - 300000;
        
        for (const [key, tsData] of Object.entries(timestamps)) {
            if (tsData.recordedAt > fiveMinutesAgo) {
                cleanTimestamps[key] = tsData;
            }
        }
        
        await handleDbSet(env, `users/${userId}/requestTimestamps`, cleanTimestamps);
        
        return false;
    } catch (error) {
        console.error('Error checking duplicate timestamp:', error);
        return false;
    }
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø·Ù„Ø¨ Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯
async function validatePromoCodeRequest(env, userId, data) {
    const { code } = data;
    
    // Ø¬Ù„Ø¨ Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const promoCodesResult = await handleDbGet(env, 'promocodes');
    const promoCodes = promoCodesResult.data || {};
    
    let promoCodeData = null;
    let promoCodeKey = null;
    
    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯
    for (const [key, promo] of Object.entries(promoCodes)) {
        if (promo.code === code) {
            promoCodeData = promo;
            promoCodeKey = key;
            break;
        }
    }
    
    // Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯
    if (!promoCodeData) {
        return {
            valid: false,
            violation: 'INVALID_PROMO_CODE',
            details: `Promo code not found: ${code}`,
            shouldBlock: false  // Ø®Ø·Ø£ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø­Ø¸Ø±
        };
    }
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯
    if (promoCodeData.status !== 'active') {
        return {
            valid: false,
            violation: 'INACTIVE_PROMO_CODE',
            details: `Promo code is not active: ${code}`,
            shouldBlock: false  // Ø®Ø·Ø£ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø­Ø¸Ø±
        };
    }
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
    if (promoCodeData.usedCount >= promoCodeData.maxUsage) {
        return {
            valid: false,
            violation: 'PROMO_CODE_LIMIT_EXCEEDED',
            details: `Promo code usage limit reached: ${code}`,
            shouldBlock: false  // Ø®Ø·Ø£ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø­Ø¸Ø±
        };
    }
    
    // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø³Ø§Ø¨Ù‚
    const userResult = await handleDbGet(env, `users/${userId}`);
    if (userResult.success && userResult.data) {
        const userData = userResult.data;
        const usedPromoCodes = userData.usedPromoCodes || [];
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‚Ø¯ Ø§Ø³ØªØ®Ø¯Ù… Ù‡Ø°Ø§ Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯ Ù…Ù† Ù‚Ø¨Ù„
        for (const usedCode of usedPromoCodes) {
            if (usedCode.code === code || usedCode === code) {
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡Ø§ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
                if (usedCode.usageCount >= (promoCodeData.usagePerUser || 1)) {
                    return {
                        valid: false,
                        violation: 'PROMO_CODE_ALREADY_USED',
                        details: `User has already used this promo code maximum times: ${code}`,
                        shouldBlock: false  // Ø®Ø·Ø£ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø­Ø¸Ø±
                    };
                }
                break;
            }
        }
    }
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†ÙˆØ¹
    const rewardAmount = promoCodeData.rewardAmount || 0;
    const rewardType = promoCodeData.rewardType || 'glx';
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù…ÙƒØ§ÙØ£Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†ÙˆØ¹
    const configResult = await handleGetConfig();
    const settings = configResult.data?.settings || {};
    
    if (rewardType === 'glx') {
        const MAX_GLX_REWARD = 100000; // 100,000 GLX ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰
        if (rewardAmount > MAX_GLX_REWARD) {
            return {
                valid: false,
                violation: 'EXCESSIVE_PROMO_REWARD',
                details: `GLX reward too high: ${rewardAmount} (max ${MAX_GLX_REWARD})`
            };
        }
    } else if (rewardType === 'ton') {
        const MAX_TON_REWARD = 1; // 1 TON ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰
        if (rewardAmount > MAX_TON_REWARD) {
            return {
                valid: false,
                violation: 'EXCESSIVE_PROMO_REWARD',
                details: `TON reward too high: ${rewardAmount} (max ${MAX_TON_REWARD})`
            };
        }
    } else if (rewardType === 'tickets') {
        const MAX_TICKETS_REWARD = 100; // 100 ØªØ°ÙƒØ±Ø© ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰
        if (rewardAmount > MAX_TICKETS_REWARD) {
            return {
                valid: false,
                violation: 'EXCESSIVE_PROMO_REWARD',
                details: `Tickets reward too high: ${rewardAmount} (max ${MAX_TICKETS_REWARD})`
            };
        }
    }
    
    return { valid: true };
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø·Ù„Ø¨ Ø§Ù„Ù…Ù‡Ù…Ø©
async function validateTaskRequest(env, userId, data) {
    const { taskId, reward, title } = data;
    
    // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ù…Ù‡Ù…Ø©
    const MAX_TASK_REWARD = 10000;
    
    if (parseInt(reward) > MAX_TASK_REWARD) {
        return {
            valid: false,
            violation: 'EXCESSIVE_TASK_REWARD',
            details: `Task reward too high: ${reward}`
        };
    }
    
    // ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ù‡Ù…Ø© Ù…Ø³Ø¨Ù‚Ù‹Ø§ Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ù‡Ù…Ø© Ø¹Ø¯Ø© Ù…Ø±Ø§Øª
    // Ø§Ù„ØªØ­Ù‚Ù‚ ÙÙ‚Ø· Ù…Ù† Ø£Ù† Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ù„Ø§ ØªØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰
    
    return { valid: true };
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø´Ø±Ø§Ø¡ Ø§Ù„ØªØ°Ø§ÙƒØ±
async function validateTicketPurchase(env, userId, data) {
    const { tickets, totalCost } = data;
    
    // Ø³Ø¹Ø± Ø§Ù„ØªØ°ÙƒØ±Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø©
    const TICKET_PRICE = 10000; // Ø³Ø¹Ø± Ø§Ù„ØªØ°ÙƒØ±Ø© = 10,000 GLX
    
    // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„ØªØ°Ø§ÙƒØ± ÙÙŠ ÙƒÙ„ Ø¹Ù…Ù„ÙŠØ©
    const MAX_TICKETS_PER_PURCHASE = 100;
    
    // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„ØªØ°Ø§ÙƒØ±
    const MIN_TICKETS_PER_PURCHASE = 1;
    
    const ticketsCount = parseInt(tickets);
    const costAmount = parseInt(totalCost);
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ø¯ Ø§Ù„ØªØ°Ø§ÙƒØ±
    if (ticketsCount < MIN_TICKETS_PER_PURCHASE) {
        return {
            valid: false,
            violation: 'INSUFFICIENT_TICKETS',
            details: `Too few tickets: ${ticketsCount}`
        };
    }
    
    if (ticketsCount > MAX_TICKETS_PER_PURCHASE) {
        return {
            valid: false,
            violation: 'EXCESSIVE_TICKET_PURCHASE',
            details: `Too many tickets: ${ticketsCount} (max ${MAX_TICKETS_PER_PURCHASE})`
        };
    }
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„ØªÙƒÙ„ÙØ© Ù…ØªÙ†Ø§Ø³Ø¨Ø© Ù…Ø¹ Ø¹Ø¯Ø¯ Ø§Ù„ØªØ°Ø§ÙƒØ±
    const expectedCost = ticketsCount * TICKET_PRICE;
    
    if (costAmount !== expectedCost) {
        return {
            valid: false,
            violation: 'COST_MANIPULATION',
            details: `Ticket cost manipulation: Expected ${expectedCost}, got ${costAmount}`
        };
    }
    
    return { valid: true };
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ù„Ø¹Ø¨Ø© Ù‚Ù„Ø¨ Ø§Ù„Ø¹Ù…Ù„Ø©
async function validateCoinFlip(env, userId, data) {
    const { betAmount } = data;
    
    // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø±Ù‡Ø§Ù†
    const MAX_BET_AMOUNT = 100000; // 100,000 GLX ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰
    
    // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø±Ù‡Ø§Ù†
    const MIN_BET_AMOUNT = 1000; // 1,000 GLX ÙƒØ­Ø¯ Ø£Ø¯Ù†Ù‰
    
    const betAmountNum = parseInt(betAmount);
    
    if (betAmountNum > MAX_BET_AMOUNT) {
        return {
            valid: false,
            violation: 'EXCESSIVE_BET_AMOUNT',
            details: `Bet amount too high: ${betAmountNum} (max ${MAX_BET_AMOUNT})`,
            shouldBlock: false  // Ø®Ø·Ø£ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø­Ø¸Ø±
        };
    }
    
    if (betAmountNum < MIN_BET_AMOUNT) {
        return {
            valid: false,
            violation: 'INSUFFICIENT_BET_AMOUNT',
            details: `Bet amount too low: ${betAmountNum} (min ${MIN_BET_AMOUNT})`
        };
    }
    
    return { valid: true };
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ù…Ù‡Ù…Ø©
async function validateTaskReward(env, userId, data, action) {
    let reward;
    let taskId;
    
    if (action === 'verifyTaskCompletion') {
        reward = data.reward;
        taskId = data.taskId;
    } else if (action === 'verifyTaskChannel') {
        reward = 2000; // Ù…ÙƒØ§ÙØ£Ø© Ø«Ø§Ø¨ØªØ© Ù„Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ù„Ù‚Ù†Ø§Ø©
    } else {
        return { valid: true };
    }
    
    // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ø© Ù„Ù„ØªØ­Ù‚Ù‚
    if (taskId) {
        const taskResult = await handleDbGet(env, `tasks/${taskId}`);
        if (taskResult.success && taskResult.data) {
            const task = taskResult.data;
            const taskReward = task.reward || 0;
            
            // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ù‡Ù…Ø© Ù„Ù‡Ø§ Ù…ÙƒØ§ÙØ£Ø© Ù…Ø­Ø¯Ø¯Ø©ØŒ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡Ø§
            if (taskReward > 0 && parseInt(reward) !== taskReward) {
                return {
                    valid: false,
                    violation: 'TASK_REWARD_MANIPULATION',
                    details: `Task reward manipulation: Expected ${taskReward}, got ${reward}`
                };
            }
        }
    }
    
    // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ù…Ù‡Ù…Ø©
    const MAX_TASK_REWARD = 20000;
    
    if (parseInt(reward) > MAX_TASK_REWARD) {
        return {
            valid: false,
            violation: 'EXCESSIVE_TASK_REWARD',
            details: `Task reward too high: ${reward}`
        };
    }
    
    return { valid: true };
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ù„Ø¹Ø¨Ø© Ø§Ù„Ø³Ù„ÙˆØªØ³
async function validateSlotSpin(env, userId) {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø¯ÙˆØ±Ø§Ù† ÙƒØ§ÙÙŠØ©
    const userResult = await handleDbGet(env, `users/${userId}`);
    if (userResult.success && userResult.data) {
        const userData = userResult.data;
        
        if ((userData.extraSpins || 0) <= 0) {
            return {
                valid: false,
                violation: 'NO_SPINS_AVAILABLE',
                details: 'No spins available'
            };
        }
    }
    
    return { valid: true };
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
async function validateDailyBonus(env, userId) {
    const userResult = await handleDbGet(env, `users/${userId}`);
    if (userResult.success && userResult.data) {
        const userData = userResult.data;
        const now = Date.now();
        const lastClaim = userData.lastDailyClaim || 0;
        const msInDay = 86400000;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù†Ù‡ Ù„Ù… ÙŠØ­ØµÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„ÙŠÙˆÙ…
        if (now - lastClaim < msInDay) {
            return {
                valid: false,
                violation: 'DAILY_BONUS_ALREADY_CLAIMED',
                details: 'Daily bonus already claimed today',
                shouldBlock: false // Ø±ÙØ¶ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø­Ø¸Ø±
            };
        }
    }
    
    return { valid: true };
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø·Ù„Ø¨ Ø§Ù„Ø³Ø­Ø¨
async function validateWithdrawalRequest(env, userId, data) {
    const { amount, method } = data;
    
    const userResult = await handleDbGet(env, `users/${userId}`);
    if (userResult.success && userResult.data) {
        const userData = userResult.data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø³Ø­Ø¨
        const configResult = await handleGetConfig();
        const settings = configResult.data?.settings || {};
        
        let minAmount = 0.05; // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ
        if (method === 'ton') {
            minAmount = settings.minTonWithdrawal || 0.05;
        } else if (method === 'faucetpay') {
            minAmount = settings.minFaucetPayWithdrawal || 0.0001;
        }
        
        if (parseFloat(amount) < minAmount) {
            return {
                valid: false,
                violation: 'INSUFFICIENT_WITHDRAWAL_AMOUNT',
                details: `Withdrawal amount too low: ${amount} (min ${minAmount})`
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„ÙƒØ§ÙÙŠ
        if ((userData.tonBalance || 0) < parseFloat(amount)) {
            return {
                valid: false,
                violation: 'INSUFFICIENT_BALANCE_FOR_WITHDRAWAL',
                details: 'Insufficient TON balance for withdrawal'
            };
        }
    }
    
    return { valid: true };
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø·Ù„Ø¨ Ø§Ù„ØªØ­ÙˆÙŠÙ„
async function validateSwapRequest(env, userId, data) {
    const { type, amount, tonValue, glxValue } = data;
    
    const userResult = await handleDbGet(env, `users/${userId}`);
    if (userResult.success && userResult.data) {
        const userData = userResult.data;
        
        if (type === 'glx_to_ton') {
            if (userData.dogsBalance < amount) {
                return {
                    valid: false,
                    violation: 'INSUFFICIENT_GLX_FOR_SWAP',
                    details: 'Insufficient GLX balance for swap',
                    shouldBlock: false  // Ø®Ø·Ø£ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø­Ø¸Ø±
                };
            }
        } else if (type === 'ton_to_glx') {
            if ((userData.tonBalance || 0) < amount) {
                return {
                    valid: false,
                    violation: 'INSUFFICIENT_TON_FOR_SWAP',
                    details: 'Insufficient TON balance for swap',
                    shouldBlock: false  // Ø®Ø·Ø£ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø­Ø¸Ø±
                };
            }
        }
    }
    
    return { valid: true };
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø·Ù„Ø¨ Ø§Ù„Ø¥ÙŠØ¯Ø§Ø¹ (ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† memo)
async function validateDepositRequest(env, userId, data) {
    const { memo, amount } = data;
    
    // ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© ØªÙ†Ø³ÙŠÙ‚ memo Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø·Ù„Ø¨Ùƒ
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø¨Ù„Øº Ø¥ÙŠØ¬Ø§Ø¨ÙŠ (ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ)
    if (parseFloat(amount) <= 0) {
        return {
            valid: false,
            violation: 'INVALID_DEPOSIT_AMOUNT',
            details: 'Deposit amount must be positive',
            shouldBlock: false  // Ø®Ø·Ø£ ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø­Ø¸Ø±
        };
    }
    
    return { valid: true };
}

// ==================== Ø¨Ø§Ù‚ÙŠ Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„ÙƒØ§Ù…Ù„Ø© ====================

async function handleExecuteSwap(env, userId, data) {
    try {
        const { type, amount, tonValue, glxValue } = data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        let updates = {};
        let historyEntry = {};
        
        if (type === 'glx_to_ton') {
            if (userData.dogsBalance < amount) {
                return { 
                    success: false, 
                    error: 'Insufficient GLX balance',
                    errorCode: 'INSUFFICIENT_GLX_BALANCE'
                };
            }
            
            updates.dogsBalance = userData.dogsBalance - amount;
            updates.tonBalance = (userData.tonBalance || 0) + tonValue;
            updates.lastUpdated = Date.now();
            
            historyEntry = {
                type: 'swap_out',
                description: 'Swap GLX to TON',
                amount: amount,
                currency: 'GLX',
                date: new Date().toISOString()
            };
            
            await handleDbPush(env, `users/${userId}/history`, historyEntry);
            
            historyEntry = {
                type: 'swap_in',
                description: 'Received from GLX Swap',
                amount: tonValue,
                currency: 'TON',
                date: new Date().toISOString()
            };
            
        } else if (type === 'ton_to_glx') {
            if ((userData.tonBalance || 0) < amount) {
                return { 
                    success: false, 
                    error: 'Insufficient TON balance',
                    errorCode: 'INSUFFICIENT_TON_BALANCE'
                };
            }
            
            updates.tonBalance = (userData.tonBalance || 0) - amount;
            updates.dogsBalance = userData.dogsBalance + glxValue;
            updates.lastUpdated = Date.now();
            
            historyEntry = {
                type: 'swap_out',
                description: 'Swap TON to GLX',
                amount: amount,
                currency: 'TON',
                date: new Date().toISOString()
            };
            
            await handleDbPush(env, `users/${userId}/history`, historyEntry);
            
            historyEntry = {
                type: 'swap_in',
                description: 'Received from TON Swap',
                amount: glxValue,
                currency: 'GLX',
                date: new Date().toISOString()
            };
        } else {
            return { 
                success: false, 
                error: 'Invalid swap type',
                errorCode: 'INVALID_SWAP_TYPE'
            };
        }
        
        await handleDbUpdate(env, `users/${userId}`, updates);
        
        await handleDbPush(env, `users/${userId}/history`, historyEntry);
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || { ...userData, ...updates };
        
        return {
            success: true,
            data: {
                newGLXBalance: updatedUserData.dogsBalance,
                newTONBalance: updatedUserData.tonBalance,
                updatedUserData: updatedUserData
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'EXECUTE_SWAP_ERROR'
        };
    }
}

async function handleVerifyDeposit(env, userId, data) {
    try {
        const { memo, amount } = data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const currentTime = Date.now();
        const memoTime = parseInt(memo.split('_').pop());
        
        if (currentTime - memoTime > 30000) {
            const userResult = await handleDbGet(env, `users/${userId}`);
            if (!userResult.success) {
                return { 
                    success: false, 
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            const userData = userResult.data;
            const newBalance = (userData.tonBalance || 0) + amount;
            
            await handleDbUpdate(env, `users/${userId}`, { 
                tonBalance: newBalance,
                lastUpdated: Date.now()
            });
            
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'deposit',
                description: `TON Deposit #${memo.substring(0, 8)}`,
                amount: amount,
                currency: 'TON',
                date: new Date().toISOString()
            });
            
            // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
            const updatedUserResult = await handleDbGet(env, `users/${userId}`);
            const updatedUserData = updatedUserResult.data || { ...userData, tonBalance: newBalance };
            
            return {
                success: true,
                data: {
                    newBalance: newBalance,
                    txHash: memo.substring(0, 12),
                    updatedUserData: updatedUserData
                }
            };
        } else {
            return { 
                success: false, 
                error: 'Deposit not confirmed yet',
                errorCode: 'DEPOSIT_NOT_CONFIRMED'
            };
        }
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_DEPOSIT_ERROR'
        };
    }
}

async function handleBuyTickets(env, userId, data) {
    try {
        const { tickets, totalCost } = data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        // Ø¬Ù„Ø¨ Ø³Ø¹Ø± Ø§Ù„ØªØ°ÙƒØ±Ø© Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
        const configResult = await handleGetConfig();
        const settings = configResult.data?.settings || {};
        const TICKET_PRICE = settings.ticketPrice || 10000;
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©
        const ticketsCount = parseInt(tickets);
        const expectedCost = ticketsCount * TICKET_PRICE;
        const costAmount = parseInt(totalCost);
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙƒÙ„ÙØ©
        if (costAmount !== expectedCost) {
            return { 
                success: false, 
                error: `Invalid ticket cost: Expected ${expectedCost}, got ${costAmount}`,
                errorCode: 'INVALID_TICKET_COST'
            };
        }
        
        if (userData.dogsBalance < costAmount) {
            return { 
                success: false, 
                error: 'Insufficient GLX balance',
                errorCode: 'INSUFFICIENT_GLX_BALANCE'
            };
        }
        
        const newBalance = userData.dogsBalance - costAmount;
        
        // ØªØ­Ø¯ÙŠØ« Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£ÙˆÙ„Ø§Ù‹
        await handleDbUpdate(env, `users/${userId}`, { 
            dogsBalance: newBalance,
            lastUpdated: Date.now()
        });
        
        // ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ø´Ø·Ø©
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return { 
                success: false, 
                error: 'No active competition found',
                errorCode: 'NO_ACTIVE_COMPETITION'
            };
        }
        
        // ØªØ­Ø¯ÙŠØ« ØªØ°Ø§ÙƒØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©
        const currentUserTickets = competitionData.userTickets[userId] || 0;
        competitionData.userTickets[userId] = currentUserTickets + ticketsCount;
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
        competitionData.totalTickets = (competitionData.totalTickets || 0) + ticketsCount;
        competitionData.prizePool = competitionData.totalTickets * 0.001;
        
        // Ø­ÙØ¸ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        await handleDbSet(env, 'competition/current', {
            isActive: competitionData.isActive,
            startTime: competitionData.startTime,
            endTime: competitionData.endTime,
            totalTickets: competitionData.totalTickets,
            prizePool: competitionData.prizePool,
            userTickets: competitionData.userTickets,
            winners: competitionData.winners || [],
            lastUpdated: Date.now()
        });
        
        // ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø¯ ØªØ°Ø§ÙƒØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ø¨ÙŠØ§Ù†Ø§ØªÙ‡ Ø§Ù„Ø´Ø®ØµÙŠØ©
        const newTicketCount = competitionData.userTickets[userId];
        await handleDbUpdate(env, `users/${userId}`, {
            competitionTickets: newTicketCount,
            lastTicketSync: Date.now(),
            lastUpdated: Date.now()
        });
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'spend',
            description: `Bought ${ticketsCount} Competition Ticket${ticketsCount > 1 ? 's' : ''}`,
            amount: costAmount,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
        const now = Date.now();
        const timeRemaining = Math.max(0, competitionData.endTime - now);
        const timeRemainingFormatted = formatTimeRemaining(timeRemaining);
        
        return {
            success: true,
            data: {
                newBalance: updatedUserData.dogsBalance,
                userTickets: competitionData.userTickets[userId],
                totalTickets: competitionData.totalTickets,
                prizePool: competitionData.prizePool,
                contestEndTime: competitionData.endTime,
                timeRemaining: timeRemaining,
                timeRemainingFormatted: timeRemainingFormatted,
                userCompetitionTickets: newTicketCount,
                updatedUserData: updatedUserData
            }
        };
    } catch (error) {
        console.error('Buy tickets error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'BUY_TICKETS_ERROR'
        };
    }
}

async function handleGetCompetitionLeaderboard(env) {
    try {
        // ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ø´Ø·Ø©
        const competitionData = await ensureAndGetCompetition(env);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'No active competition found',
                errorCode: 'NO_ACTIVE_COMPETITION'
            };
        }
        
        const userTickets = competitionData.userTickets || {};
        const leaderboard = [];
        
        for (const [userId, tickets] of Object.entries(userTickets)) {
            if (tickets > 0) {
                const userResult = await handleDbGet(env, `users/${userId}`);
                if (userResult.success && userResult.data) {
                    // ØªØ®Ø·ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ† Ù…Ù† Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†
                    if (userResult.data.isBlocked) continue;
                    
                    leaderboard.push({
                        userId: userId,
                        name: userResult.data.name || 'Anonymous',
                        photoUrl: userResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                        tickets: tickets
                    });
                }
            }
        }
        
        leaderboard.sort((a, b) => b.tickets - a.tickets);
        
        return {
            success: true,
            data: {
                leaderboard: leaderboard.slice(0, 10),
                contest: {
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    endTime: competitionData.endTime,
                    startTime: competitionData.startTime,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted,
                    isActive: competitionData.isActiveNow
                }
            }
        };
    } catch (error) {
        console.error('Get competition leaderboard error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_COMPETITION_LEADERBOARD_ERROR'
        };
    }
}

async function handleGetPreviousWinners(env) {
    try {
        const winnersResult = await handleDbGet(env, 'competition/winners');
        const winnersData = winnersResult.data || {};
        
        const winners = [];
        
        for (const [key, winner] of Object.entries(winnersData)) {
            if (winner.userId) {
                const userResult = await handleDbGet(env, `users/${winner.userId}`);
                if (userResult.success && userResult.data) {
                    // ØªØ®Ø·ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†
                    if (userResult.data.isBlocked) continue;
                    
                    winners.push({
                        userId: winner.userId,
                        name: userResult.data.name || 'Anonymous',
                        photoUrl: userResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                        tickets: winner.tickets || 0,
                        prize: winner.prize || 0,
                        timestamp: winner.timestamp || Date.now()
                    });
                }
            }
        }
        
        winners.sort((a, b) => b.timestamp - a.timestamp);
        
        return {
            success: true,
            data: {
                winners: winners.slice(0, 10)
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_PREVIOUS_WINNERS_ERROR'
        };
    }
}

async function handleFlipCoin(env, userId, data) {
    try {
        const { betAmount, chosenSide } = data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        if (!betAmount || !chosenSide) {
            return { 
                success: false, 
                error: 'Missing required parameters',
                errorCode: 'MISSING_PARAMETERS'
            };
        }
        
        const betAmountNum = parseInt(betAmount);
        
        if (isNaN(betAmountNum) || betAmountNum <= 0) {
            return { 
                success: false, 
                error: 'Invalid bet amount',
                errorCode: 'INVALID_BET_AMOUNT'
            };
        }
        
        if (chosenSide !== 'glx' && chosenSide !== 'gold') {
            return { 
                success: false, 
                error: 'Invalid side chosen (must be glx or gold)',
                errorCode: 'INVALID_SIDE'
            };
        }
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ÙˆØ¯
        const configResult = await handleGetConfig();
        const settings = configResult.data?.settings || {};
        
        const MIN_BET = settings.coinFlipMinBet || 1000;
        const MAX_BET = settings.coinFlipMaxBet || 100000;
        
        if (betAmountNum < MIN_BET) {
            return { 
                success: false, 
                error: `Minimum bet is ${MIN_BET.toLocaleString()} GLX`,
                errorCode: 'MINIMUM_BET_REQUIRED'
            };
        }
        
        if (betAmountNum > MAX_BET) {
            return { 
                success: false, 
                error: `Maximum bet is ${MAX_BET.toLocaleString()} GLX`,
                errorCode: 'MAXIMUM_BET_EXCEEDED'
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±ØµÙŠØ¯
        if (userData.dogsBalance < betAmountNum) {
            return { 
                success: false, 
                error: 'Insufficient GLX balance',
                errorCode: 'INSUFFICIENT_GLX_BALANCE',
                data: {
                    currentBalance: userData.dogsBalance,
                    requiredAmount: betAmountNum,
                    difference: betAmountNum - userData.dogsBalance
                }
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¯ Ø§Ù„Ù…ÙƒØ§Ø³Ø¨ Ø§Ù„ÙŠÙˆÙ…ÙŠ
        const today = new Date().toDateString();
        const dailyLimit = settings.coinFlipDailyLimit || 1000000;
        
        // Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ÙŠÙˆÙ…
        const dailyStatsKey = `coinFlipDaily_${today.replace(/\s+/g, '_')}`;
        const dailyStats = userData[dailyStatsKey] || { totalWins: 0, totalProfit: 0 };
        
        // ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
        const randomNumber = Math.random() * 100;
        const isWin = randomNumber < 45; // 45% ÙØ±ØµØ© Ù„Ù„ÙÙˆØ²
        const resultSide = isWin ? chosenSide : (chosenSide === 'glx' ? 'gold' : 'glx');
        const winAmount = isWin ? betAmountNum * 2 : 0;
        const netProfit = isWin ? betAmountNum : -betAmountNum;
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ù‡Ø§Ù†
        let finalBalance;
        let transactionEntry;
        
        if (isWin) {
            // Ø¥Ø°Ø§ ÙØ§Ø² Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            const newDailyProfit = (dailyStats.totalProfit || 0) + betAmountNum;
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠ
            if (newDailyProfit > dailyLimit) {
                // Ø¥Ø°Ø§ ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠØŒ Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø±Ù‡Ø§Ù† ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† Ø±Ø¨Ø­
                finalBalance = userData.dogsBalance;
                
                transactionEntry = {
                    type: 'coin_flip_daily_limit',
                    description: `Coin Flip Daily Limit Reached`,
                    amount: 0,
                    currency: 'GLX',
                    date: new Date().toISOString(),
                    timestamp: Date.now(),
                    betType: 'refund',
                    betSide: chosenSide,
                    betAmount: betAmountNum,
                    status: 'daily_limit_reached',
                    note: `Daily profit limit of ${dailyLimit.toLocaleString()} GLX reached`
                };
            } else {
                // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ÙƒØ³Ø¨ Ø§Ù„ÙƒØ§Ù…Ù„
                finalBalance = userData.dogsBalance + betAmountNum;
                
                transactionEntry = {
                    type: 'coin_flip_win',
                    description: `Coin Flip Win (${chosenSide.toUpperCase()})`,
                    amount: winAmount,
                    currency: 'GLX',
                    date: new Date().toISOString(),
                    timestamp: Date.now(),
                    betType: 'win',
                    betSide: chosenSide,
                    betAmount: betAmountNum,
                    netProfit: betAmountNum,
                    status: 'won'
                };
            }
        } else {
            // Ø¥Ø°Ø§ Ø®Ø³Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            finalBalance = userData.dogsBalance - betAmountNum;
            
            transactionEntry = {
                type: 'coin_flip_loss',
                description: `Coin Flip Loss (${chosenSide.toUpperCase()})`,
                amount: 0,
                currency: 'GLX',
                date: new Date().toISOString(),
                timestamp: Date.now(),
                betType: 'loss',
                betSide: chosenSide,
                betAmount: betAmountNum,
                netProfit: -betAmountNum,
                status: 'lost'
            };
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±ØµÙŠØ¯
        await handleDbUpdate(env, `users/${userId}`, {
            dogsBalance: finalBalance,
            lastUpdated: Date.now(),
            lastCoinFlip: Date.now(),
            lastActivity: Date.now()
        });
        
        // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙÙŠ Ø§Ù„Ø³Ø¬Ù„
        await handleDbPush(env, `users/${userId}/history`, transactionEntry);
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
        const gameStatsUpdates = {
            totalCoinFlipPlays: (userData.totalCoinFlipPlays || 0) + 1,
            totalCoinFlipProfit: (userData.totalCoinFlipProfit || 0) + netProfit,
            lastCoinFlipResult: isWin ? 'win' : 'loss',
            lastCoinFlipDate: Date.now()
        };
        
        if (isWin) {
            gameStatsUpdates.totalCoinFlipWins = (userData.totalCoinFlipWins || 0) + 1;
        } else {
            gameStatsUpdates.totalCoinFlipLosses = (userData.totalCoinFlipLosses || 0) + 1;
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ÙŠÙˆÙ…
        const updatedDailyStats = {
            totalPlays: (dailyStats.totalPlays || 0) + 1,
            totalProfit: isWin ? (dailyStats.totalProfit || 0) + betAmountNum : (dailyStats.totalProfit || 0),
            lastPlayDate: Date.now()
        };
        
        if (isWin) {
            updatedDailyStats.totalWins = (dailyStats.totalWins || 0) + 1;
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
        await handleDbUpdate(env, `users/${userId}`, {
            ...gameStatsUpdates,
            [dailyStatsKey]: updatedDailyStats,
            lastUpdated: Date.now()
        });
        
        // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹
        const responseData = {
            isWin: isWin,
            resultSide: resultSide,
            betAmount: betAmountNum,
            winAmount: winAmount,
            netProfit: netProfit,
            newBalance: finalBalance,
            currentBalance: updatedUserData.dogsBalance,
            gameStats: {
                totalPlays: gameStatsUpdates.totalCoinFlipPlays,
                totalWins: gameStatsUpdates.totalCoinFlipWins || 0,
                totalLosses: gameStatsUpdates.totalCoinFlipLosses || 0,
                totalProfit: gameStatsUpdates.totalCoinFlipProfit,
                winRate: gameStatsUpdates.totalCoinFlipPlays > 0 
                    ? ((gameStatsUpdates.totalCoinFlipWins || 0) / gameStatsUpdates.totalCoinFlipPlays * 100).toFixed(2) 
                    : '0.00'
            },
            dailyStats: updatedDailyStats,
            dailyLimit: dailyLimit,
            dailyLimitRemaining: Math.max(0, dailyLimit - updatedDailyStats.totalProfit),
            transactionId: Date.now().toString(),
            updatedUserData: {
                ...updatedUserData,
                dogsBalance: finalBalance
            }
        };
        
        // Ø¥Ø°Ø§ ØªÙ… Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø­Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠ
        if (isWin && updatedDailyStats.totalProfit >= dailyLimit) {
            responseData.dailyLimitReached = true;
            responseData.warning = `Daily profit limit reached. Maximum daily profit is ${dailyLimit.toLocaleString()} GLX.`;
        }
        
        return {
            success: true,
            data: responseData
        };
        
    } catch (error) {
        console.error('Flip coin error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'FLIP_COIN_ERROR',
            stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
        };
    }
}

async function handleRedeemPromoCode(env, userId, data) {
    try {
        const { code } = data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        // Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯Ø§Øª
        const promoCodesResult = await handleDbGet(env, 'promocodes');
        const promoCodes = promoCodesResult.data || {};
        
        let promoCodeData = null;
        let promoCodeKey = null;
        
        // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯
        for (const [key, promo] of Object.entries(promoCodes)) {
            if (promo.code === code) {
                promoCodeData = promo;
                promoCodeKey = key;
                break;
            }
        }
        
        if (!promoCodeData) {
            return { 
                success: false, 
                error: 'Invalid or expired promo code',
                errorCode: 'INVALID_PROMO_CODE'
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯
        if (promoCodeData.status !== 'active') {
            return { 
                success: false, 
                error: 'This promo code is no longer active',
                errorCode: 'INACTIVE_PROMO_CODE'
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
        if (promoCodeData.usedCount >= promoCodeData.maxUsage) {
            return { 
                success: false, 
                error: 'This promo code has reached its usage limit',
                errorCode: 'PROMO_CODE_LIMIT_EXCEEDED'
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        const usedPromoCodes = userData.usedPromoCodes || [];
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‚Ø¯ Ø§Ø³ØªØ®Ø¯Ù… Ù‡Ø°Ø§ Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯ Ù…Ù† Ù‚Ø¨Ù„
        let alreadyUsed = false;
        let usageCount = 0;
        
        for (const usedCode of usedPromoCodes) {
            if (typeof usedCode === 'object' && usedCode.code === code) {
                alreadyUsed = true;
                usageCount = usedCode.usageCount || 1;
                break;
            } else if (usedCode === code) {
                alreadyUsed = true;
                usageCount = 1;
                break;
            }
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡Ø§ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        if (alreadyUsed && usageCount >= (promoCodeData.usagePerUser || 1)) {
            return { 
                success: false, 
                error: 'You have already used this promo code',
                errorCode: 'PROMO_CODE_ALREADY_USED'
            };
        }
        
        const rewardAmount = promoCodeData.rewardAmount || 0;
        const rewardType = promoCodeData.rewardType || 'glx';
        
        let updates = {};
        let historyDescription = '';
        
        // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†ÙˆØ¹
        if (rewardType === 'glx') {
            const newBalance = userData.dogsBalance + rewardAmount;
            updates.dogsBalance = newBalance;
            historyDescription = `Promo Code: ${code} (${rewardAmount} GLX)`;
        } else if (rewardType === 'ton') {
            const newBalance = (userData.tonBalance || 0) + rewardAmount;
            updates.tonBalance = newBalance;
            historyDescription = `Promo Code: ${code} (${rewardAmount} TON)`;
        } else if (rewardType === 'tickets') {
            // Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„ØªØ°Ø§ÙƒØ± ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©
            const competitionData = await ensureAndGetCompetition(env, userId);
            if (competitionData) {
                const currentUserTickets = competitionData.userTickets[userId] || 0;
                competitionData.userTickets[userId] = currentUserTickets + rewardAmount;
                competitionData.totalTickets = (competitionData.totalTickets || 0) + rewardAmount;
                competitionData.prizePool = competitionData.totalTickets * 0.001;
                
                await handleDbSet(env, 'competition/current', {
                    isActive: competitionData.isActive,
                    startTime: competitionData.startTime,
                    endTime: competitionData.endTime,
                    totalTickets: competitionData.totalTickets,
                    prizePool: competitionData.prizePool,
                    userTickets: competitionData.userTickets,
                    winners: competitionData.winners || [],
                    lastUpdated: Date.now()
                });
                
                updates.competitionTickets = competitionData.userTickets[userId];
                updates.lastTicketSync = Date.now();
            }
            historyDescription = `Promo Code: ${code} (${rewardAmount} Tickets)`;
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        if (alreadyUsed) {
            // ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
            const updatedUsedCodes = usedPromoCodes.map(usedCode => {
                if (typeof usedCode === 'object' && usedCode.code === code) {
                    return { ...usedCode, usageCount: (usedCode.usageCount || 1) + 1 };
                } else if (usedCode === code) {
                    return { code: code, usageCount: 2 };
                }
                return usedCode;
            });
            updates.usedPromoCodes = updatedUsedCodes;
        } else {
            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯
            usedPromoCodes.push({ code: code, usageCount: 1 });
            updates.usedPromoCodes = usedPromoCodes;
        }
        
        updates.lastUpdated = Date.now();
        
        // ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        await handleDbUpdate(env, `users/${userId}`, updates);
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        const newUsedCount = promoCodeData.usedCount + 1;
        await handleDbUpdate(env, `promocodes/${promoCodeKey}`, {
            usedCount: newUsedCount,
            lastUsed: Date.now(),
            lastUpdated: Date.now()
        });
        
        // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø°ÙŠÙ† Ø§Ø³ØªØ®Ø¯Ù…ÙˆØ§ Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯
        await handleDbPush(env, `promocodes/${promoCodeKey}/users`, {
            userId: userId,
            usedAt: Date.now(),
            rewardAmount: rewardAmount,
            rewardType: rewardType
        });
        
        // ØªØ³Ø¬ÙŠÙ„ ÙÙŠ Ø³Ø¬Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: historyDescription,
            amount: rewardAmount,
            currency: rewardType === 'ton' ? 'TON' : 'GLX',
            date: new Date().toISOString()
        });
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        return {
            success: true,
            data: {
                reward: rewardAmount,
                rewardType: rewardType,
                newBalance: rewardType === 'ton' ? updatedUserData.tonBalance : updatedUserData.dogsBalance,
                tickets: rewardType === 'tickets' ? updates.competitionTickets : undefined,
                updatedUserData: updatedUserData
            }
        };
    } catch (error) {
        console.error('Redeem promo code error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'REDEEM_PROMO_CODE_ERROR'
        };
    }
}

async function handleCreateTask(env, userId, data) {
    try {
        const { taskId, name, link, category, count, cost } = data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‡Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø¨Ø­Ø§Ù„Ø© pending payment
        const newTask = {
            id: taskId,
            title: name,
            description: `Reward: ${category.toUpperCase()}`,
            link: link,
            reward: 2000,
            category: 'community',
            total: parseInt(count),
            remaining: parseInt(count),
            status: 'pending_payment',
            creator: userId,
            cost: parseFloat(cost),
            createdAt: Date.now(),
            paymentVerified: false,
            paymentCheckCount: 0,
            lastPaymentCheck: null,
            lastUpdated: Date.now()
        };
        
        await handleDbSet(env, `tasks/${taskId}`, newTask);
        
        // ØªØ³Ø¬ÙŠÙ„ Ø·Ù„Ø¨ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù‡Ù…Ø©
        await handleDbPush(env, `task_requests/${taskId}`, {
            userId: userId,
            taskData: newTask,
            requestedAt: Date.now(),
            status: 'awaiting_payment'
        });
        
        return {
            success: true,
            data: { 
                taskId: taskId,
                status: 'pending_payment',
                message: 'Task created successfully. Please wait 10 seconds for payment verification.',
                nextStep: 'verifyPayment',
                verifyAfter: 10000 // 10 Ø«ÙˆØ§Ù†Ù
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'CREATE_TASK_ERROR'
        };
    }
}

async function handleVerifyTaskPayment(env, taskId) {
    try {
        const taskResult = await handleDbGet(env, `tasks/${taskId}`);
        if (!taskResult.success || !taskResult.data) {
            return { 
                success: false, 
                error: 'Task not found',
                errorCode: 'TASK_NOT_FOUND'
            };
        }
        
        const task = taskResult.data;
        const now = Date.now();
        
        // ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„ØªØ­Ù‚Ù‚
        const checkCount = (task.paymentCheckCount || 0) + 1;
        
        await handleDbUpdate(env, `tasks/${taskId}`, { 
            paymentCheckCount: checkCount,
            lastPaymentCheck: now,
            lastUpdated: Date.now()
        });
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ÙŠØ¯ÙˆÙŠ - Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ø¹Ø¯ 10 Ø«ÙˆØ§Ù†Ù
        const timeSinceCreation = now - (task.createdAt || 0);
        
        if (timeSinceCreation >= 10000) { // 10 Ø«ÙˆØ§Ù†Ù
            // ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¯ÙØ¹ (Ù…Ø­Ø§ÙƒØ§Ø©)
            await handleDbUpdate(env, `tasks/${taskId}`, { 
                status: 'active',
                paymentVerified: true,
                verifiedAt: now,
                activeSince: now,
                lastUpdated: Date.now()
            });
            
            // ØªØ­Ø¯ÙŠØ« Ø·Ù„Ø¨ Ø§Ù„Ù…Ù‡Ù…Ø©
            await handleDbUpdate(env, `task_requests/${taskId}`, {
                status: 'payment_verified',
                verifiedAt: now,
                verifiedBy: 'system_auto'
            });
            
            return {
                success: true,
                data: { 
                    verified: true,
                    status: 'active',
                    message: 'Payment verified successfully. Task is now active.',
                    taskId: taskId,
                    verifiedAt: now
                }
            };
        } else {
            // Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ÙˆÙ‚Øª
            const timeRemaining = 10000 - timeSinceCreation;
            
            return {
                success: true,
                data: { 
                    verified: false,
                    status: 'pending_payment',
                    message: 'Payment verification in progress. Please wait...',
                    timeRemaining: Math.max(0, timeRemaining),
                    checkCount: checkCount,
                    nextCheckIn: Math.ceil(timeRemaining / 1000)
                }
            };
        }
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_TASK_PAYMENT_ERROR'
        };
    }
}

async function handleVerifyTaskChannel(env, userId, data) {
    try {
        const { taskId, channelUsername } = data;
        
        console.log(`Verifying channel membership for user ${userId} in channel ${channelUsername}`);
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        const completedTasks = userData.completedTasks || {};
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ù‡Ù…Ø© Ù…ÙƒØªÙ…Ù„Ø© Ø¨Ø§Ù„ÙØ¹Ù„
        if (completedTasks[taskId]) {
            return { 
                success: true,
                data: {
                    alreadyCompleted: true,
                    verified: true,
                    message: 'Task already completed.',
                    reward: completedTasks[taskId].reward || 0,
                    newBalance: userData.dogsBalance,
                    taskStatus: 'already_completed',
                    updatedUserData: userData
                }
            };
        }
        
        // ØªÙ†Ø¸ÙŠÙ Ø§Ø³Ù… Ø§Ù„Ù‚Ù†Ø§Ø©
        let cleanChannelUsername = channelUsername;
        
        if (cleanChannelUsername.includes('t.me/')) {
            cleanChannelUsername = cleanChannelUsername.split('t.me/')[1];
        }
        
        if (cleanChannelUsername.startsWith('@')) {
            cleanChannelUsername = cleanChannelUsername.substring(1);
        }
        
        console.log(`Cleaned channel username: ${cleanChannelUsername}`);
        
        // Ø¬Ù„Ø¨ Bot Token
        const botToken = env.TELEGRAM_BOT_TOKEN || '7066931017:AAHwuXbgaKHNrHrbf6jaoC8LDk0lSCPimgI';
        
        if (!botToken) {
            return { 
                success: false, 
                error: 'Bot token not configured',
                errorCode: 'BOT_TOKEN_MISSING'
            };
        }
        
        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Telegram Bot API Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¶ÙˆÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const chatMemberUrl = `https://api.telegram.org/bot${botToken}/getChatMember`;
        
        console.log(`Calling Telegram API: ${chatMemberUrl}`);
        console.log(`Request data: chat_id=@${cleanChannelUsername}, user_id=${userId}`);
        
        let telegramResult;
        
        try {
            // Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰: Ø§Ø³ØªØ®Ø¯Ø§Ù… @username
            const response = await fetch(chatMemberUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: `@${cleanChannelUsername}`,
                    user_id: parseInt(userId)
                })
            });
            
            console.log(`Telegram API response status: ${response.status}`);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error(`Telegram API error: ${errorText}`);
                
                // Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¯ÙŠÙ„Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… numeric chat_id
                try {
                    // Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø¹Ù† Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‚Ù†Ø§Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ chat_id Ø§Ù„Ø±Ù‚Ù…ÙŠ
                    const getChatUrl = `https://api.telegram.org/bot${botToken}/getChat`;
                    const getChatResponse = await fetch(getChatUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chat_id: `@${cleanChannelUsername}`
                        })
                    });
                    
                    if (getChatResponse.ok) {
                        const chatInfo = await getChatResponse.json();
                        console.log(`Chat info: ${JSON.stringify(chatInfo)}`);
                        
                        if (chatInfo.ok && chatInfo.result) {
                            const numericChatId = chatInfo.result.id;
                            console.log(`Found numeric chat ID: ${numericChatId}`);
                            
                            // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… numeric chat_id
                            const retryResponse = await fetch(chatMemberUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    chat_id: numericChatId,
                                    user_id: parseInt(userId)
                                })
                            });
                            
                            if (retryResponse.ok) {
                                telegramResult = await retryResponse.json();
                            } else {
                                throw new Error('Failed with numeric chat ID too');
                            }
                        }
                    }
                } catch (fallbackError) {
                    console.error('Fallback verification failed:', fallbackError);
                    return { 
                        success: false, 
                        error: 'Failed to verify channel membership. Please make sure you have joined the channel and try again.',
                        errorCode: 'TELEGRAM_API_ERROR',
                        data: {
                            verificationStatus: 'failed',
                            errorDetails: errorText,
                            debug: {
                                channelUsername: cleanChannelUsername,
                                userId: userId
                            }
                        }
                    };
                }
            } else {
                telegramResult = await response.json();
            }
            
            console.log(`Telegram API result: ${JSON.stringify(telegramResult)}`);
            
            if (!telegramResult.ok) {
                return {
                    success: false,
                    error: 'Unable to verify membership. Please try again.',
                    errorCode: 'TELEGRAM_API_FAILED',
                    data: {
                        telegramResult: telegramResult,
                        verificationStatus: 'api_failed'
                    }
                };
            }
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø¶ÙˆÙŠØ©
            const memberStatus = telegramResult.result.status;
            const isMember = memberStatus === 'member' || 
                           memberStatus === 'administrator' || 
                           memberStatus === 'creator';
            
            console.log(`User ${userId} membership status: ${memberStatus}, isMember: ${isMember}`);
            
            if (!isMember) {
                return { 
                    success: false, 
                    error: 'You must join the channel first! Please join the channel and try again.',
                    errorCode: 'NOT_CHANNEL_MEMBER',
                    data: {
                        verificationStatus: 'not_member',
                        channelUsername: cleanChannelUsername,
                        currentStatus: memberStatus,
                        requiredStatus: ['member', 'administrator', 'creator']
                    }
                };
            }
            
            // Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
            const configResult = await handleGetConfig();
            const settings = configResult.data?.settings || {};
            const TASK_CHANNEL_REWARD = settings.taskChannelReward || 2000;
            
            // ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ø©
            completedTasks[taskId] = {
                completedAt: Date.now(),
                channel: cleanChannelUsername,
                reward: TASK_CHANNEL_REWARD,
                status: 'completed',
                verifiedAt: Date.now()
            };
            
            const newBalance = (userData.dogsBalance || 0) + TASK_CHANNEL_REWARD;
            
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            await handleDbUpdate(env, `users/${userId}`, { 
                completedTasks: completedTasks,
                dogsBalance: newBalance,
                lastTaskCompletion: Date.now(),
                lastUpdated: Date.now()
            });
            
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù‡Ù…Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            const taskResult = await handleDbGet(env, `tasks/${taskId}`);
            if (taskResult.success && taskResult.data) {
                const task = taskResult.data;
                if (task.remaining !== undefined && task.remaining > 0) {
                    await handleDbUpdate(env, `tasks/${taskId}`, { 
                        remaining: task.remaining - 1,
                        lastCompleted: Date.now(),
                        lastCompletedBy: userId,
                        completedCount: (task.completedCount || 0) + 1,
                        lastUpdated: Date.now()
                    });
                }
            }
            
            // ØªØ³Ø¬ÙŠÙ„ ÙÙŠ Ø§Ù„Ø³Ø¬Ù„
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'earn',
                description: `Joined Telegram Channel: ${cleanChannelUsername}`,
                amount: TASK_CHANNEL_REWARD,
                currency: 'GLX',
                date: new Date().toISOString(),
                taskId: taskId,
                channel: cleanChannelUsername
            });
            
            // Ø­ÙØ¸ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„
            await handleDbSet(env, `tasks/${taskId}/completions/${userId}`, {
                completedAt: Date.now(),
                reward: TASK_CHANNEL_REWARD,
                verified: true,
                channel: cleanChannelUsername,
                status: 'completed',
                userId: userId
            });
            
            // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
            const updatedUserResult = await handleDbGet(env, `users/${userId}`);
            const updatedUserData = updatedUserResult.data || userData;
            
            return {
                success: true,
                data: {
                    verified: true,
                    reward: TASK_CHANNEL_REWARD,
                    newBalance: newBalance,
                    channel: cleanChannelUsername,
                    membershipStatus: memberStatus,
                    message: 'Channel membership verified successfully! Task completed.',
                    taskStatus: 'completed',
                    taskId: taskId,
                    completionTime: Date.now(),
                    updatedUserData: updatedUserData
                }
            };
            
        } catch (apiError) {
            console.error('Telegram API call failed:', apiError);
            return { 
                success: false, 
                error: 'Unable to verify channel membership at this time. Please try again later.',
                errorCode: 'TELEGRAM_API_CALL_FAILED',
                data: {
                    errorDetails: apiError.message,
                    verificationStatus: 'api_error'
                }
            };
        }
        
    } catch (error) {
        console.error('Verify task channel error:', error);
        return {
            success: false,
            error: 'An unexpected error occurred. Please try again.',
            errorCode: 'VERIFY_TASK_CHANNEL_ERROR',
            data: {
                errorDetails: error.message,
                verificationStatus: 'error'
            }
        };
    }
}

async function handleSpinSlots(env, userId) {
    try {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        if ((userData.extraSpins || 0) <= 0) {
            return { 
                success: false, 
                error: 'No spins left',
                errorCode: 'NO_SPINS_AVAILABLE'
            };
        }
        
        const newSpins = (userData.extraSpins || 1) - 1;
        await handleDbUpdate(env, `users/${userId}`, { 
            extraSpins: newSpins,
            lastUpdated: Date.now()
        });
        
        const symbols = ['ğŸŒŸ', 'ğŸª', 'ğŸ’«', 'â­', 'ğŸš€', 'ğŸŒŒ'];
        const results = [
            symbols[Math.floor(Math.random() * symbols.length)],
            symbols[Math.floor(Math.random() * symbols.length)],
            symbols[Math.floor(Math.random() * symbols.length)]
        ];
        
        let winAmount = 0;
        const resultString = results.join('');
        
        if (resultString === 'ğŸŒŸğŸŒŸğŸŒŸ') winAmount = 10000;
        else if (resultString === 'ğŸªğŸªğŸª') winAmount = 5000;
        else if (resultString === 'ğŸ’«ğŸ’«ğŸ’«') winAmount = 2500;
        else if (resultString === 'â­â­â­') winAmount = 1200;
        else if (results[0] === 'ğŸŒŸ' && results[1] === 'ğŸŒŸ') winAmount = 700;
        else if (results[1] === 'ğŸŒŸ' && results[2] === 'ğŸŒŸ') winAmount = 700;
        else if (results[0] === results[1] || results[1] === results[2] || results[0] === results[2]) winAmount = 500;
        
        if (winAmount > 0) {
            const newBalance = userData.dogsBalance + winAmount;
            await handleDbUpdate(env, `users/${userId}`, { 
                dogsBalance: newBalance,
                lastUpdated: Date.now()
            });
            
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'earn',
                description: `Galaxy Slots Win (${resultString})`,
                amount: winAmount,
                currency: 'GLX',
                date: new Date().toISOString()
            });
            
            // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
            const updatedUserResult = await handleDbGet(env, `users/${userId}`);
            const updatedUserData = updatedUserResult.data || userData;
            
            return {
                success: true,
                data: {
                    results: results,
                    winAmount: winAmount,
                    newBalance: updatedUserData.dogsBalance,
                    newSpins: newSpins,
                    updatedUserData: updatedUserData
                }
            };
        } else {
            // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
            const updatedUserResult = await handleDbGet(env, `users/${userId}`);
            const updatedUserData = updatedUserResult.data || userData;
            
            return {
                success: true,
                data: {
                    results: results,
                    winAmount: 0,
                    newBalance: updatedUserData.dogsBalance,
                    newSpins: newSpins,
                    updatedUserData: updatedUserData
                }
            };
        }
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'SPIN_SLOTS_ERROR'
        };
    }
}

async function handleAddExtraSpin(env, userId) {
    try {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        const newSpins = (userData.extraSpins || 0) + 1;
        await handleDbUpdate(env, `users/${userId}`, { 
            extraSpins: newSpins,
            lastUpdated: Date.now()
        });
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: 'Extra Spin from Ad',
            amount: 1,
            currency: 'Spin',
            date: new Date().toISOString()
        });
        
        // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        return {
            success: true,
            data: {
                newSpins: newSpins,
                updatedUserData: updatedUserData
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'ADD_EXTRA_SPIN_ERROR'
        };
    }
}

async function handleClaimDailyBonus(env, userId) {
    try {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        const now = Date.now();
        const msInDay = 86400000;
        
        let streak = userData.dailyStreak || 0;
        const lastClaim = userData.lastDailyClaim || 0;
        
        if (now - lastClaim > 172800000) {
            streak = 0;
        }
        
        const rewards = [2000, 3000, 5000, 7000, 9000, 12000, 15000];
        const reward = rewards[Math.min(streak, rewards.length - 1)] || 100;
        
        const updates = {
            lastDailyClaim: now,
            dailyStreak: streak + 1,
            dogsBalance: userData.dogsBalance + reward,
            lastUpdated: Date.now()
        };
        
        await handleDbUpdate(env, `users/${userId}`, updates);
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: `Daily Login Day ${streak + 1}`,
            amount: reward,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        return {
            success: true,
            data: {
                reward: reward,
                lastDailyClaim: now,
                dailyStreak: streak + 1,
                newBalance: updatedUserData.dogsBalance,
                updatedUserData: updatedUserData
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'CLAIM_DAILY_BONUS_ERROR'
        };
    }
}

async function handleGetTransactionHistory(env, userId, limit = 50) {
    try {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const historyResult = await handleDbGet(env, `users/${userId}/history`);
        const historyData = historyResult.data || {};
        
        const historyArray = Object.values(historyData)
            .sort((a, b) => new Date(b.date) - new Date(a.date))
            .slice(0, limit);
        
        return {
            success: true,
            data: {
                history: historyArray
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_TRANSACTION_HISTORY_ERROR'
        };
    }
}

async function handleGetUserWithdrawals(env, userId) {
    try {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const withdrawalsResult = await handleDbGet(env, 'withdrawals/pending');
        const withdrawalsData = withdrawalsResult.data || {};
        
        const userWithdrawals = [];
        
        for (const [key, withdrawal] of Object.entries(withdrawalsData)) {
            if (withdrawal.userId === userId) {
                userWithdrawals.push({
                    key: key,
                    ...withdrawal
                });
            }
        }
        
        userWithdrawals.sort((a, b) => b.timestamp - a.timestamp);
        
        return {
            success: true,
            data: {
                withdrawals: userWithdrawals
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_USER_WITHDRAWALS_ERROR'
        };
    }
}

async function handleGetWithdrawalHistory(env) {
    try {
        // Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø³Ø­ÙˆØ¨Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© ÙÙ‚Ø·
        const completedResult = await handleDbGet(env, 'withdrawals/completed');
        const completedData = completedResult.data || {};
        
        const withdrawals = [];
        
        for (const [key, withdrawal] of Object.entries(completedData)) {
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø³Ø­Ø¨ Ù…ÙƒØªÙ…Ù„ Ø¨Ø§Ù„ÙØ¹Ù„
            if (withdrawal.status === 'completed') {
                const userResult = await handleDbGet(env, `users/${withdrawal.userId}`);
                if (userResult.success && userResult.data) {
                    // ØªØ®Ø·ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†
                    if (userResult.data.isBlocked) continue;
                    
                    withdrawals.push({
                        ...withdrawal,
                        key: key,
                        name: userResult.data.name || 'Anonymous',
                        photoUrl: userResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png'
                    });
                }
            }
        }
        
        withdrawals.sort((a, b) => b.timestamp - a.timestamp);
        
        return {
            success: true,
            data: {
                withdrawals: withdrawals.slice(0, 50),
                completedCount: withdrawals.length,
                message: 'Showing completed withdrawals only'
            }
        };
    } catch (error) {
        console.error('Get withdrawal history error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_WITHDRAWAL_HISTORY_ERROR'
        };
    }
}

async function handleGetWithdrawalStats(env) {
    try {
        const completedResult = await handleDbGet(env, 'withdrawals/completed');
        const pendingResult = await handleDbGet(env, 'withdrawals/pending');
        
        const completedData = completedResult.data || {};
        const pendingData = pendingResult.data || {};
        
        let completedCount = 0;
        let totalPaid = 0;
        let pendingCount = 0;
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø­ÙˆØ¨Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©
        for (const [key, withdrawal] of Object.entries(completedData)) {
            if (withdrawal.status === 'completed') {
                completedCount++;
                totalPaid += parseFloat(withdrawal.amount || 0);
            }
        }
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø­ÙˆØ¨Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©
        for (const [key, withdrawal] of Object.entries(pendingData)) {
            if (withdrawal.status === 'pending') {
                pendingCount++;
            }
        }
        
        return {
            success: true,
            data: {
                completedCount: completedCount,
                totalPaid: totalPaid.toFixed(4),
                pendingCount: pendingCount,
                totalWithdrawals: completedCount + pendingCount
            }
        };
    } catch (error) {
        console.error('Get withdrawal stats error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_WITHDRAWAL_STATS_ERROR'
        };
    }
}

async function handleGetReferredUsers(env, userId) {
    try {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        const referredUsers = userData.referredUsers || [];
        
        const referredUsersData = [];
        
        for (const referredUserId of referredUsers) {
            const referredUserResult = await handleDbGet(env, `users/${referredUserId}`);
            if (referredUserResult.success && referredUserResult.data) {
                referredUsersData.push({
                    userId: referredUserId,
                    name: referredUserResult.data.name || 'Anonymous User',
                    photoUrl: referredUserResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                    joinDate: referredUserResult.data.joinDate,
                    dogsBalance: referredUserResult.data.dogsBalance || 0
                });
            }
        }
        
        return {
            success: true,
            data: {
                referredUsers: referredUsersData
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_REFERRED_USERS_ERROR'
        };
    }
}

async function handleGetTasks(env, userId) {
    try {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const tasksResult = await handleDbGet(env, 'tasks');
        const tasksData = tasksResult.data || {};
        
        const activeTasks = [];
        
        for (const [taskId, task] of Object.entries(tasksData)) {
            if (task.status === 'active' && (task.remaining === undefined || task.remaining > 0)) {
                activeTasks.push({
                    id: taskId,
                    ...task
                });
            }
        }
        
        return {
            success: true,
            data: {
                tasks: activeTasks
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_TASKS_ERROR'
        };
    }
}

async function handleVerifyTaskCompletion(env, userId, data) {
    try {
        const { taskId, reward, title, link, channelUsername, claimReward = false } = data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        const taskResult = await handleDbGet(env, `tasks/${taskId}`);
        if (!taskResult.success || !taskResult.data) {
            return { 
                success: false, 
                error: 'Task not found',
                errorCode: 'TASK_NOT_FOUND'
            };
        }
        
        const task = taskResult.data;
        
        const completedTasks = userData.completedTasks || {};
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ù‡Ù…Ø© Ù…ÙƒØªÙ…Ù„Ø© Ø¨Ø§Ù„ÙØ¹Ù„
        if (completedTasks[taskId]) {
            return { 
                success: true,
                data: {
                    alreadyCompleted: true,
                    taskCompleted: true,
                    taskStatus: 'already_completed',
                    message: 'Task already completed.',
                    reward: completedTasks[taskId].reward || 0,
                    newBalance: userData.dogsBalance,
                    updatedUserData: userData
                }
            };
        }
        
        if (task.remaining !== undefined && task.remaining <= 0) {
            return { 
                success: false, 
                error: 'No rewards left for this task',
                errorCode: 'NO_TASK_REWARDS_LEFT'
            };
        }
        
        const rewardAmount = parseInt(reward);
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ù…Ù‡Ù…Ø© ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø®Ø²Ù†Ø©
        if (task.reward && rewardAmount !== task.reward) {
            return { 
                success: false, 
                error: `Invalid task reward: Expected ${task.reward}, got ${rewardAmount}`,
                errorCode: 'INVALID_TASK_REWARD'
            };
        }
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª claimReward = false (ØªØ­Ù‚Ù‚ ÙÙ‚Ø·)
        if (!claimReward) {
            return {
                success: true,
                data: {
                    taskAvailable: true,
                    taskId: taskId,
                    reward: rewardAmount,
                    title: title,
                    message: 'Task is available for completion',
                    userBalance: userData.dogsBalance,
                    taskStatus: 'available',
                    updatedUserData: userData
                }
            };
        }
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª claimReward = true (Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø© Ø¨Ø§Ù„Ù…ÙƒØ§ÙØ£Ø©)
        const newBalance = userData.dogsBalance + rewardAmount;
        
        const updates = {};
        if (task.remaining !== undefined) {
            updates.remaining = task.remaining - 1;
            updates.lastUpdated = Date.now();
        }
        
        const userUpdates = {
            dogsBalance: newBalance,
            lastUpdated: Date.now(),
            lastActivity: Date.now()
        };
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù‡Ù…Ø© ÙƒÙ…ÙƒØªÙ…Ù„Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        completedTasks[taskId] = {
            completedAt: Date.now(),
            reward: rewardAmount,
            taskTitle: title,
            verified: true
        };
        
        userUpdates.completedTasks = completedTasks;
        
        // ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        await handleDbUpdate(env, `users/${userId}`, userUpdates);
        
        if (Object.keys(updates).length > 0) {
            await handleDbUpdate(env, `tasks/${taskId}`, updates);
        }
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: `Mission: ${title}`,
            amount: rewardAmount,
            currency: 'GLX',
            date: new Date().toISOString(),
            taskId: taskId,
            link: link,
            channelUsername: channelUsername
        });
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || { ...userData, ...userUpdates };
        
        return {
            success: true,
            data: {
                taskCompleted: true,
                reward: rewardAmount,
                newBalance: updatedUserData.dogsBalance,
                message: 'Task completed successfully and reward claimed!',
                updatedUserData: updatedUserData,
                taskId: taskId
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_TASK_COMPLETION_ERROR'
        };
    }
}

async function handleReferral(env, userId, referrerId) {
    try {
        if (!referrerId || referrerId === userId) {
            return { 
                success: false, 
                error: 'Invalid referrer',
                errorCode: 'INVALID_REFERRER'
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
        const userBlockCheck = await checkUserBlocked(env, userId);
        const referrerBlockCheck = await checkUserBlocked(env, referrerId);
        
        if ((userBlockCheck && userBlockCheck.isBlocked) || (referrerBlockCheck && referrerBlockCheck.isBlocked)) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    userBlocked: userBlockCheck ? userBlockCheck.isBlocked : false,
                    referrerBlocked: referrerBlockCheck ? referrerBlockCheck.isBlocked : false,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${userBlockCheck?.reason || referrerBlockCheck?.reason}\nViolation: ${userBlockCheck?.violation || referrerBlockCheck?.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (userResult.success && userResult.data && userResult.data.referrer) {
            return { 
                success: false, 
                error: 'Already referred',
                errorCode: 'ALREADY_REFERRED'
            };
        }
        
        await handleDbUpdate(env, `users/${userId}`, { 
            referrer: referrerId, 
            joinDate: Date.now(),
            lastUpdated: Date.now()
        });
        
        const referrerResult = await handleDbGet(env, `users/${referrerId}`);
        if (!referrerResult.success || !referrerResult.data) {
            return { 
                success: true, 
                data: { referred: true } 
            };
        }
        
        const referrerData = referrerResult.data;
        
        const referredUsers = referrerData.referredUsers || [];
        if (!referredUsers.includes(userId)) {
            referredUsers.push(userId);
        }
        
        // Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ø¥Ø­Ø§Ù„Ø© 100,000 GLX
        const referralReward = 100000;
        
        const updates = {
            referredUsers: referredUsers,
            referrals: (referrerData.referrals || 0) + 1,
            dogsBalance: (referrerData.dogsBalance || 0) + referralReward,
            lastUpdated: Date.now()
        };
        
        await handleDbUpdate(env, `users/${referrerId}`, updates);
        
        await handleDbPush(env, `users/${referrerId}/history`, {
            type: 'referral',
            description: 'Friend Invited',
            amount: referralReward,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        const updatedReferrerResult = await handleDbGet(env, `users/${referrerId}`);
        const updatedReferrerData = updatedReferrerResult.data || referrerData;
        
        return {
            success: true,
            data: { 
                referred: true,
                referralReward: referralReward,
                updatedUserData: updatedReferrerData
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'HANDLE_REFERRAL_ERROR'
        };
    }
}

async function handleTestFirebase(env) {
    try {
        console.log('Testing Firebase connection...');
        console.log('API Key:', env.FIREBASE_API_KEY ? 'Present' : 'Missing');
        console.log('DB URL:', env.FIREBASE_DATABASE_URL);
        
        // Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„
        const testPath = 'connection_test';
        const timestamp = Date.now();
        
        // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ÙƒØªØ§Ø¨Ø©
        const writeUrl = await getFirebaseUrl(env, testPath);
        console.log('Write URL:', writeUrl);
        
        const writeResponse = await fetch(writeUrl, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                test: true, 
                timestamp: timestamp,
                message: 'Firebase connection test'
            })
        });
        
        console.log('Write status:', writeResponse.status);
        
        if (!writeResponse.ok) {
            const errorText = await writeResponse.text();
            console.error('Write error:', errorText);
            throw new Error(`Write failed: ${writeResponse.status} - ${errorText}`);
        }
        
        const writeResult = await writeResponse.json();
        console.log('Write result:', writeResult);
        
        // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©
        const readResponse = await fetch(writeUrl);
        console.log('Read status:', readResponse.status);
        
        if (!readResponse.ok) {
            const errorText = await readResponse.text();
            throw new Error(`Read failed: ${writeResponse.status} - ${errorText}`);
        }
        
        const readData = await readResponse.json();
        console.log('Read data:', readData);
        
        return {
            success: true,
            message: 'Firebase connection successful',
            data: {
                writeStatus: writeResponse.status,
                readStatus: readResponse.status,
                testData: readData,
                apiKeyLength: env.FIREBASE_API_KEY ? env.FIREBASE_API_KEY.length : 0,
                databaseUrl: env.FIREBASE_DATABASE_URL
            }
        };
    } catch (error) {
        console.error('Firebase test error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'FIREBASE_TEST_ERROR',
            debug: {
                apiKey: env.FIREBASE_API_KEY ? 'Present' : 'Missing',
                apiKeyFirst10: env.FIREBASE_API_KEY ? env.FIREBASE_API_KEY.substring(0, 10) + '...' : 'None',
                dbUrl: env.FIREBASE_DATABASE_URL,
                fullUrl: env.FIREBASE_DATABASE_URL ? `${env.FIREBASE_DATABASE_URL}/test.json` : 'No URL'
            }
        };
    }
}

async function handleGetUserData(env, userId) {
    try {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to load competition data',
                errorCode: 'COMPETITION_DATA_LOAD_ERROR'
            };
        }
        
        // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªØ­Ø¯ÙŠØ« Ø­Ù‚Ù„ competitionTickets ÙÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const currentUserTickets = competitionData.userTicketCount || 0;
        if (userResult.data.competitionTickets !== currentUserTickets) {
            await handleDbUpdate(env, `users/${userId}`, { 
                competitionTickets: currentUserTickets,
                lastTicketSync: Date.now(),
                lastUpdated: Date.now()
            });
        }
        
        // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userResult.data;
        
        return {
            success: true,
            data: {
                userData: {
                    ...updatedUserData,
                    competitionTickets: currentUserTickets
                },
                contest: {
                    yourTickets: currentUserTickets,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    isActive: competitionData.isActiveNow,
                    endTime: competitionData.endTime,
                    startTime: competitionData.startTime,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted
                }
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_USER_DATA_ERROR'
        };
    }
}

async function handleRefreshCompetition(env) {
    try {
        const competitionData = await ensureAndGetCompetition(env);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to refresh competition',
                errorCode: 'REFRESH_COMPETITION_ERROR'
            };
        }
        
        return {
            success: true,
            data: {
                competitionData: {
                    isActive: competitionData.isActive,
                    startTime: competitionData.startTime,
                    endTime: competitionData.endTime,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted,
                    isActiveNow: competitionData.isActiveNow
                }
            }
        };
    } catch (error) {
        console.error('Error refreshing competition:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'REFRESH_COMPETITION_ERROR'
        };
    }
}

async function handleVerifyTelegramMembership(env, userId, data) {
    try {
        const { channelUsername } = data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        const botToken = env.TELEGRAM_BOT_TOKEN || '7066931017:AAHwuXbgaKHNrHrbf6jaoC8LDk0lSCPimgI';
        
        if (!botToken) {
            return { 
                success: false, 
                error: 'Bot token not configured',
                errorCode: 'BOT_TOKEN_MISSING'
            };
        }
        
        // ØªÙ†Ø¸ÙŠÙ Ø§Ø³Ù… Ø§Ù„Ù‚Ù†Ø§Ø©
        let cleanChannelUsername = channelUsername;
        
        if (cleanChannelUsername.includes('t.me/')) {
            cleanChannelUsername = cleanChannelUsername.split('t.me/')[1];
        }
        
        if (cleanChannelUsername.startsWith('@')) {
            cleanChannelUsername = cleanChannelUsername.substring(1);
        }
        
        const chatMemberUrl = `https://api.telegram.org/bot${botToken}/getChatMember`;
        
        const response = await fetch(chatMemberUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: `@${cleanChannelUsername}`,
                user_id: parseInt(userId)
            })
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            return { 
                success: false, 
                error: 'Failed to verify membership',
                errorCode: 'TELEGRAM_API_ERROR',
                details: errorText
            };
        }
        
        const result = await response.json();
        
        const isMember = result.ok && 
            (result.result.status === 'member' || 
             result.result.status === 'administrator' || 
             result.result.status === 'creator');
        
        return {
            success: true,
            data: {
                isMember: isMember,
                channelUsername: cleanChannelUsername,
                userId: userId,
                status: result.result.status,
                requiredStatus: ['member', 'administrator', 'creator']
            }
        };
        
    } catch (error) {
        console.error('Verify telegram membership error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_TELEGRAM_MEMBERSHIP_ERROR'
        };
    }
}

async function handleSyncUserCompetitionTickets(env, userId) {
    try {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to load competition data',
                errorCode: 'COMPETITION_DATA_LOAD_ERROR'
            };
        }
        
        const currentTickets = competitionData.userTicketCount || 0;
        
        // ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        await handleDbUpdate(env, `users/${userId}`, {
            competitionTickets: currentTickets,
            lastTicketSync: Date.now(),
            lastUpdated: Date.now()
        });
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
        const userResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = userResult.data || {};
        
        return {
            success: true,
            data: {
                competitionTickets: currentTickets,
                userData: updatedUserData,
                contest: {
                    yourTickets: currentTickets,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    isActive: competitionData.isActiveNow
                }
            }
        };
    } catch (error) {
        console.error('Error syncing user competition tickets:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'SYNC_USER_COMPETITION_TICKETS_ERROR'
        };
    }
}

async function handleTestTelegramApi(env, userId, data) {
    try {
        const { channelUsername } = data;
        
        console.log(`Testing Telegram API for channel: ${channelUsername}, user: ${userId}`);
        
        const botToken = env.TELEGRAM_BOT_TOKEN || '7066931017:AAHwuXbgaKHNrHrbf6jaoC8LDk0lSCPimgI';
        
        if (!botToken) {
            return {
                success: false,
                error: 'Bot token not configured',
                errorCode: 'BOT_TOKEN_MISSING'
            };
        }
        
        // Ø§Ø®ØªØ¨Ø§Ø± 1: Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª
        const getMeUrl = `https://api.telegram.org/bot${botToken}/getMe`;
        const getMeResponse = await fetch(getMeUrl);
        const getMeResult = await getMeResponse.json();
        
        console.log('Bot info:', getMeResult);
        
        // Ø§Ø®ØªØ¨Ø§Ø± 2: Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‚Ù†Ø§Ø©
        let cleanChannelUsername = channelUsername;
        
        if (cleanChannelUsername.includes('t.me/')) {
            cleanChannelUsername = cleanChannelUsername.split('t.me/')[1];
        }
        
        if (cleanChannelUsername.startsWith('@')) {
            cleanChannelUsername = cleanChannelUsername.substring(1);
        }
        
        const getChatUrl = `https://api.telegram.org/bot${botToken}/getChat`;
        const getChatResponse = await fetch(getChatUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: `@${cleanChannelUsername}`
            })
        });
        
        const getChatResult = await getChatResponse.json();
        
        console.log('Channel info:', getChatResult);
        
        // Ø§Ø®ØªØ¨Ø§Ø± 3: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¶ÙˆÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const chatMemberUrl = `https://api.telegram.org/bot${botToken}/getChatMember`;
        let membershipResult = null;
        
        if (getChatResult.ok && getChatResult.result) {
            // Ø§Ø³ØªØ®Ø¯Ø§Ù… numeric chat_id Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªØ§Ø­Ù‹Ø§
            const numericChatId = getChatResult.result.id;
            
            const chatMemberResponse = await fetch(chatMemberUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: numericChatId,
                    user_id: parseInt(userId)
                })
            });
            
            membershipResult = await chatMemberResponse.json();
        } else {
            // Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… username
            const chatMemberResponse = await fetch(chatMemberUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: `@${cleanChannelUsername}`,
                    user_id: parseInt(userId)
                })
            });
            
            membershipResult = await chatMemberResponse.json();
        }
        
        console.log('Membership check:', membershipResult);
        
        return {
            success: true,
            data: {
                botInfo: getMeResult,
                channelInfo: getChatResult,
                membershipCheck: membershipResult,
                debug: {
                    channelUsername: cleanChannelUsername,
                    userId: userId,
                    botTokenExists: !!botToken,
                    botTokenFirst10: botToken.substring(0, 10) + '...'
                }
            }
        };
        
    } catch (error) {
        console.error('Test Telegram API error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'TEST_TELEGRAM_API_ERROR',
            stack: error.stack
        };
    }
}

async function migrateWithdrawals(env) {
    try {
        // Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø³Ø­ÙˆØ¨Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
        const oldWithdrawalsResult = await handleDbGet(env, 'withdrawals');
        const oldWithdrawals = oldWithdrawalsResult.data || {};
        
        let migratedCount = 0;
        let completedCount = 0;
        let pendingCount = 0;
        
        for (const [key, withdrawal] of Object.entries(oldWithdrawals)) {
            // ØªØ®Ø·ÙŠ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø¬Ù„Ø¯Ù‹Ø§ (ÙŠØ­ÙˆÙŠ /)
            if (key.includes('/')) continue;
            
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø³Ø­Ø¨ Ù…ÙƒØªÙ…Ù„Ø§Ù‹
            if (withdrawal.status === 'completed' || withdrawal.processed === 'yes' || withdrawal.processed === true) {
                // Ù†Ù‚Ù„ Ø¥Ù„Ù‰ withdrawals/completed
                await handleDbSet(env, `withdrawals/completed/${key}`, withdrawal);
                completedCount++;
                
                // Ø­Ø°Ù Ù…Ù† Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù‚Ø¯ÙŠÙ…
                await handleDbSet(env, `withdrawals/${key}`, null);
                migratedCount++;
            } 
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø³Ø­Ø¨ Ù…Ø¹Ù„Ù‚Ø§Ù‹
            else if (withdrawal.status === 'pending') {
                // Ù†Ù‚Ù„ Ø¥Ù„Ù‰ withdrawals/pending
                await handleDbSet(env, `withdrawals/pending/${key}`, withdrawal);
                pendingCount++;
                
                // Ø­Ø°Ù Ù…Ù† Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù‚Ø¯ÙŠÙ…
                await handleDbSet(env, `withdrawals/${key}`, null);
                migratedCount++;
            }
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø±ÙÙˆØ¶Ø§Ù‹
            else if (withdrawal.status === 'rejected') {
                // Ù†Ù‚Ù„ Ø¥Ù„Ù‰ withdrawals/rejected
                await handleDbSet(env, `withdrawals/rejected/${key}`, withdrawal);
                
                // Ø­Ø°Ù Ù…Ù† Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù‚Ø¯ÙŠÙ…
                await handleDbSet(env, `withdrawals/${key}`, null);
                migratedCount++;
            }
        }
        
        return {
            success: true,
            data: {
                migratedCount: migratedCount,
                completedCount: completedCount,
                pendingCount: pendingCount,
                message: `Successfully migrated ${migratedCount} withdrawals`
            }
        };
    } catch (error) {
        console.error('Migration error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'MIGRATION_ERROR',
            details: error.stack
        };
    }
}

async function handleGetAllPromoCodes(env) {
    try {
        const promoCodesResult = await handleDbGet(env, 'promocodes');
        const promoCodes = promoCodesResult.data || {};
        
        const promoCodeList = [];
        
        for (const [key, promo] of Object.entries(promoCodes)) {
            promoCodeList.push({
                id: key,
                ...promo
            });
        }
        
        // ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ (Ø§Ù„Ø£Ø­Ø¯Ø« Ø£ÙˆÙ„Ø§Ù‹)
        promoCodeList.sort((a, b) => b.createdAt - a.createdAt);
        
        return {
            success: true,
            data: {
                promoCodes: promoCodeList,
                totalCount: promoCodeList.length
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_ALL_PROMO_CODES_ERROR'
        };
    }
}

async function handleGetActivePromoCodes(env) {
    try {
        const promoCodesResult = await handleDbGet(env, 'promocodes');
        const promoCodes = promoCodesResult.data || {};
        
        const activePromoCodes = [];
        
        for (const [key, promo] of Object.entries(promoCodes)) {
            if (promo.status === 'active') {
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
                if (promo.usedCount < promo.maxUsage) {
                    activePromoCodes.push({
                        id: key,
                        ...promo
                    });
                }
            }
        }
        
        // ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ (Ø§Ù„Ø£Ø­Ø¯Ø« Ø£ÙˆÙ„Ø§Ù‹)
        activePromoCodes.sort((a, b) => b.createdAt - a.createdAt);
        
        return {
            success: true,
            data: {
                activePromoCodes: activePromoCodes,
                activeCount: activePromoCodes.length
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_ACTIVE_PROMO_CODES_ERROR'
        };
    }
}

async function handleCreatePromoCode(env, userId, data) {
    try {
        const { code, rewardAmount, rewardType, maxUsage, usagePerUser, description, isPublic } = data;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'ACCOUNT_BLOCKED',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck,
                    blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                    redirectToBlockPage: true
                }
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        if (!code || !rewardAmount || !rewardType) {
            return { 
                success: false, 
                error: 'Missing required fields',
                errorCode: 'MISSING_FIELDS'
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ù†ÙˆØ¹ Ø§Ù„Ù…ÙƒØ§ÙØ£Ø©
        const validRewardTypes = ['glx', 'ton', 'tickets'];
        if (!validRewardTypes.includes(rewardType)) {
            return { 
                success: false, 
                error: 'Invalid reward type. Must be glx, ton, or tickets',
                errorCode: 'INVALID_REWARD_TYPE'
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„ÙƒÙˆØ¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ù‹Ø§
        const promoCodesResult = await handleDbGet(env, 'promocodes');
        const promoCodes = promoCodesResult.data || {};
        
        for (const [key, promo] of Object.entries(promoCodes)) {
            if (promo.code === code) {
                return { 
                    success: false, 
                    error: 'Promo code already exists',
                    errorCode: 'PROMO_CODE_EXISTS'
                };
            }
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯
        const promoId = `promo_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        const newPromoCode = {
            code: code,
            rewardAmount: parseFloat(rewardAmount),
            rewardType: rewardType,
            maxUsage: parseInt(maxUsage) || 100,
            usagePerUser: parseInt(usagePerUser) || 1,
            description: description || '',
            isPublic: isPublic !== false,
            status: 'active',
            usedCount: 0,
            createdAt: Date.now(),
            createdBy: userId,
            lastUpdated: Date.now()
        };
        
        // Ø­ÙØ¸ Ø§Ù„Ø¨Ø±ÙˆÙ…Ùˆ ÙƒÙˆØ¯
        await handleDbSet(env, `promocodes/${promoId}`, newPromoCode);
        
        return {
            success: true,
            data: {
                promoCode: newPromoCode,
                promoId: promoId,
                message: 'Promo code created successfully'
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'CREATE_PROMO_CODE_ERROR'
        };
    }
}

async function handleGetLeaderboard(env) {
    try {
        const usersResult = await handleDbGet(env, 'users');
        const usersData = usersResult.data || {};
        
        const users = [];
        
        for (const [userId, userData] of Object.entries(usersData)) {
            // ØªØ®Ø·ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ† Ù…Ù† Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†
            if (userData.isBlocked) continue;
            
            users.push({
                userId: userId,
                name: userData.name || 'Anonymous',
                photoUrl: userData.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                dogsBalance: userData.dogsBalance || 0,
                referrals: userData.referrals || 0
            });
        }
        
        const byInvites = [...users].sort((a, b) => b.referrals - a.referrals);
        
        const byGLX = [...users].sort((a, b) => b.dogsBalance - a.dogsBalance);
        
        return {
            success: true,
            data: {
                byInvites: byInvites.slice(0, 50),
                byGLX: byGLX.slice(0, 50)
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_LEADERBOARD_ERROR'
        };
    }
}

async function handleGetCompetitionData(env, userId = null) {
    try {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø± Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ù…Ø¹Ø±Ù Ù…Ø³ØªØ®Ø¯Ù…
        if (userId) {
            const blockCheck = await checkUserBlocked(env, userId);
            if (blockCheck && blockCheck.isBlocked) {
                return { 
                    success: false, 
                    error: 'ACCOUNT_BLOCKED',
                    errorCode: 'ACCOUNT_BLOCKED',
                    data: { 
                        isBlocked: true,
                        blockDetails: blockCheck,
                        blockedMessage: `ğŸš« Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\n\nThis decision is final.`,
                        redirectToBlockPage: true
                    }
                };
            }
        }
        
        // Ø£ÙˆÙ„Ø§Ù‹: Ø¶Ù…Ø§Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø§Ø¨Ù‚Ø© Ù†Ø´Ø·Ø©
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to load competition data',
                errorCode: 'COMPETITION_DATA_LOAD_ERROR'
            };
        }
        
        // Ø¬Ù„Ø¨ Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†
        const userTickets = competitionData.userTickets || {};
        const leaderboard = [];
        
        for (const [uId, tickets] of Object.entries(userTickets)) {
            if (tickets > 0) {
                const userResult = await handleDbGet(env, `users/${uId}`);
                if (userResult.success && userResult.data) {
                    // ØªØ®Ø·ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ† Ù…Ù† Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†
                    if (userResult.data.isBlocked) continue;
                    
                    leaderboard.push({
                        userId: uId,
                        name: userResult.data.name || 'Anonymous',
                        photoUrl: userResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                        tickets: tickets
                    });
                }
            }
        }
        
        leaderboard.sort((a, b) => b.tickets - a.tickets);
        
        return {
            success: true,
            data: {
                competitionData: {
                    isActive: competitionData.isActive,
                    startTime: competitionData.startTime,
                    endTime: competitionData.endTime,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted,
                    isActiveNow: competitionData.isActiveNow
                },
                userTickets: userId ? competitionData.userTicketCount || 0 : 0,
                leaderboard: leaderboard.slice(0, 10)
            }
        };
    } catch (error) {
        console.error('Error getting competition data:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_COMPETITION_DATA_ERROR'
        };
    }
}

// ==================== Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ÙƒÙˆØ¯ ====================
