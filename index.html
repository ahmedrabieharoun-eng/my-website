export default {
  async fetch(request, env, ctx) {
    // CORS Ù‡ÙŠØ¯Ø±Ø§Øª
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, PATCH, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
    };

    // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø·Ù„Ø¨Ø§Øª Pre-flight
    if (request.method === "OPTIONS") {
      return new Response(null, { headers: corsHeaders });
    }

    const url = new URL(request.url);
    const params = url.searchParams;
    const action = params.get("action");

    // Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Firebase Ù…Ù† Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©
    const FIREBASE_CONFIG = {
      databaseURL: env.FIREBASE_DATABASE_URL,
      apiKey: env.FIREBASE_API_KEY,
      authDomain: env.FIREBASE_AUTH_DOMAIN,
      projectId: env.FIREBASE_PROJECT_ID,
      secret: env.FIREBASE_DB_SECRET
    };

    if (!FIREBASE_CONFIG.databaseURL) {
      return new Response(
        JSON.stringify({ error: "Server configuration missing" }),
        { 
          status: 500,
          headers: { "Content-Type": "application/json", ...corsHeaders }
        }
      );
    }

    // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ Firebase Realtime Database
    async function firebaseFetch(path, method = "GET", data = null) {
      let fetchUrl = `${FIREBASE_CONFIG.databaseURL}/${path}.json`;
      
      // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªÙˆØ«ÙŠÙ‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø³ÙƒØ±Øª
      if (FIREBASE_CONFIG.secret) {
        fetchUrl += `?auth=${FIREBASE_CONFIG.secret}`;
      }
      
      const options = {
        method: method,
        headers: {
          "Content-Type": "application/json",
        },
      };
      
      if (data && (method === "POST" || method === "PUT" || method === "PATCH")) {
        options.body = JSON.stringify(data);
      }
      
      try {
        const response = await fetch(fetchUrl, options);
        
        if (method === "DELETE") {
          return { success: true };
        }
        
        if (response.status === 200 || response.status === 201) {
          const text = await response.text();
          return text ? JSON.parse(text) : {};
        } else if (response.status === 204) {
          return { success: true };
        } else {
          throw new Error(`Firebase error: ${response.status}`);
        }
      } catch (error) {
        console.error(`Firebase fetch error for ${path}:`, error);
        throw error;
      }
    }

    try {
      let result = {};
      
      // ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£ÙˆÙ„Ø§Ù‹
      if (action === "checkBan") {
        const userId = params.get("userId");
        if (!userId) {
          return new Response(
            JSON.stringify({ error: "User ID required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        const banData = await firebaseFetch(`bannedUsers/${userId}`);
        if (banData && banData.isBanned) {
          result = {
            banned: true,
            reason: banData.reason || "Violation of terms of service"
          };
        } else {
          result = { banned: false };
        }
      }
      
      // ğŸ“‹ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
      else if (action === "getConfig") {
        result = await firebaseFetch("config");
      }
      
      // ğŸ‘¤ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
      else if (action === "login") {
        const reqData = await request.json();
        const userId = reqData.id;
        const refId = reqData.refId;
        
        if (!userId) {
          return new Response(
            JSON.stringify({ error: "User ID required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        let userData = await firebaseFetch(`users/${userId}`);
        const today = new Date().toISOString().slice(0, 10);
        
        if (!userData) {
          // Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯
          userData = {
            id: userId,
            firstName: reqData.firstName || "",
            lastName: reqData.lastName || "",
            username: reqData.username || "",
            photoUrl: reqData.photoUrl || "",
            balance: 0,
            rrBalance: 0,
            referrals: 0,
            referredBy: refId || null,
            totalEarned: 0,
            lifetimeAdCount: 0,
            lastAdWatchDate: today,
            dailyAdCount: 0,
            breakUntil: 0,
            completedTasks: {},
            subscribedToChannels: reqData.subscribedToChannels || false,
            joinDate: new Date().toISOString(),
            lastActive: new Date().toISOString(),
            language: reqData.language || "en",
            country: reqData.country || null
          };
          
          await firebaseFetch(`users/${userId}`, "PUT", userData);
          
          // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø­Ø§Ù„Ø© Ø¥Ø°Ø§ ÙˆØ¬Ø¯Øª
          if (refId && refId !== userId) {
            try {
              const referrer = await firebaseFetch(`users/${refId}`);
              if (referrer) {
                // ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø§Øª Ù„Ù„Ù…Ø­ÙŠÙ„
                await firebaseFetch(`users/${refId}`, "PATCH", {
                  referrals: (referrer.referrals || 0) + 1
                });
                
                // ØªØ­Ø¯ÙŠØ« Ø£Ø±Ø¨Ø§Ø­ Ø§Ù„Ø¥Ø­Ø§Ù„Ø©
                const referralData = await firebaseFetch(`referrals/${refId}`);
                const currentRefData = referralData || {
                  totalEarnings: 0,
                  pendingEarnings: 0,
                  referredUsers: []
                };
                
                currentRefData.referredUsers = currentRefData.referredUsers || [];
                currentRefData.referredUsers.push({
                  id: userId,
                  name: `${reqData.firstName || ""} ${reqData.lastName || ""}`.trim() || "User",
                  joinDate: new Date().toISOString()
                });
                
                await firebaseFetch(`referrals/${refId}`, "PUT", currentRefData);
                
                // ØªØ­Ø¯ÙŠØ« Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ù„Ù„Ù…Ø­ÙŠÙ„
                if (reqData.contestActive) {
                  const contestData = await firebaseFetch(`contest/participants/${refId}`);
                  const currentPoints = contestData?.points || 0;
                  await firebaseFetch(`contest/participants/${refId}`, "PUT", {
                    points: currentPoints + 15,
                    referrals: (contestData?.referrals || 0) + 1,
                    userId: refId,
                    userName: referrer.firstName || "",
                    username: referrer.username || "",
                    lastActivity: Date.now()
                  });
                }
              }
            } catch (error) {
              console.error("Referral processing error:", error);
            }
          }
        } else {
          // Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ - ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
          const updates = {};
          
          if (reqData.photoUrl && userData.photoUrl !== reqData.photoUrl) {
            updates.photoUrl = reqData.photoUrl;
          }
          
          if (reqData.subscribedToChannels !== undefined) {
            updates.subscribedToChannels = reqData.subscribedToChannels;
          }
          
          if (reqData.country) {
            updates.country = reqData.country;
          }
          
          updates.lastActive = new Date().toISOString();
          
          // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ø¥Ø°Ø§ ÙƒØ§Ù† ØªØ§Ø±ÙŠØ® Ø¬Ø¯ÙŠØ¯
          if (userData.lastAdWatchDate !== today) {
            updates.dailyAdCount = 0;
            updates.lastAdWatchDate = today;
          }
          
          if (Object.keys(updates).length > 0) {
            await firebaseFetch(`users/${userId}`, "PATCH", updates);
            userData = { ...userData, ...updates };
          }
        }
        
        result = userData;
      }
      
      // ğŸ“Š ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±ØµÙŠØ¯ (Ø¨Ø¹Ø¯ Ù…Ø´Ø§Ù‡Ø¯Ø© Ø¥Ø¹Ù„Ø§Ù†)
      else if (action === "updateBalance") {
        const reqData = await request.json();
        const userId = reqData.userId;
        const amount = reqData.amount || 0;
        const rrAmount = reqData.rrAmount || 0;
        const adWatched = reqData.adWatched || false;
        const contestPoints = reqData.contestPoints || 0;
        
        if (!userId) {
          return new Response(
            JSON.stringify({ error: "User ID required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        const userData = await firebaseFetch(`users/${userId}`);
        if (!userData) {
          return new Response(
            JSON.stringify({ error: "User not found" }),
            { status: 404, headers: corsHeaders }
          );
        }
        
        const updates = {};
        
        // ØªØ­Ø¯ÙŠØ« Ø±ØµÙŠØ¯ TON
        if (amount !== 0) {
          const newBalance = (userData.balance || 0) + amount;
          updates.balance = newBalance;
          updates.totalEarned = (userData.totalEarned || 0) + amount;
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø±ØµÙŠØ¯ RR
        if (rrAmount !== 0) {
          const newRRBalance = (userData.rrBalance || 0) + rrAmount;
          updates.rrBalance = newRRBalance;
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†Ø§Øª
        if (adWatched) {
          const today = new Date().toISOString().slice(0, 10);
          
          if (userData.lastAdWatchDate !== today) {
            updates.dailyAdCount = 1;
            updates.lastAdWatchDate = today;
          } else {
            updates.dailyAdCount = (userData.dailyAdCount || 0) + 1;
          }
          
          updates.lifetimeAdCount = (userData.lifetimeAdCount || 0) + 1;
          
          // ØªØ­Ø¯ÙŠØ« Ø£Ø±Ø¨Ø§Ø­ Ø§Ù„ÙŠÙˆÙ…
          const todayEarningsRef = `userEarnings/${userId}/${today}`;
          const todayEarnings = await firebaseFetch(todayEarningsRef);
          const newTodayEarnings = (todayEarnings || 0) + (amount || 0);
          await firebaseFetch(todayEarningsRef, "PUT", newTodayEarnings);
          
          // ØªØ­Ø¯ÙŠØ« Ø£Ø±Ø¨Ø§Ø­ Ø§Ù„Ø¥Ø­Ø§Ù„Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† Ù„Ø¯ÙŠÙ‡ Ù…Ø­ÙŠÙ„
          if (userData.referredBy) {
            const referrerId = userData.referredBy;
            const referralData = await firebaseFetch(`referrals/${referrerId}`);
            const currentData = referralData || {
              totalEarnings: 0,
              pendingEarnings: 0,
              referredUsers: []
            };
            
            const referralBonus = rrAmount * 0.15; // 15% Ù…Ù† Ø£Ø±Ø¨Ø§Ø­ RR
            currentData.pendingEarnings = (currentData.pendingEarnings || 0) + referralBonus;
            
            await firebaseFetch(`referrals/${referrerId}`, "PUT", currentData);
          }
        }
        
        // ØªØ­Ø¯ÙŠØ« Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©
        if (contestPoints > 0) {
          const contestData = await firebaseFetch(`contest/participants/${userId}`);
          const currentContestData = contestData || {
            points: 0,
            adsWatched: 0,
            referrals: 0,
            userId: userId,
            userName: userData.firstName || "",
            username: userData.username || ""
          };
          
          currentContestData.points = (currentContestData.points || 0) + contestPoints;
          if (adWatched) {
            currentContestData.adsWatched = (currentContestData.adsWatched || 0) + 1;
          }
          currentContestData.lastActivity = Date.now();
          
          await firebaseFetch(`contest/participants/${userId}`, "PUT", currentContestData);
        }
        
        // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª
        if (Object.keys(updates).length > 0) {
          await firebaseFetch(`users/${userId}`, "PATCH", updates);
          userData.balance = updates.balance !== undefined ? updates.balance : userData.balance;
          userData.rrBalance = updates.rrBalance !== undefined ? updates.rrBalance : userData.rrBalance;
          userData.dailyAdCount = updates.dailyAdCount !== undefined ? updates.dailyAdCount : userData.dailyAdCount;
        }
        
        result = {
          success: true,
          newBalance: userData.balance,
          newRRBalance: userData.rrBalance,
          dailyAdCount: userData.dailyAdCount
        };
      }
      
      // ğŸ’± ØªØ­ÙˆÙŠÙ„ RR Ø¥Ù„Ù‰ TON
      else if (action === "convertRR") {
        const reqData = await request.json();
        const userId = reqData.userId;
        const rrAmount = reqData.rrAmount;
        
        if (!userId || !rrAmount) {
          return new Response(
            JSON.stringify({ error: "User ID and RR amount required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        const userData = await firebaseFetch(`users/${userId}`);
        if (!userData) {
          return new Response(
            JSON.stringify({ error: "User not found" }),
            { status: 404, headers: corsHeaders }
          );
        }
        
        const currentRR = userData.rrBalance || 0;
        if (rrAmount > currentRR) {
          return new Response(
            JSON.stringify({ error: "Insufficient RR balance" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        const RR_TO_TON_RATE = 10000000; // 10 Ù…Ù„ÙŠÙˆÙ† RR = 0.1 TON
        const tonAmount = rrAmount / RR_TO_TON_RATE;
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±ØµÙŠØ¯
        await firebaseFetch(`users/${userId}`, "PATCH", {
          rrBalance: currentRR - rrAmount,
          balance: (userData.balance || 0) + tonAmount
        });
        
        result = {
          success: true,
          convertedRR: rrAmount,
          receivedTON: tonAmount,
          newRRBalance: currentRR - rrAmount,
          newTONBalance: (userData.balance || 0) + tonAmount
        };
      }
      
      // ğŸ† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©
      else if (action === "getContestData") {
        const userId = params.get("userId");
        
        // Ø¬Ù„Ø¨ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©
        const contestConfig = await firebaseFetch("contest");
        const endTime = contestConfig?.endTime || null;
        const isActive = contestConfig?.isActive !== false;
        
        let userPoints = 0;
        let userRank = 0;
        let leaderboard = [];
        
        if (userId) {
          const userContestData = await firebaseFetch(`contest/participants/${userId}`);
          userPoints = userContestData?.points || 0;
        }
        
        // Ø¬Ù„Ø¨ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ† (Ø£ÙØ¶Ù„ 50)
        const allParticipants = await firebaseFetch("contest/participants");
        if (allParticipants) {
          // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© ÙˆÙØ±Ø² Ø­Ø³Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø·
          const participantsArray = Object.values(allParticipants);
          participantsArray.sort((a, b) => (b.points || 0) - (a.points || 0));
          
          leaderboard = participantsArray.slice(0, 50);
          
          // Ø¥ÙŠØ¬Ø§Ø¯ ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
          if (userId) {
            const userIndex = participantsArray.findIndex(p => p.userId === userId);
            userRank = userIndex >= 0 ? userIndex + 1 : 0;
          }
        }
        
        result = {
          userPoints,
          userRank,
          leaderboard: leaderboard.slice(0, 10), // Ø£ÙØ¶Ù„ 10 ÙÙ‚Ø· Ù„Ù„Ø¥Ø±Ø³Ø§Ù„
          endTime,
          isActive,
          durationDays: contestConfig?.durationDays || 7
        };
      }
      
      // ğŸ“… Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙŠÙˆÙ…ÙŠ
      else if (action === "getDailyLogin") {
        const userId = params.get("userId");
        
        if (!userId) {
          return new Response(
            JSON.stringify({ error: "User ID required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        const dailyData = await firebaseFetch(`dailyLogin/${userId}`);
        const today = new Date().toDateString();
        
        result = dailyData || {
          currentStreak: 0,
          lastLoginDate: null,
          claimedDays: []
        };
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        if (result.lastLoginDate !== today) {
          const yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);
          const yesterdayStr = yesterday.toDateString();
          
          if (result.lastLoginDate === yesterdayStr) {
            result.currentStreak = (result.currentStreak || 0) + 1;
          } else if (result.lastLoginDate !== today) {
            result.currentStreak = 1;
          }
          
          result.lastLoginDate = today;
          
          // Ø­ÙØ¸ Ø§Ù„ØªØ­Ø¯ÙŠØ«
          await firebaseFetch(`dailyLogin/${userId}`, "PUT", result);
        }
      }
      
      // ğŸ Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø© Ø¨Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙŠÙˆÙ…ÙŠ
      else if (action === "claimDailyBonus") {
        const reqData = await request.json();
        const userId = reqData.userId;
        
        if (!userId) {
          return new Response(
            JSON.stringify({ error: "User ID required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        const today = new Date().toDateString();
        const dailyData = await firebaseFetch(`dailyLogin/${userId}`);
        const currentData = dailyData || {
          currentStreak: 0,
          lastLoginDate: null,
          claimedDays: []
        };
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ØªÙ… Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø© Ø§Ù„ÙŠÙˆÙ…
        if (currentData.claimedDays && currentData.claimedDays.includes(today)) {
          return new Response(
            JSON.stringify({ error: "Already claimed today" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø¬Ù„Ø¨ Ù…ÙƒØ§ÙØ¢Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
        const config = await firebaseFetch("config");
        const dailyLoginRewards = config?.dailyLoginRewards || [0.0001, 0.0002, 0.0004, 0.0008, 0.0016, 0.0032, 0.0064];
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ÙƒØ§ÙØ£Ø©
        const currentStreak = currentData.currentStreak || 1;
        const rewardIndex = Math.min(currentStreak - 1, dailyLoginRewards.length - 1);
        const rewardAmount = dailyLoginRewards[rewardIndex] || dailyLoginRewards[dailyLoginRewards.length - 1] || 0.0001;
        const rewardAmountRR = Math.round(rewardAmount * 10000000); // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ RR
        
        // ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const userData = await firebaseFetch(`users/${userId}`);
        const newRRBalance = (userData?.rrBalance || 0) + rewardAmountRR;
        
        await firebaseFetch(`users/${userId}`, "PATCH", {
          rrBalance: newRRBalance
        });
        
        // ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙŠÙˆÙ…ÙŠ
        const claimedDays = currentData.claimedDays || [];
        claimedDays.push(today);
        
        await firebaseFetch(`dailyLogin/${userId}`, "PUT", {
          currentStreak: currentStreak,
          lastLoginDate: today,
          claimedDays: claimedDays
        });
        
        result = {
          success: true,
          rewardRR: rewardAmountRR,
          rewardTON: rewardAmount,
          streak: currentStreak,
          newRRBalance: newRRBalance
        };
      }
      
      // ğŸ‘¥ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¥Ø­Ø§Ù„Ø§Øª
      else if (action === "getReferralData") {
        const userId = params.get("userId");
        
        if (!userId) {
          return new Response(
            JSON.stringify({ error: "User ID required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¥Ø­Ø§Ù„Ø§Øª
        const referralData = await firebaseFetch(`referrals/${userId}`);
        const currentRefData = referralData || {
          totalEarnings: 0,
          pendingEarnings: 0,
          referredUsers: []
        };
        
        // Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø§Ù„ÙŠÙ† Ù…Ø¹ ØªÙØ§ØµÙŠÙ„Ù‡Ù…
        const allUsers = await firebaseFetch("users");
        const referredUsersDetails = [];
        
        if (allUsers && currentRefData.referredUsers) {
          currentRefData.referredUsers.forEach(refUser => {
            if (allUsers[refUser.id]) {
              referredUsersDetails.push({
                id: refUser.id,
                name: `${allUsers[refUser.id].firstName || ''} ${allUsers[refUser.id].lastName || ''}`.trim() || 'User',
                username: allUsers[refUser.id].username || '',
                photoUrl: allUsers[refUser.id].photoUrl || 'https://ui-avatars.com/api/?name=User&background=random&size=35',
                joinDate: allUsers[refUser.id].joinDate,
                totalEarned: allUsers[refUser.id].totalEarned || 0
              });
            }
          });
        }
        
        // Ø¹Ø¯Ø¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø§Øª Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const userData = await firebaseFetch(`users/${userId}`);
        const referralCount = userData?.referrals || 0;
        
        result = {
          totalReferrals: referralCount,
          totalEarnings: currentRefData.totalEarnings || 0,
          pendingEarnings: currentRefData.pendingEarnings || 0,
          referredUsers: referredUsersDetails,
          commissionRate: 15 // 15%
        };
      }
      
      // ğŸ Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø© Ø¨Ø£Ø±Ø¨Ø§Ø­ Ø§Ù„Ø¥Ø­Ø§Ù„Ø©
      else if (action === "claimReferralEarnings") {
        const reqData = await request.json();
        const userId = reqData.userId;
        
        if (!userId) {
          return new Response(
            JSON.stringify({ error: "User ID required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        const referralData = await firebaseFetch(`referrals/${userId}`);
        const currentData = referralData || {
          totalEarnings: 0,
          pendingEarnings: 0,
          referredUsers: []
        };
        
        if (currentData.pendingEarnings <= 0) {
          return new Response(
            JSON.stringify({ error: "No pending earnings to claim" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const userData = await firebaseFetch(`users/${userId}`);
        const newRRBalance = (userData?.rrBalance || 0) + currentData.pendingEarnings;
        
        await firebaseFetch(`users/${userId}`, "PATCH", {
          rrBalance: newRRBalance
        });
        
        // ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¥Ø­Ø§Ù„Ø©
        await firebaseFetch(`referrals/${userId}`, "PUT", {
          totalEarnings: (currentData.totalEarnings || 0) + currentData.pendingEarnings,
          pendingEarnings: 0,
          referredUsers: currentData.referredUsers || []
        });
        
        result = {
          success: true,
          claimedAmount: currentData.pendingEarnings,
          newRRBalance: newRRBalance
        };
      }
      
      // ğŸ”‘ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯
      else if (action === "redeemCode") {
        const reqData = await request.json();
        const userId = reqData.userId;
        const code = reqData.code?.trim().toUpperCase();
        
        if (!userId || !code) {
          return new Response(
            JSON.stringify({ error: "User ID and code required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒÙˆØ¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹
        const redeemedCodes = await firebaseFetch(`redeemedCodes/${userId}`);
        if (redeemedCodes && redeemedCodes.includes(code)) {
          return new Response(
            JSON.stringify({ error: "Code already used" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙƒÙˆØ¯
        const codeData = await firebaseFetch(`codes/${code}`);
        if (!codeData) {
          return new Response(
            JSON.stringify({ error: "Invalid code" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ÙƒÙˆØ¯
        if (codeData.usedCount >= codeData.maxUses) {
          return new Response(
            JSON.stringify({ error: "Code usage limit reached" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        if (codeData.expires && Date.now() > codeData.expires) {
          return new Response(
            JSON.stringify({ error: "Code expired" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        let rewardMessage = "";
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹
        if (codeData.rewardType === "TON") {
          const tonAmount = codeData.rewardValue || 0;
          const userData = await firebaseFetch(`users/${userId}`);
          await firebaseFetch(`users/${userId}`, "PATCH", {
            balance: (userData?.balance || 0) + tonAmount
          });
          rewardMessage = `${tonAmount.toFixed(4)} TON`;
          
        } else if (codeData.rewardType === "RR") {
          const rrAmount = codeData.rewardValue || 0;
          const userData = await firebaseFetch(`users/${userId}`);
          await firebaseFetch(`users/${userId}`, "PATCH", {
            rrBalance: (userData?.rrBalance || 0) + rrAmount
          });
          rewardMessage = `${rrAmount.toLocaleString()} RR`;
          
        } else if (codeData.rewardType === "points") {
          const points = codeData.rewardValue || 0;
          const contestData = await firebaseFetch(`contest/participants/${userId}`);
          const currentPoints = contestData?.points || 0;
          await firebaseFetch(`contest/participants/${userId}`, "PUT", {
            points: currentPoints + points,
            userId: userId,
            lastActivity: Date.now()
          });
          rewardMessage = `${points} contest points`;
          
        } else {
          // Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ (Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©)
          const points = codeData.rewardValue || 10;
          const contestData = await firebaseFetch(`contest/participants/${userId}`);
          const currentPoints = contestData?.points || 0;
          await firebaseFetch(`contest/participants/${userId}`, "PUT", {
            points: currentPoints + points,
            userId: userId,
            lastActivity: Date.now()
          });
          rewardMessage = `${points} contest points`;
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒÙˆØ¯
        await firebaseFetch(`codes/${code}`, "PATCH", {
          usedCount: (codeData.usedCount || 0) + 1,
          lastUsed: Date.now(),
          lastUsedBy: userId
        });
        
        // Ø­ÙØ¸ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const userRedeemedCodes = redeemedCodes || [];
        userRedeemedCodes.push(code);
        await firebaseFetch(`redeemedCodes/${userId}`, "PUT", userRedeemedCodes);
        
        result = {
          success: true,
          message: `Code redeemed! You earned ${rewardMessage}!`
        };
      }
      
      // ğŸ’³ Ø·Ù„Ø¨ Ø³Ø­Ø¨
      else if (action === "withdraw") {
        const reqData = await request.json();
        const userId = reqData.userId;
        const method = reqData.method;
        const account = reqData.account;
        const amount = reqData.amount;
        const memo = reqData.memo || "";
        
        if (!userId || !method || !account || !amount) {
          return new Response(
            JSON.stringify({ error: "Missing required fields" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const userData = await firebaseFetch(`users/${userId}`);
        if (!userData || (userData.balance || 0) < amount) {
          return new Response(
            JSON.stringify({ error: "Insufficient balance" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø¥Ø­Ø§Ù„Ø§Øª Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ ÙÙŠ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
        const config = await firebaseFetch("config");
        const minReferrals = config?.minimumWithdrawReferrals || 0;
        const userReferrals = userData.referrals || 0;
        
        if (minReferrals > 0 && userReferrals < minReferrals) {
          return new Response(
            JSON.stringify({ 
              error: `Need ${minReferrals} referrals to withdraw (you have ${userReferrals})` 
            }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ Ø§Ù„Ø³Ø­Ø¨
        const withdrawalId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        const withdrawalData = {
          id: withdrawalId,
          userId: userId,
          userName: `${userData.firstName || ''} ${userData.lastName || ''}`.trim(),
          username: userData.username || '',
          method: method,
          account: account,
          memo: memo,
          amount: amount,
          status: "pending",
          timestamp: Date.now(),
          currency: "TON"
        };
        
        // ØªØ®ÙÙŠØ¶ Ø§Ù„Ø±ØµÙŠØ¯
        await firebaseFetch(`users/${userId}`, "PATCH", {
          balance: (userData.balance || 0) - amount
        });
        
        // Ø­ÙØ¸ Ø·Ù„Ø¨ Ø§Ù„Ø³Ø­Ø¨
        await firebaseFetch(`withdrawals/pending/${withdrawalId}`, "PUT", withdrawalData);
        
        // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¥Ø¯Ø§Ø±Ø©
        const botToken = config?.botToken;
        const adminChatId = config?.adminChatId;
        
        if (botToken && adminChatId) {
          const notificationMessage = `
ğŸª™ NEW WITHDRAWAL REQUEST ğŸª™

ğŸ‘¤ User Information:
â€¢ Name: ${withdrawalData.userName}
â€¢ Username: @${withdrawalData.username || 'N/A'}
â€¢ User ID: ${userId}

ğŸ’ Withdrawal Details:
â€¢ Amount: ${Number(amount).toFixed(4)} TON
â€¢ Method: ${method}
â€¢ Account: ${account}
${memo ? `â€¢ Memo: ${memo}\n` : ''}
ğŸ“… Date: ${new Date().toLocaleString()}
ğŸ†” Request ID: ${withdrawalId}

âœ… Status: Pending Approval
          `.trim();
          
          try {
            await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                chat_id: adminChatId,
                text: notificationMessage
              })
            });
          } catch (error) {
            console.error("Failed to send Telegram notification:", error);
          }
        }
        
        result = {
          success: true,
          withdrawalId: withdrawalId,
          newBalance: (userData.balance || 0) - amount
        };
      }
      
      // ğŸ“œ Ø³Ø¬Ù„ Ø§Ù„Ø³Ø­Ø¨
      else if (action === "getWithdrawalHistory") {
        const userId = params.get("userId");
        
        if (!userId) {
          return new Response(
            JSON.stringify({ error: "User ID required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø³Ø­Ø¨ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const statuses = ["pending", "completed", "rejected"];
        let allWithdrawals = [];
        
        for (const status of statuses) {
          const withdrawals = await firebaseFetch(`withdrawals/${status}`);
          if (withdrawals) {
            Object.values(withdrawals).forEach(withdrawal => {
              if (withdrawal.userId === userId) {
                allWithdrawals.push({
                  ...withdrawal,
                  status: status
                });
              }
            });
          }
        }
        
        // ÙØ±Ø² Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ®
        allWithdrawals.sort((a, b) => b.timestamp - a.timestamp);
        
        result = allWithdrawals;
      }
      
      // ğŸ“‹ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
      else if (action === "getDailyTasks") {
        const userId = params.get("userId");
        
        if (!userId) {
          return new Response(
            JSON.stringify({ error: "User ID required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        const userData = await firebaseFetch(`users/${userId}`);
        const dailyTasksData = await firebaseFetch(`dailyTasks/${userId}`);
        const claimedTasks = dailyTasksData || {};
        
        const watchedToday = userData?.dailyAdCount || 0;
        
        // ØªØ¹Ø±ÙŠÙ Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
        const dailyTasks = [
          { id: 'daily_login', name: 'Daily Login', required: 0, current: 1, reward: 5000 },
          { id: 'watch_50_ads', name: 'Watch 50 Ads Today', required: 50, current: watchedToday, reward: 10000 },
          { id: 'watch_100_ads', name: 'Watch 100 Ads Today', required: 100, current: watchedToday, reward: 20000 },
          { id: 'watch_500_ads', name: 'Watch 500 Ads Today', required: 500, current: watchedToday, reward: 50000 },
          { id: 'watch_1000_ads', name: 'Watch 1000 Ads Today', required: 1000, current: watchedToday, reward: 100000 }
        ];
        
        result = dailyTasks.map(task => ({
          ...task,
          claimed: claimedTasks[task.id] || false,
          completed: task.current >= task.required
        }));
      }
      
      // ğŸ Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø© Ø¨Ù…Ù‡Ù…Ø© ÙŠÙˆÙ…ÙŠØ©
      else if (action === "claimDailyTask") {
        const reqData = await request.json();
        const userId = reqData.userId;
        const taskId = reqData.taskId;
        
        if (!userId || !taskId) {
          return new Response(
            JSON.stringify({ error: "User ID and task ID required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ØªÙ… Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹
        const dailyTasksData = await firebaseFetch(`dailyTasks/${userId}`);
        const claimedTasks = dailyTasksData || {};
        
        if (claimedTasks[taskId]) {
          return new Response(
            JSON.stringify({ error: "Task already claimed" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ§Ù„Ù…Ù‡Ø§Ù…
        const userData = await firebaseFetch(`users/${userId}`);
        const watchedToday = userData?.dailyAdCount || 0;
        
        // ØªØ¹Ø±ÙŠÙ Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
        const dailyTasks = {
          'daily_login': { reward: 5000 },
          'watch_50_ads': { reward: 10000, required: 50 },
          'watch_100_ads': { reward: 20000, required: 100 },
          'watch_500_ads': { reward: 50000, required: 500 },
          'watch_1000_ads': { reward: 100000, required: 1000 }
        };
        
        const task = dailyTasks[taskId];
        if (!task) {
          return new Response(
            JSON.stringify({ error: "Invalid task ID" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ù‡Ù…Ø© (Ø¨Ø§Ø³ØªØ«Ù†Ø§Ø¡ daily_login)
        if (taskId !== 'daily_login') {
          if (watchedToday < task.required) {
            return new Response(
              JSON.stringify({ 
                error: `Task not completed. Required: ${task.required} ads, Watched: ${watchedToday}` 
              }),
              { status: 400, headers: corsHeaders }
            );
          }
        }
        
        // Ù…Ù†Ø­ Ø§Ù„Ù…ÙƒØ§ÙØ£Ø©
        const reward = task.reward;
        await firebaseFetch(`users/${userId}`, "PATCH", {
          rrBalance: (userData?.rrBalance || 0) + reward
        });
        
        // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ù‡Ù…Ø©
        claimedTasks[taskId] = {
          claimedAt: Date.now(),
          reward: reward
        };
        await firebaseFetch(`dailyTasks/${userId}`, "PUT", claimedTasks);
        
        result = {
          success: true,
          reward: reward,
          newRRBalance: (userData?.rrBalance || 0) + reward
        };
      }
      
      // ğŸ“Š Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
      else if (action === "getUserStats") {
        const userId = params.get("userId");
        
        if (!userId) {
          return new Response(
            JSON.stringify({ error: "User ID required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        const userData = await firebaseFetch(`users/${userId}`);
        const referralData = await firebaseFetch(`referrals/${userId}`);
        const contestData = await firebaseFetch(`contest/participants/${userId}`);
        
        result = {
          balance: userData?.balance || 0,
          rrBalance: userData?.rrBalance || 0,
          totalEarned: userData?.totalEarned || 0,
          referrals: userData?.referrals || 0,
          dailyAdCount: userData?.dailyAdCount || 0,
          lifetimeAdCount: userData?.lifetimeAdCount || 0,
          referralEarnings: referralData?.totalEarnings || 0,
          pendingReferralEarnings: referralData?.pendingEarnings || 0,
          contestPoints: contestData?.points || 0,
          joinDate: userData?.joinDate,
          lastActive: userData?.lastActive
        };
      }
      
      // ğŸ”„ ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
      else if (action === "updateUser") {
        const reqData = await request.json();
        const userId = reqData.userId;
        const updates = reqData.updates;
        
        if (!userId || !updates) {
          return new Response(
            JSON.stringify({ error: "User ID and updates required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        await firebaseFetch(`users/${userId}`, "PATCH", updates);
        
        result = { success: true };
      }
      
      // ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù‚Ù†ÙˆØ§Øª
      else if (action === "checkChannelSubscription") {
        const reqData = await request.json();
        const userId = reqData.userId;
        const channelUsername = reqData.channelUsername;
        
        if (!userId || !channelUsername) {
          return new Response(
            JSON.stringify({ error: "User ID and channel username required" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        // Ø¬Ù„Ø¨ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
        const config = await firebaseFetch("config");
        const botToken = config?.botToken;
        
        if (!botToken) {
          return new Response(
            JSON.stringify({ error: "Bot token not configured" }),
            { status: 400, headers: corsHeaders }
          );
        }
        
        try {
          // Ø§Ø³ØªØ®Ø¯Ø§Ù… Telegram Bot API Ù„Ù„ØªØ­Ù‚Ù‚
          const response = await fetch(`https://api.telegram.org/bot${botToken}/getChatMember`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              chat_id: '@' + channelUsername,
              user_id: parseInt(userId)
            })
          });
          
          const data = await response.json();
          
          if (data.ok) {
            const status = data.result.status;
            const isSubscribed = ['member', 'administrator', 'creator'].includes(status);
            result = {
              subscribed: isSubscribed,
              status: status
            };
          } else {
            result = {
              subscribed: false,
              error: data.description
            };
          }
        } catch (error) {
          result = {
            subscribed: false,
            error: error.message
          };
        }
      }
      
      // âŒ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ
      else {
        return new Response(
          JSON.stringify({ error: "Unknown action" }),
          { status: 400, headers: corsHeaders }
        );
      }
      
      return new Response(JSON.stringify(result), {
        headers: { 
          "Content-Type": "application/json",
          ...corsHeaders 
        }
      });
      
    } catch (error) {
      console.error("Worker error:", error);
      
      return new Response(
        JSON.stringify({ 
          error: error.message,
          stack: error.stack 
        }),
        { 
          status: 500,
          headers: { 
            "Content-Type": "application/json",
            ...corsHeaders 
          }
        }
      );
    }
  },
};
