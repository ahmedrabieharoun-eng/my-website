// ============================================
// FARM ECONOMY WORKER v5.0 - WITH TASKS SYSTEM
// FIXED: Auto-add referral earnings, Hatch 5000, Notifications, Withdraw 0.1, Market Fee 10%
// ADDED: Tasks System with Partner & Community tasks, Channel verification, Bot tasks
// UPDATED: Diamond price 25 TON, Task reward 0.001 TON fixed
// ============================================

export default {
    async fetch(request, env, ctx) {
        // ===== CORS HANDLING =====
        if (request.method === 'OPTIONS') {
            return new Response(null, {
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Action, X-CSRF-Token',
                    'Access-Control-Max-Age': '86400',
                }
            });
        }
        
        const url = new URL(request.url);
        const path = url.pathname;
        
        // ===== TON CONNECT MANIFEST =====
        if (path === '/tonconnect-manifest.json') {
            return new Response(JSON.stringify({
                url: "Crystal_Ranch_bot",
                name: "Crystal_Ranch_bot",
                iconUrl: "https://i.ibb.co/cfMm2bV/photo-5805343424280988997-c.jpg",
                description: "Crystal Ranch Game"
            }), {
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
        }
        
        // ===== HEALTH CHECK =====
        if (path === '/health') {
            return new Response(JSON.stringify({
                status: 'ok',
                timestamp: Date.now(),
                environment: env.ENVIRONMENT || 'production'
            }), {
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
        }
        
        // ===== MAIN API ENDPOINT =====
        if (path === '/api') {
            try {
                // === SECURITY ENHANCEMENTS ===
                const clientIp = request.headers.get('CF-Connecting-IP') || 'unknown';
                const rateLimitKey = `ratelimit:${clientIp}`;
                
                const requestCount = await checkRateLimit(env, rateLimitKey);
                if (requestCount > 60) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Rate limit exceeded. Too many requests.',
                        errorCode: 'RATE_LIMIT_EXCEEDED'
                    }), {
                        status: 429,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const csrfToken = request.headers.get('X-CSRF-Token');
                const method = request.method;
                
                if (method === 'POST' && !isValidCsrfToken(csrfToken, env)) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Invalid CSRF token',
                        errorCode: 'CSRF_INVALID'
                    }), {
                        status: 403,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const rawBody = await request.text();
                const sanitizedBody = sanitizeInput(rawBody);
                const requestData = JSON.parse(sanitizedBody);
                
                const authHeader = request.headers.get('Authorization');
                
                if (!authHeader || !authHeader.startsWith('Telegram ')) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Telegram authentication required',
                        errorCode: 'AUTH_REQUIRED',
                        details: 'Missing Telegram authorization header'
                    }), {
                        status: 401,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const initData = authHeader.replace('Telegram ', '');
                
                const isDevelopment = env.ENVIRONMENT === 'development' || !env.BOT_TOKEN;
                let validationResult;
                
                if (isDevelopment) {
                    validationResult = await validateTelegramInitDataDev(initData, env.BOT_TOKEN);
                    console.log('Development mode: using simplified validation');
                } else {
                    validationResult = await validateTelegramInitData(initData, env.BOT_TOKEN);
                }
                
                if (!validationResult.valid) {
                    console.error('Telegram validation failed:', validationResult.error);
                    
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Invalid Telegram authentication',
                        errorCode: 'INVALID_TELEGRAM_AUTH',
                        details: validationResult.error,
                        debug: {
                            hasInitData: !!initData,
                            initDataLength: initData?.length,
                            botTokenConfigured: !!env.BOT_TOKEN,
                            environment: env.ENVIRONMENT || 'production'
                        }
                    }), {
                        status: 401,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const params = new URLSearchParams(initData);
                const userParam = params.get('user');
                
                if (!userParam) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'User data not found in Telegram init data',
                        errorCode: 'USER_DATA_MISSING'
                    }), {
                        status: 401,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                let userData;
                try {
                    userData = JSON.parse(decodeURIComponent(userParam));
                } catch (e) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Invalid user data format',
                        errorCode: 'INVALID_USER_DATA'
                    }), {
                        status: 401,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const userId = String(userData.id);
                const authDate = params.get('auth_date');
                
                console.log(`[${new Date().toISOString()}] ‚úÖ Valid Telegram auth - User: ${userId}, Auth Date: ${authDate || 'unknown'}, Env: ${env.ENVIRONMENT || 'production'}`);
                
                const action = request.headers.get('X-Action') || requestData.action;
                const data = requestData.data || {};
                
                console.log(`[${new Date().toISOString()}] Action: ${action}, User: ${userId}`);
                
                let result;
                
                switch (action) {
                    case 'getState':
                        result = await handleGetState(env, userId);
                        break;
                    
                    case 'buyCow':
                        result = await handleBuyCow(env, userId, data);
                        break;
                    case 'buyChicken':
                        result = await handleBuyChicken(env, userId, data);
                        break;
                    case 'buyDiamondEngine':
                        result = await handleBuyDiamondEngine(env, userId, data);
                        break;
                    
                    case 'hatchCow':
                        result = await handleHatchCow(env, userId, data);
                        break;
                    case 'hatchChicken':
                        result = await handleHatchChicken(env, userId, data);
                        break;
                    
                    case 'startDiamondProduction':
                        result = await handleStartDiamondProduction(env, userId, data);
                        break;
                    
                    case 'convertDiamond':
                        result = await handleConvertDiamond(env, userId, data);
                        break;
                    
                    case 'createSellOrder':
                        result = await handleCreateSellOrder(env, userId, data);
                        break;
                    case 'createBuyOrder':
                        result = await handleCreateBuyOrder(env, userId, data);
                        break;
                    case 'executeOrder':
                        result = await handleExecuteOrder(env, userId, data);
                        break;
                    case 'getMarketOrders':
                        result = await handleGetMarketOrders(env, data);
                        break;
                    case 'getMyOrders':
                        result = await handleGetMyOrders(env, userId);
                        break;
                    case 'cancelOrder':
                        result = await handleCancelOrder(env, userId, data);
                        break;
                    
                    case 'deposit':
                        result = await handleDeposit(env, userId, data);
                        break;
                    case 'verifyDeposit':
                        result = await handleVerifyDeposit(env, userId, data);
                        break;
                    
                    case 'withdraw':
                        result = await handleWithdraw(env, userId, data);
                        break;
                    
                    case 'claimReferralEarnings':
                        result = await handleClaimReferralEarnings(env, userId);
                        break;
                    case 'getReferralInfo':
                        result = await handleGetReferralInfo(env, userId);
                        break;
                    
                    case 'initializeUser':
                        result = await handleInitializeUser(env, userId, data);
                        break;
                    
                    case 'setLanguage':
                        result = await handleSetLanguage(env, userId, data);
                        break;
                    
                    // New Task Actions
                    case 'createTask':
                        result = await handleCreateTask(env, userId, data);
                        break;
                    case 'verifyTask':
                        result = await handleVerifyTask(env, userId, data);
                        break;
                    case 'getTasks':
                        result = await handleGetTasks(env, userId);
                        break;
                    
                    default:
                        result = {
                            success: false,
                            error: 'Unknown action',
                            errorCode: 'UNKNOWN_ACTION'
                        };
                }
                
                return new Response(JSON.stringify(result), {
                    headers: {
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
                
            } catch (error) {
                console.error(`Worker Error: ${error.message}`, error.stack);
                
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Internal server error',
                    errorCode: 'INTERNAL_SERVER_ERROR',
                    message: error.message
                }), {
                    status: 500,
                    headers: { 
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
            }
        }
        
        return new Response(JSON.stringify({
            success: false,
            error: 'Endpoint not found'
        }), {
            status: 404,
            headers: { 'Content-Type': 'application/json' }
        });
    }
};

// ============================================
// SECURITY FUNCTIONS
// ============================================

async function checkRateLimit(env, key) {
    return 0;
}

function isValidCsrfToken(token, env) {
    if (!env.CSRF_SECRET) return true;
    if (!token) return false;
    const expected = generateCsrfToken(env);
    return token === expected;
}

function generateCsrfToken(env) {
    return 'fixed-csrf-token-for-demo';
}

function sanitizeInput(input) {
    if (!input) return input;
    let sanitized = input.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
    sanitized = sanitized.replace(/[<>]/g, function(match) {
        return match === '<' ? '&lt;' : '&gt;';
    });
    return sanitized;
}

// ============================================
// GAME CONSTANTS - MODIFIED
// ============================================

const GAME_CONSTANTS = {
    COW_PRICE: 1,
    COW_GLOBAL_CAP: 1000,
    COW_PRODUCTION_RATE: 41,
    COW_HATCH_COST: 5000,
    
    CHICKEN_PRICE: 1,
    CHICKEN_GLOBAL_CAP: 1000,
    CHICKEN_PRODUCTION_RATE: 41,
    CHICKEN_HATCH_COST: 5000,
    
    DIAMOND_ENGINE_PRICE: 20,
    DIAMOND_PRODUCTION_COST_MILK: 20000,
    DIAMOND_PRODUCTION_COST_EGG: 20000,
    DIAMOND_PRODUCTION_YIELD: 1,
    DIAMOND_BASE_PRICE: 25,
    
    MIN_ORDER_AMOUNT: 100,
    MAX_ACTIVE_ORDERS: 50,
    MARKET_FEE_PERCENT: 10,
    
    MIN_WITHDRAW_AMOUNT: 0.1,
    WITHDRAW_FEE_PERCENT: 5,
    
    MIN_DEPOSIT_AMOUNT: 0.1,
    
    REFERRAL_REWARD_PERCENT: 10,
    
    HOUR_IN_MS: 3600000,
    
    // Task System Constants
    TASK_REWARD: 0.001,
    MIN_TASK_TARGET: 1000,
    MAX_TASK_DURATION_DAYS: 30
};

// ============================================
// TELEGRAM VALIDATION
// ============================================

async function validateTelegramInitData(initData, botToken) {
    try {
        if (!initData || !botToken) {
            return {
                valid: false,
                error: !initData ? 'No init data provided' : 'Bot token not configured'
            };
        }

        const params = new URLSearchParams(initData);
        const hash = params.get('hash');
        
        if (!hash) {
            return {
                valid: false,
                error: 'No hash parameter in init data'
            };
        }

        params.delete('hash');
        
        const sortedKeys = Array.from(params.keys()).sort();
        let dataCheckArray = [];
        
        for (const key of sortedKeys) {
            dataCheckArray.push(`${key}=${params.get(key)}`);
        }
        
        const dataCheckString = dataCheckArray.join('\n');
        
        const encoder = new TextEncoder();
        
        const secretKeyMaterial = await crypto.subtle.importKey(
            'raw',
            encoder.encode('WebAppData'),
            { name: 'HMAC', hash: 'SHA-256' },
            false,
            ['sign']
        );
        
        const secretKey = await crypto.subtle.sign(
            'HMAC',
            secretKeyMaterial,
            encoder.encode(botToken)
        );
        
        const hmacKey = await crypto.subtle.importKey(
            'raw',
            secretKey,
            { name: 'HMAC', hash: 'SHA-256' },
            false,
            ['sign']
        );
        
        const signature = await crypto.subtle.sign(
            'HMAC',
            hmacKey,
            encoder.encode(dataCheckString)
        );
        
        const hashHex = Array.from(new Uint8Array(signature))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
        
        const isValid = hashHex.toLowerCase() === hash.toLowerCase();
        
        const authDate = params.get('auth_date');
        if (authDate) {
            const authTimestamp = parseInt(authDate) * 1000;
            const now = Date.now();
            const oneDayMs = 24 * 60 * 60 * 1000;
            
            if (now - authTimestamp > oneDayMs) {
                console.warn('Telegram auth data is older than 24 hours');
            }
        }
        
        if (!isValid) {
            console.error('Hash validation failed');
            console.error('Expected:', hashHex);
            console.error('Received:', hash);
            console.error('Data string:', dataCheckString);
            
            return {
                valid: false,
                error: 'Hash validation failed - data tampered'
            };
        }
        
        return {
            valid: true,
            hash: hashHex,
            authDate: params.get('auth_date')
        };
        
    } catch (error) {
        console.error('Telegram validation error:', error);
        return {
            valid: false,
            error: `Validation error: ${error.message}`
        };
    }
}

async function validateTelegramInitDataDev(initData, botToken) {
    try {
        if (!initData) {
            return { valid: false, error: 'No init data' };
        }
        
        const params = new URLSearchParams(initData);
        const userParam = params.get('user');
        const hash = params.get('hash');
        
        if (!userParam) {
            return { valid: false, error: 'No user data' };
        }
        
        try {
            JSON.parse(decodeURIComponent(userParam));
        } catch (e) {
            return { valid: false, error: 'Invalid user data format' };
        }
        
        return { 
            valid: true, 
            hash: hash || 'dev-mode',
            devMode: true 
        };
        
    } catch (error) {
        return { valid: false, error: error.message };
    }
}

// ============================================
// TELEGRAM CHANNEL VERIFICATION
// ============================================

async function checkTelegramMembership(env, userId, channelUsername) {
    try {
        if (!env.BOT_TOKEN) {
            console.log('No bot token, skipping channel verification');
            return true; // Skip verification in dev mode
        }
        
        // Extract channel username from link
        let username = channelUsername;
        if (channelUsername.includes('t.me/')) {
            username = channelUsername.split('t.me/')[1].split('?')[0].split('/')[0];
        }
        if (username.startsWith('@')) {
            username = username.substring(1);
        }
        
        const url = `https://api.telegram.org/bot${env.BOT_TOKEN}/getChatMember`;
        
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: `@${username}`,
                user_id: parseInt(userId)
            })
        });
        
        const result = await response.json();
        
        if (!result.ok) {
            console.error('Telegram API error:', result);
            return false;
        }
        
        const status = result.result?.status;
        const isMember = ['member', 'administrator', 'creator'].includes(status);
        
        return isMember;
        
    } catch (error) {
        console.error('Channel verification error:', error);
        return false;
    }
}

// ============================================
// DATABASE OPERATIONS - FIREBASE REST API
// ============================================

async function getFirebaseUrl(env, path) {
    const baseUrl = env.FIREBASE_DATABASE_URL?.replace(/\/$/, '');
    if (!baseUrl) {
        throw new Error('FIREBASE_DATABASE_URL is not configured');
    }
    
    const cleanPath = path.replace(/^\//, '');
    const apiKey = env.FIREBASE_API_KEY;
    
    if (!apiKey) {
        throw new Error('FIREBASE_API_KEY is not configured');
    }
    
    return `${baseUrl}/${cleanPath}.json?key=${apiKey}`;
}

async function dbGet(env, path) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase GET error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        const data = await response.json();
        
        return {
            success: true,
            data: data
        };
    } catch (error) {
        console.error(`DB GET Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_GET_ERROR'
        };
    }
}

async function dbSet(env, path, data) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase SET error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error(`DB SET Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_SET_ERROR'
        };
    }
}

async function dbUpdate(env, path, updates) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updates)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase UPDATE error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error(`DB UPDATE Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_UPDATE_ERROR'
        };
    }
}

async function dbPush(env, path, data) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase PUSH error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: { id: result.name }
        };
    } catch (error) {
        console.error(`DB PUSH Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_PUSH_ERROR'
        };
    }
}

async function dbDelete(env, path) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url, {
            method: 'DELETE'
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase DELETE error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        return {
            success: true
        };
    } catch (error) {
        console.error(`DB DELETE Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_DELETE_ERROR'
        };
    }
}

// ============================================
// NOTIFICATION FUNCTIONS - TELEGRAM BOT
// ============================================

async function sendTelegramNotification(env, userId, message) {
    try {
        if (!env.BOT_TOKEN) {
            console.log('No bot token configured, skipping notification');
            return false;
        }
        
        const url = `https://api.telegram.org/bot${env.BOT_TOKEN}/sendMessage`;
        
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: userId,
                text: message,
                parse_mode: 'HTML'
            })
        });
        
        const result = await response.json();
        return result.ok;
    } catch (error) {
        console.error('Failed to send notification:', error);
        return false;
    }
}

async function notifyOrderFilled(env, userId, order, quantity, totalTon, fee = 0) {
    const resourceEmoji = order.resource === 'milk' ? 'ü•õ' : 'ü•ö';
    const resourceName = order.resource === 'milk' ? 'MILK' : 'EGG';
    const netAmount = order.type === 'sell' ? totalTon - fee : totalTon;
    
    let message = '';
    
    if (order.type === 'sell') {
        message = `üéâ <b>Order Sold!</b>\n\nYour sell order for ${formatNumber(quantity)} ${resourceEmoji} ${resourceName} has been filled!\n\nüí∞ You received: ${formatTON(netAmount)} TON`;
        if (fee > 0) {
            message += `\nüìâ Fee (10%): ${formatTON(fee)} TON`;
        }
        message += `\nüì¶ Order ID: #${order.id.substring(0, 6)}`;
    } else {
        message = `üéâ <b>Order Filled!</b>\n\nYour buy order for ${formatNumber(quantity)} ${resourceEmoji} ${resourceName} has been filled!\n\nüì¶ Order ID: #${order.id.substring(0, 6)}`;
    }
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyMachinePurchase(env, userId, machineType) {
    const machineEmoji = machineType === 'cow' ? 'üêÆ' : machineType === 'chicken' ? 'üêî' : 'üíé';
    const machineName = machineType === 'cow' ? 'Cow' : machineType === 'chicken' ? 'Chicken' : 'Crystal Engine';
    
    const message = `üéâ <b>Purchase Successful!</b>\n\nYou just bought a ${machineName} Machine ${machineEmoji}!\n\nStart producing resources now! üöÄ`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyReferralReward(env, userId, amount, referrerName) {
    const message = `üéÅ <b>Referral Reward!</b>\n\nYour referral ${referrerName || 'friend'} just purchased a machine!\n\nüíé You received: ${formatTON(amount)} TON\n\nKeep sharing your link to earn more! üöÄ`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyDepositSuccess(env, userId, amount) {
    const message = `üí∞ <b>Deposit Successful!</b>\n\nYour deposit of ${formatTON(amount)} TON has been confirmed and added to your balance.\n\nHappy farming! üöú`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyTaskCompleted(env, userId, taskType, reward) {
    const message = `‚úÖ <b>Task Completed!</b>\n\nYou have successfully completed the ${taskType === 'channel' ? 'üì¢ Channel' : 'ü§ñ Bot'} task!\n\nüí∞ Reward: ${formatTON(reward)} TON added to your balance.\n\nKeep completing tasks to earn more! üöÄ`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyTaskCreated(env, userId, taskType, targetUsers, totalCost) {
    const message = `üì¢ <b>Task Created!</b>\n\nYour ${taskType === 'channel' ? 'üì¢ Channel' : 'ü§ñ Bot'} task has been created successfully!\n\nüë• Target: ${targetUsers} users\nüí∞ Total Cost: ${formatTON(totalCost)} TON\n\nIt will appear in Community Tasks section. üöÄ`;
    
    await sendTelegramNotification(env, userId, message);
}

function formatNumber(num) {
    if (num === null || num === undefined) return '0';
    if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num.toString();
}

function formatTON(amount) {
    if (amount === null || amount === undefined) return '0.0000';
    return parseFloat(amount).toFixed(4);
}

// ============================================
// INITIALIZATION FUNCTIONS
// ============================================

async function initializeGlobalState(env) {
    const now = Date.now();
    
    const initialState = {
        cows_sold: 0,
        chickens_sold: 0,
        diamond_price: GAME_CONSTANTS.DIAMOND_BASE_PRICE,
        createdAt: now,
        updatedAt: now
    };
    
    await dbSet(env, 'global', initialState);
    return initialState;
}

function generateReferralCode(userId) {
    return `ref_${userId}`;
}

function extractReferrerFromStartParam(startParam) {
    if (!startParam) return null;
    
    if (startParam.startsWith('ref_')) {
        const referrerId = startParam.replace('ref_', '');
        if (!isNaN(parseInt(referrerId))) {
            return referrerId;
        }
    }
    return null;
}

async function initializeUser(env, userId, userInfo = {}, startParam = null) {
    const now = Date.now();
    
    const referredBy = extractReferrerFromStartParam(startParam);
    const referralCode = generateReferralCode(userId);
    
    const userData = {
        tonBalance: 0,
        milk: 0,
        eggs: 0,
        diamond: 0,
        
        cows_owned: 0,
        chickens_owned: 0,
        diamond_engines_owned: 0,
        
        lastProduction: now,
        
        referralCode: referralCode,
        referredBy: referredBy,
        referralEarnings: 0,
        referralEarningsClaimed: 0,
        
        firstName: userInfo.first_name || '',
        lastName: userInfo.last_name || '',
        username: userInfo.username || '',
        photoUrl: userInfo.photo_url || '',
        
        language: 'en',
        
        completedTasks: [], // Array of task IDs completed by user
        
        createdAt: now,
        updatedAt: now
    };
    
    await dbSet(env, `users/${userId}`, userData);
    
    if (referredBy) {
        await recordReferral(env, referredBy, userId, userData);
    }
    
    return userData;
}

async function recordReferral(env, referrerId, newUserId, newUserData) {
    const now = Date.now();
    
    const referralRecord = {
        userId: newUserId,
        firstName: newUserData.firstName || 'Farmer',
        lastName: newUserData.lastName || '',
        username: newUserData.username || '',
        photoUrl: newUserData.photoUrl || '',
        joinedAt: now,
        totalEarnedFromThisUser: 0,
        lastPurchase: null
    };
    
    await dbSet(env, `users/${referrerId}/referrals/${newUserId}`, referralRecord);
    
    await sendTelegramNotification(
        env,
        referrerId,
        `üéâ <b>New Referral!</b>\n\n${newUserData.firstName || 'A new farmer'} just joined using your link!\n\nYou'll earn 10% commission on their purchases. üöÄ`
    );
}

async function updateReferralEarnings(env, referrerId, referredUserId, purchaseAmount, purchaseType) {
    const now = Date.now();
    
    const commission = purchaseAmount * (GAME_CONSTANTS.REFERRAL_REWARD_PERCENT / 100);
    
    const referrerResult = await dbGet(env, `users/${referrerId}`);
    if (!referrerResult.success || !referrerResult.data) {
        console.error('Referrer not found:', referrerId);
        return null;
    }
    
    const referrer = referrerResult.data;
    
    const currentEarnings = parseFloat(referrer.referralEarnings || 0);
    const newEarnings = currentEarnings + commission;
    
    await dbUpdate(env, `users/${referrerId}`, {
        referralEarnings: newEarnings,
        tonBalance: (parseFloat(referrer.tonBalance || 0) + commission),
        updatedAt: now
    });
    
    const referredUserResult = await dbGet(env, `users/${referredUserId}`);
    let referredUserInfo = {};
    if (referredUserResult.success && referredUserResult.data) {
        referredUserInfo = referredUserResult.data;
    }
    
    const referralRecordResult = await dbGet(env, `users/${referrerId}/referrals/${referredUserId}`);
    if (referralRecordResult.success && referralRecordResult.data) {
        const currentTotal = parseFloat(referralRecordResult.data.totalEarnedFromThisUser || 0);
        
        await dbUpdate(env, `users/${referrerId}/referrals/${referredUserId}`, {
            totalEarnedFromThisUser: currentTotal + commission,
            lastPurchase: {
                amount: purchaseAmount,
                commission: commission,
                type: purchaseType,
                timestamp: now
            },
            firstName: referredUserInfo.firstName || referralRecordResult.data.firstName,
            lastName: referredUserInfo.lastName || '',
            username: referredUserInfo.username || '',
            photoUrl: referredUserInfo.photoUrl || ''
        });
    }
    
    await dbPush(env, `users/${referrerId}/referralEarnings`, {
        userId: referredUserId,
        amount: commission,
        type: purchaseType,
        purchaseAmount: purchaseAmount,
        timestamp: now,
        firstName: referredUserInfo.firstName || 'Farmer',
        username: referredUserInfo.username || ''
    });
    
    const buyerName = referredUserInfo.firstName || referredUserInfo.username || 'Your referral';
    await notifyReferralReward(env, referrerId, commission, buyerName);
    
    return commission;
}

// ============================================
// MACHINE PURCHASES WITH UPDATED REFERRAL SYSTEM
// ============================================

async function handleBuyCow(env, userId, data) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        const globalResult = await dbGet(env, 'global');
        
        if (!userResult.success || !globalResult.success) {
            return {
                success: false,
                error: 'Failed to load game state',
                errorCode: 'STATE_LOAD_ERROR'
            };
        }
        
        let user = userResult.data;
        let global = globalResult.data;
        
        if (!global) {
            global = await initializeGlobalState(env);
        }
        
        if (!user) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        if (global.cows_sold >= GAME_CONSTANTS.COW_GLOBAL_CAP) {
            return {
                success: false,
                error: 'All Cow machines are sold out',
                errorCode: 'COW_SOLD_OUT'
            };
        }
        
        if (user.cows_owned > 0) {
            return {
                success: false,
                error: 'You can only own one Cow machine',
                errorCode: 'COW_ALREADY_OWNED'
            };
        }
        
        if ((user.tonBalance || 0) < GAME_CONSTANTS.COW_PRICE) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        const userUpdates = {
            cows_owned: 1,
            tonBalance: (user.tonBalance || 0) - GAME_CONSTANTS.COW_PRICE,
            updatedAt: Date.now()
        };
        
        const globalUpdates = {
            cows_sold: (global.cows_sold || 0) + 1,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        await dbUpdate(env, 'global', globalUpdates);
        
        let referralCommission = 0;
        
        if (user.referredBy) {
            referralCommission = await updateReferralEarnings(
                env, 
                user.referredBy, 
                userId, 
                GAME_CONSTANTS.COW_PRICE, 
                'cow_purchase'
            );
        }
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'buy_cow',
            amount: GAME_CONSTANTS.COW_PRICE,
            payment: 'TON',
            timestamp: Date.now()
        });
        
        await notifyMachinePurchase(env, userId, 'cow');
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                cows_owned: 1,
                newTonBalance: updatedUser.tonBalance,
                cows_sold: globalUpdates.cows_sold,
                cows_remaining: GAME_CONSTANTS.COW_GLOBAL_CAP - globalUpdates.cows_sold,
                referralCommission: referralCommission || 0
            }
        };
        
    } catch (error) {
        console.error('Buy cow error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'BUY_COW_ERROR'
        };
    }
}

async function handleBuyChicken(env, userId, data) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        const globalResult = await dbGet(env, 'global');
        
        if (!userResult.success || !globalResult.success) {
            return {
                success: false,
                error: 'Failed to load game state',
                errorCode: 'STATE_LOAD_ERROR'
            };
        }
        
        let user = userResult.data;
        let global = globalResult.data;
        
        if (!global) {
            global = await initializeGlobalState(env);
        }
        
        if (!user) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        if (global.cows_sold < GAME_CONSTANTS.COW_GLOBAL_CAP) {
            return {
                success: false,
                error: 'Chicken machine is locked until all Cow machines are sold',
                errorCode: 'CHICKEN_LOCKED'
            };
        }
        
        if (global.chickens_sold >= GAME_CONSTANTS.CHICKEN_GLOBAL_CAP) {
            return {
                success: false,
                error: 'All Chicken machines are sold out',
                errorCode: 'CHICKEN_SOLD_OUT'
            };
        }
        
        if (user.chickens_owned > 0) {
            return {
                success: false,
                error: 'You can only own one Chicken machine',
                errorCode: 'CHICKEN_ALREADY_OWNED'
            };
        }
        
        if ((user.tonBalance || 0) < GAME_CONSTANTS.CHICKEN_PRICE) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        const userUpdates = {
            chickens_owned: 1,
            tonBalance: (user.tonBalance || 0) - GAME_CONSTANTS.CHICKEN_PRICE,
            updatedAt: Date.now()
        };
        
        const globalUpdates = {
            chickens_sold: (global.chickens_sold || 0) + 1,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        await dbUpdate(env, 'global', globalUpdates);
        
        let referralCommission = 0;
        
        if (user.referredBy) {
            referralCommission = await updateReferralEarnings(
                env, 
                user.referredBy, 
                userId, 
                GAME_CONSTANTS.CHICKEN_PRICE, 
                'chicken_purchase'
            );
        }
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'buy_chicken',
            amount: GAME_CONSTANTS.CHICKEN_PRICE,
            payment: 'TON',
            timestamp: Date.now()
        });
        
        await notifyMachinePurchase(env, userId, 'chicken');
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                chickens_owned: 1,
                newTonBalance: updatedUser.tonBalance,
                chickens_sold: globalUpdates.chickens_sold,
                chickens_remaining: GAME_CONSTANTS.CHICKEN_GLOBAL_CAP - globalUpdates.chickens_sold,
                referralCommission: referralCommission || 0
            }
        };
        
    } catch (error) {
        console.error('Buy chicken error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'BUY_CHICKEN_ERROR'
        };
    }
}

async function handleBuyDiamondEngine(env, userId, data) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        const globalResult = await dbGet(env, 'global');
        
        if (!userResult.success || !globalResult.success) {
            return {
                success: false,
                error: 'Failed to load game state',
                errorCode: 'STATE_LOAD_ERROR'
            };
        }
        
        let user = userResult.data;
        let global = globalResult.data;
        
        if (!global) {
            global = await initializeGlobalState(env);
        }
        
        if (!user) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        if (global.cows_sold < GAME_CONSTANTS.COW_GLOBAL_CAP || 
            global.chickens_sold < GAME_CONSTANTS.CHICKEN_GLOBAL_CAP) {
            return {
                success: false,
                error: 'Diamond Engine is locked until all Cow and Chicken machines are sold',
                errorCode: 'DIAMOND_LOCKED'
            };
        }
        
        if (user.diamond_engines_owned > 0) {
            return {
                success: false,
                error: 'You can only own one Diamond Engine',
                errorCode: 'DIAMOND_ALREADY_OWNED'
            };
        }
        
        if ((user.tonBalance || 0) < GAME_CONSTANTS.DIAMOND_ENGINE_PRICE) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        const userUpdates = {
            diamond_engines_owned: 1,
            tonBalance: (user.tonBalance || 0) - GAME_CONSTANTS.DIAMOND_ENGINE_PRICE,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        let referralCommission = 0;
        
        if (user.referredBy) {
            referralCommission = await updateReferralEarnings(
                env, 
                user.referredBy, 
                userId, 
                GAME_CONSTANTS.DIAMOND_ENGINE_PRICE, 
                'diamond_engine_purchase'
            );
        }
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'buy_diamond_engine',
            amount: GAME_CONSTANTS.DIAMOND_ENGINE_PRICE,
            payment: 'TON',
            timestamp: Date.now()
        });
        
        await notifyMachinePurchase(env, userId, 'diamond');
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                diamond_engines_owned: 1,
                newTonBalance: updatedUser.tonBalance,
                referralCommission: referralCommission || 0
            }
        };
        
    } catch (error) {
        console.error('Buy diamond engine error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'BUY_DIAMOND_ENGINE_ERROR'
        };
    }
}

// ============================================
// PRODUCTION CALCULATION - LIFETIME ACCRUAL
// ============================================

async function calculateProduction(env, userId, user = null) {
    try {
        if (!user) {
            const userResult = await dbGet(env, `users/${userId}`);
            
            if (!userResult.success || !userResult.data) {
                return null;
            }
            
            user = userResult.data;
        }
        
        const now = Date.now();
        const lastProduction = user.lastProduction || now;
        
        const msPassed = now - lastProduction;
        const hoursPassed = Math.floor(msPassed / GAME_CONSTANTS.HOUR_IN_MS);
        
        if (hoursPassed <= 0) {
            return {
                user: user,
                hoursPassed: 0,
                milkProduced: 0,
                eggsProduced: 0
            };
        }
        
        const milkProduced = (user.cows_owned || 0) * GAME_CONSTANTS.COW_PRODUCTION_RATE * hoursPassed;
        const eggsProduced = (user.chickens_owned || 0) * GAME_CONSTANTS.CHICKEN_PRODUCTION_RATE * hoursPassed;
        
        const updates = {
            milk: (user.milk || 0) + milkProduced,
            eggs: (user.eggs || 0) + eggsProduced,
            lastProduction: lastProduction + (hoursPassed * GAME_CONSTANTS.HOUR_IN_MS),
            updatedAt: now
        };
        
        await dbUpdate(env, `users/${userId}`, updates);
        
        const updatedUser = {
            ...user,
            ...updates
        };
        
        return {
            user: updatedUser,
            hoursPassed: hoursPassed,
            milkProduced: milkProduced,
            eggsProduced: eggsProduced
        };
        
    } catch (error) {
        console.error('Production calculation error:', error);
        return null;
    }
}

// ============================================
// HATCH SYSTEM - MODIFIED (5000)
// ============================================

async function handleHatchCow(env, userId, data) {
    try {
        const { amount } = data;
        const hatchAmount = parseInt(amount) || 1;
        
        if (hatchAmount <= 0) {
            return {
                success: false,
                error: 'Invalid hatch amount',
                errorCode: 'INVALID_AMOUNT'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        const milkNeeded = GAME_CONSTANTS.COW_HATCH_COST * hatchAmount;
        
        if ((user.milk || 0) < milkNeeded) {
            return {
                success: false,
                error: `Insufficient Milk. Need ${milkNeeded} Milk`,
                errorCode: 'INSUFFICIENT_MILK'
            };
        }
        
        const userUpdates = {
            milk: (user.milk || 0) - milkNeeded,
            cows_owned: (user.cows_owned || 0) + hatchAmount,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'hatch_cow',
            amount: hatchAmount,
            milkCost: milkNeeded,
            timestamp: Date.now()
        });
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                cows_hatched: hatchAmount,
                milk_used: milkNeeded,
                new_milk: updatedUser.milk,
                new_cows: updatedUser.cows_owned
            }
        };
        
    } catch (error) {
        console.error('Hatch cow error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'HATCH_COW_ERROR'
        };
    }
}

async function handleHatchChicken(env, userId, data) {
    try {
        const { amount } = data;
        const hatchAmount = parseInt(amount) || 1;
        
        if (hatchAmount <= 0) {
            return {
                success: false,
                error: 'Invalid hatch amount',
                errorCode: 'INVALID_AMOUNT'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        const eggsNeeded = GAME_CONSTANTS.CHICKEN_HATCH_COST * hatchAmount;
        
        if ((user.eggs || 0) < eggsNeeded) {
            return {
                success: false,
                error: `Insufficient Eggs. Need ${eggsNeeded} Eggs`,
                errorCode: 'INSUFFICIENT_EGGS'
            };
        }
        
        const userUpdates = {
            eggs: (user.eggs || 0) - eggsNeeded,
            chickens_owned: (user.chickens_owned || 0) + hatchAmount,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'hatch_chicken',
            amount: hatchAmount,
            eggsCost: eggsNeeded,
            timestamp: Date.now()
        });
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                chickens_hatched: hatchAmount,
                eggs_used: eggsNeeded,
                new_eggs: updatedUser.eggs,
                new_chickens: updatedUser.chickens_owned
            }
        };
        
    } catch (error) {
        console.error('Hatch chicken error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'HATCH_CHICKEN_ERROR'
        };
    }
}

// ============================================
// DIAMOND PRODUCTION
// ============================================

async function handleStartDiamondProduction(env, userId, data) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        if (!user.diamond_engines_owned || user.diamond_engines_owned < 1) {
            return {
                success: false,
                error: 'You need a Diamond Engine first',
                errorCode: 'NO_DIAMOND_ENGINE'
            };
        }
        
        if ((user.milk || 0) < GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK) {
            return {
                success: false,
                error: `Insufficient Milk. Need ${GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK} Milk`,
                errorCode: 'INSUFFICIENT_MILK'
            };
        }
        
        if ((user.eggs || 0) < GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG) {
            return {
                success: false,
                error: `Insufficient Eggs. Need ${GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG} Eggs`,
                errorCode: 'INSUFFICIENT_EGGS'
            };
        }
        
        const userUpdates = {
            milk: (user.milk || 0) - GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK,
            eggs: (user.eggs || 0) - GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG,
            diamond: (user.diamond || 0) + GAME_CONSTANTS.DIAMOND_PRODUCTION_YIELD,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'diamond_production',
            milkUsed: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK,
            eggsUsed: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG,
            diamondProduced: GAME_CONSTANTS.DIAMOND_PRODUCTION_YIELD,
            timestamp: Date.now()
        });
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                diamondProduced: GAME_CONSTANTS.DIAMOND_PRODUCTION_YIELD,
                newMilk: updatedUser.milk,
                newEggs: updatedUser.eggs,
                newDiamond: updatedUser.diamond
            }
        };
        
    } catch (error) {
        console.error('Diamond production error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DIAMOND_PRODUCTION_ERROR'
        };
    }
}

// ============================================
// DIAMOND CONVERSION
// ============================================

async function handleConvertDiamond(env, userId, data) {
    try {
        const { amount } = data;
        const diamondsToConvert = parseInt(amount);
        
        if (!diamondsToConvert || diamondsToConvert <= 0) {
            return {
                success: false,
                error: 'Invalid amount',
                errorCode: 'INVALID_AMOUNT'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        const globalResult = await dbGet(env, 'global');
        
        if (!userResult.success || !globalResult.success) {
            return {
                success: false,
                error: 'Failed to load game state',
                errorCode: 'STATE_LOAD_ERROR'
            };
        }
        
        let user = userResult.data;
        let global = globalResult.data;
        
        if (!user) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        if (!global) {
            global = await initializeGlobalState(env);
        }
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        if ((user.diamond || 0) < diamondsToConvert) {
            return {
                success: false,
                error: 'Insufficient diamonds',
                errorCode: 'INSUFFICIENT_DIAMOND'
            };
        }
        
        const diamondPrice = global.diamond_price || GAME_CONSTANTS.DIAMOND_BASE_PRICE;
        const tonToReceive = diamondsToConvert * diamondPrice;
        
        const userUpdates = {
            diamond: (user.diamond || 0) - diamondsToConvert,
            tonBalance: (user.tonBalance || 0) + tonToReceive,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'diamond_conversion',
            diamondsUsed: diamondsToConvert,
            diamondPrice: diamondPrice,
            tonReceived: tonToReceive,
            timestamp: Date.now()
        });
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                diamondsConverted: diamondsToConvert,
                diamondPrice: diamondPrice,
                tonReceived: tonToReceive,
                newDiamond: updatedUser.diamond,
                newTonBalance: updatedUser.tonBalance
            }
        };
        
    } catch (error) {
        console.error('Diamond conversion error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DIAMOND_CONVERSION_ERROR'
        };
    }
}

// ============================================
// MARKET - P2P ORDER BOOK WITH 10% FEE
// ============================================

async function handleCreateSellOrder(env, userId, data) {
    try {
        const { resource, quantity, pricePerUnit } = data;
        
        if (!['milk', 'eggs'].includes(resource)) {
            return {
                success: false,
                error: 'Invalid resource. Must be milk or eggs',
                errorCode: 'INVALID_RESOURCE'
            };
        }
        
        const orderQuantity = parseInt(quantity);
        
        if (!orderQuantity || orderQuantity < GAME_CONSTANTS.MIN_ORDER_AMOUNT) {
            return {
                success: false,
                error: `Minimum order quantity is ${GAME_CONSTANTS.MIN_ORDER_AMOUNT}`,
                errorCode: 'INVALID_QUANTITY'
            };
        }
        
        const orderPrice = parseFloat(pricePerUnit);
        
        if (!orderPrice || orderPrice <= 0) {
            return {
                success: false,
                error: 'Price must be greater than 0',
                errorCode: 'INVALID_PRICE'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        const userBalance = resource === 'milk' ? (user.milk || 0) : (user.eggs || 0);
        
        if (userBalance < orderQuantity) {
            return {
                success: false,
                error: `Insufficient ${resource}`,
                errorCode: 'INSUFFICIENT_RESOURCE'
            };
        }
        
        const activeOrdersResult = await dbGet(env, `users/${userId}/orders`);
        let activeOrders = 0;
        
        if (activeOrdersResult.success && activeOrdersResult.data) {
            activeOrders = Object.values(activeOrdersResult.data).filter(o => o.status === 'active').length;
        }
        
        if (activeOrders >= GAME_CONSTANTS.MAX_ACTIVE_ORDERS) {
            return {
                success: false,
                error: `Maximum ${GAME_CONSTANTS.MAX_ACTIVE_ORDERS} active orders allowed`,
                errorCode: 'MAX_ORDERS_REACHED'
            };
        }
        
        const userUpdates = {};
        
        if (resource === 'milk') {
            userUpdates.milk = (user.milk || 0) - orderQuantity;
        } else {
            userUpdates.eggs = (user.eggs || 0) - orderQuantity;
        }
        
        userUpdates.updatedAt = Date.now();
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        const orderId = `sell_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
        
        const orderData = {
            id: orderId,
            userId: userId,
            type: 'sell',
            resource: resource,
            quantity: orderQuantity,
            remaining: orderQuantity,
            pricePerUnit: orderPrice,
            status: 'active',
            createdAt: Date.now(),
            updatedAt: Date.now()
        };
        
        await dbSet(env, `orders/${orderId}`, orderData);
        await dbSet(env, `users/${userId}/orders/${orderId}`, {
            id: orderId,
            type: 'sell',
            resource: resource,
            quantity: orderQuantity,
            remaining: orderQuantity,
            pricePerUnit: orderPrice,
            status: 'active',
            createdAt: Date.now()
        });
        
        return {
            success: true,
            data: {
                orderId: orderId,
                order: orderData
            }
        };
        
    } catch (error) {
        console.error('Create sell order error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'CREATE_SELL_ORDER_ERROR'
        };
    }
}

async function handleCreateBuyOrder(env, userId, data) {
    try {
        const { resource, quantity, pricePerUnit } = data;
        
        if (!['milk', 'eggs'].includes(resource)) {
            return {
                success: false,
                error: 'Invalid resource. Must be milk or eggs',
                errorCode: 'INVALID_RESOURCE'
            };
        }
        
        const orderQuantity = parseInt(quantity);
        
        if (!orderQuantity || orderQuantity < GAME_CONSTANTS.MIN_ORDER_AMOUNT) {
            return {
                success: false,
                error: `Minimum order quantity is ${GAME_CONSTANTS.MIN_ORDER_AMOUNT}`,
                errorCode: 'INVALID_QUANTITY'
            };
        }
        
        const orderPrice = parseFloat(pricePerUnit);
        
        if (!orderPrice || orderPrice <= 0) {
            return {
                success: false,
                error: 'Price must be greater than 0',
                errorCode: 'INVALID_PRICE'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        const totalCost = orderQuantity * orderPrice;
        
        if ((user.tonBalance || 0) < totalCost) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        const activeOrdersResult = await dbGet(env, `users/${userId}/orders`);
        let activeOrders = 0;
        
        if (activeOrdersResult.success && activeOrdersResult.data) {
            activeOrders = Object.values(activeOrdersResult.data).filter(o => o.status === 'active').length;
        }
        
        if (activeOrders >= GAME_CONSTANTS.MAX_ACTIVE_ORDERS) {
            return {
                success: false,
                error: `Maximum ${GAME_CONSTANTS.MAX_ACTIVE_ORDERS} active orders allowed`,
                errorCode: 'MAX_ORDERS_REACHED'
            };
        }
        
        const userUpdates = {
            tonBalance: (user.tonBalance || 0) - totalCost,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        const orderId = `buy_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
        
        const orderData = {
            id: orderId,
            userId: userId,
            type: 'buy',
            resource: resource,
            quantity: orderQuantity,
            remaining: orderQuantity,
            pricePerUnit: orderPrice,
            status: 'active',
            createdAt: Date.now(),
            updatedAt: Date.now()
        };
        
        await dbSet(env, `orders/${orderId}`, orderData);
        await dbSet(env, `users/${userId}/orders/${orderId}`, {
            id: orderId,
            type: 'buy',
            resource: resource,
            quantity: orderQuantity,
            remaining: orderQuantity,
            pricePerUnit: orderPrice,
            status: 'active',
            createdAt: Date.now()
        });
        
        return {
            success: true,
            data: {
                orderId: orderId,
                order: orderData
            }
        };
        
    } catch (error) {
        console.error('Create buy order error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'CREATE_BUY_ORDER_ERROR'
        };
    }
}

async function handleExecuteOrder(env, userId, data) {
    try {
        const { orderId, quantity } = data;
        
        const orderResult = await dbGet(env, `orders/${orderId}`);
        
        if (!orderResult.success || !orderResult.data) {
            return {
                success: false,
                error: 'Order not found',
                errorCode: 'ORDER_NOT_FOUND'
            };
        }
        
        const order = orderResult.data;
        
        if (order.status !== 'active') {
            return {
                success: false,
                error: 'Order is not active',
                errorCode: 'ORDER_NOT_ACTIVE'
            };
        }
        
        if (order.userId === userId) {
            return {
                success: false,
                error: 'Cannot execute your own order',
                errorCode: 'OWN_ORDER'
            };
        }
        
        const executeQuantity = quantity ? parseInt(quantity) : order.remaining;
        
        if (executeQuantity <= 0 || executeQuantity > order.remaining) {
            return {
                success: false,
                error: 'Invalid execution quantity',
                errorCode: 'INVALID_QUANTITY'
            };
        }
        
        let buyerId, sellerId;
        let buyer, seller;
        
        if (order.type === 'sell') {
            buyerId = userId;
            sellerId = order.userId;
        } else {
            buyerId = order.userId;
            sellerId = userId;
        }
        
        const buyerResult = await dbGet(env, `users/${buyerId}`);
        
        if (!buyerResult.success || !buyerResult.data) {
            return {
                success: false,
                error: 'Buyer not found',
                errorCode: 'BUYER_NOT_FOUND'
            };
        }
        
        let buyerData = buyerResult.data;
        
        const buyerProductionResult = await calculateProduction(env, buyerId, buyerData);
        
        if (buyerProductionResult) {
            buyerData = buyerProductionResult.user;
        }
        
        const sellerResult = await dbGet(env, `users/${sellerId}`);
        
        if (!sellerResult.success || !sellerResult.data) {
            return {
                success: false,
                error: 'Seller not found',
                errorCode: 'SELLER_NOT_FOUND'
            };
        }
        
        let sellerData = sellerResult.data;
        
        const sellerProductionResult = await calculateProduction(env, sellerId, sellerData);
        
        if (sellerProductionResult) {
            sellerData = sellerProductionResult.user;
        }
        
        const totalCost = executeQuantity * order.pricePerUnit;
        const fee = order.type === 'sell' ? totalCost * (GAME_CONSTANTS.MARKET_FEE_PERCENT / 100) : 0;
        const sellerReceives = order.type === 'sell' ? totalCost - fee : totalCost;
        
        if (order.type === 'sell') {
            if ((buyerData.tonBalance || 0) < totalCost) {
                return {
                    success: false,
                    error: 'Buyer has insufficient TON balance',
                    errorCode: 'BUYER_INSUFFICIENT_TON'
                };
            }
            
            const buyerUpdates = {
                tonBalance: (buyerData.tonBalance || 0) - totalCost
            };
            
            if (order.resource === 'milk') {
                buyerUpdates.milk = (buyerData.milk || 0) + executeQuantity;
            } else {
                buyerUpdates.eggs = (buyerData.eggs || 0) + executeQuantity;
            }
            
            buyerUpdates.updatedAt = Date.now();
            
            await dbUpdate(env, `users/${buyerId}`, buyerUpdates);
            
            const sellerUpdates = {
                tonBalance: (sellerData.tonBalance || 0) + sellerReceives,
                updatedAt: Date.now()
            };
            
            await dbUpdate(env, `users/${sellerId}`, sellerUpdates);
            
            await notifyOrderFilled(env, sellerId, order, executeQuantity, totalCost, fee);
            
        } else {
            const sellerResourceBalance = order.resource === 'milk' ? 
                (sellerData.milk || 0) : (sellerData.eggs || 0);
            
            if (sellerResourceBalance < executeQuantity) {
                return {
                    success: false,
                    error: 'Seller has insufficient resource',
                    errorCode: 'SELLER_INSUFFICIENT_RESOURCE'
                };
            }
            
            const sellerUpdates = {
                tonBalance: (sellerData.tonBalance || 0) + totalCost
            };
            
            if (order.resource === 'milk') {
                sellerUpdates.milk = (sellerData.milk || 0) - executeQuantity;
            } else {
                sellerUpdates.eggs = (sellerData.eggs || 0) - executeQuantity;
            }
            
            sellerUpdates.updatedAt = Date.now();
            
            await dbUpdate(env, `users/${sellerId}`, sellerUpdates);
            
            const buyerUpdates = {};
            
            if (order.resource === 'milk') {
                buyerUpdates.milk = (buyerData.milk || 0) + executeQuantity;
            } else {
                buyerUpdates.eggs = (buyerData.eggs || 0) + executeQuantity;
            }
            
            buyerUpdates.updatedAt = Date.now();
            
            await dbUpdate(env, `users/${buyerId}`, buyerUpdates);
            
            await notifyOrderFilled(env, buyerId, order, executeQuantity, totalCost, 0);
        }
        
        const newRemaining = order.remaining - executeQuantity;
        const orderStatus = newRemaining <= 0 ? 'filled' : 'active';
        
        const orderUpdates = {
            remaining: newRemaining,
            status: orderStatus,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `orders/${orderId}`, orderUpdates);
        await dbUpdate(env, `users/${order.userId}/orders/${orderId}`, orderUpdates);
        
        const txId = `tx_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
        
        await dbPush(env, `users/${buyerId}/transactions`, {
            id: txId,
            type: 'market_buy',
            orderId: orderId,
            resource: order.resource,
            quantity: executeQuantity,
            pricePerUnit: order.pricePerUnit,
            totalCost: totalCost,
            sellerId: sellerId,
            timestamp: Date.now()
        });
        
        await dbPush(env, `users/${sellerId}/transactions`, {
            id: txId,
            type: 'market_sell',
            orderId: orderId,
            resource: order.resource,
            quantity: executeQuantity,
            pricePerUnit: order.pricePerUnit,
            totalReceived: sellerReceives,
            fee: fee,
            buyerId: buyerId,
            timestamp: Date.now()
        });
        
        return {
            success: true,
            data: {
                txId: txId,
                orderId: orderId,
                resource: order.resource,
                quantity: executeQuantity,
                pricePerUnit: order.pricePerUnit,
                totalCost: totalCost,
                fee: fee,
                sellerReceives: sellerReceives,
                orderRemaining: newRemaining,
                orderStatus: orderStatus
            }
        };
        
    } catch (error) {
        console.error('Execute order error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'EXECUTE_ORDER_ERROR'
        };
    }
}

async function handleGetMarketOrders(env, data) {
    try {
        const { resource, type, page = 1, limit = 10 } = data;
        
        const ordersResult = await dbGet(env, 'orders');
        
        if (!ordersResult.success || !ordersResult.data) {
            return {
                success: true,
                data: {
                    orders: [],
                    total: 0,
                    page: page,
                    totalPages: 0
                }
            };
        }
        
        const allOrders = ordersResult.data;
        const filteredOrders = [];
        
        for (const [orderId, order] of Object.entries(allOrders)) {
            if (order.status !== 'active') continue;
            
            if (resource && order.resource !== resource) continue;
            
            if (type && order.type !== type) continue;
            
            filteredOrders.push({
                id: orderId,
                userId: order.userId,
                type: order.type,
                resource: order.resource,
                quantity: order.quantity,
                remaining: order.remaining,
                pricePerUnit: order.pricePerUnit,
                createdAt: order.createdAt
            });
        }
        
        if (type === 'sell') {
            filteredOrders.sort((a, b) => a.pricePerUnit - b.pricePerUnit);
        } else if (type === 'buy') {
            filteredOrders.sort((a, b) => b.pricePerUnit - a.pricePerUnit);
        } else {
            filteredOrders.sort((a, b) => b.createdAt - a.createdAt);
        }
        
        const total = filteredOrders.length;
        const totalPages = Math.ceil(total / limit);
        const start = (page - 1) * limit;
        const end = start + limit;
        const paginatedOrders = filteredOrders.slice(start, end);
        
        return {
            success: true,
            data: {
                orders: paginatedOrders,
                total: total,
                page: page,
                totalPages: totalPages,
                hasMore: page < totalPages
            }
        };
        
    } catch (error) {
        console.error('Get market orders error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_MARKET_ORDERS_ERROR'
        };
    }
}

async function handleGetMyOrders(env, userId) {
    try {
        const ordersResult = await dbGet(env, `users/${userId}/orders`);
        
        if (!ordersResult.success || !ordersResult.data) {
            return {
                success: true,
                data: {
                    orders: []
                }
            };
        }
        
        const userOrders = ordersResult.data;
        const activeOrders = [];
        const filledOrders = [];
        
        for (const [orderId, order] of Object.entries(userOrders)) {
            if (order.status === 'active') {
                activeOrders.push({
                    id: orderId,
                    ...order
                });
            } else {
                filledOrders.push({
                    id: orderId,
                    ...order
                });
            }
        }
        
        activeOrders.sort((a, b) => b.createdAt - a.createdAt);
        filledOrders.sort((a, b) => b.createdAt - a.createdAt);
        
        return {
            success: true,
            data: {
                active: activeOrders.slice(0, 20),
                filled: filledOrders.slice(0, 20)
            }
        };
        
    } catch (error) {
        console.error('Get my orders error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_MY_ORDERS_ERROR'
        };
    }
}

async function handleCancelOrder(env, userId, data) {
    try {
        const { orderId } = data;
        
        const orderResult = await dbGet(env, `orders/${orderId}`);
        
        if (!orderResult.success || !orderResult.data) {
            return {
                success: false,
                error: 'Order not found',
                errorCode: 'ORDER_NOT_FOUND'
            };
        }
        
        const order = orderResult.data;
        
        if (order.userId !== userId) {
            return {
                success: false,
                error: 'Unauthorized to cancel this order',
                errorCode: 'UNAUTHORIZED'
            };
        }
        
        if (order.status !== 'active') {
            return {
                success: false,
                error: 'Order is not active',
                errorCode: 'ORDER_NOT_ACTIVE'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        if (order.type === 'sell') {
            const userUpdates = {};
            
            if (order.resource === 'milk') {
                userUpdates.milk = (user.milk || 0) + order.remaining;
            } else {
                userUpdates.eggs = (user.eggs || 0) + order.remaining;
            }
            
            userUpdates.updatedAt = Date.now();
            
            await dbUpdate(env, `users/${userId}`, userUpdates);
            
        } else {
            const refundAmount = order.remaining * order.pricePerUnit;
            
            await dbUpdate(env, `users/${userId}`, {
                tonBalance: (user.tonBalance || 0) + refundAmount,
                updatedAt: Date.now()
            });
        }
        
        const orderUpdates = {
            status: 'cancelled',
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `orders/${orderId}`, orderUpdates);
        await dbUpdate(env, `users/${userId}/orders/${orderId}`, orderUpdates);
        
        return {
            success: true,
            data: {
                orderId: orderId,
                status: 'cancelled'
            }
        };
        
    } catch (error) {
        console.error('Cancel order error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'CANCEL_ORDER_ERROR'
        };
    }
}

// ============================================
// DEPOSIT SYSTEM
// ============================================

async function handleDeposit(env, userId, data) {
    try {
        const { amount, txHash, comment } = data;
        
        if (!amount || amount < GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT) {
            return {
                success: false,
                error: `Minimum deposit amount is ${GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT} TON`,
                errorCode: 'INVALID_AMOUNT'
            };
        }
        
        if (!comment || comment.toString() !== userId) {
            return {
                success: false,
                error: 'Invalid comment. Comment must contain only your User ID',
                errorCode: 'INVALID_COMMENT'
            };
        }
        
        const existingTx = await dbGet(env, `transactions/${txHash}`);
        
        if (existingTx.success && existingTx.data) {
            return {
                success: false,
                error: 'Transaction already processed',
                errorCode: 'DUPLICATE_TRANSACTION'
            };
        }
        
        const depositId = `dep_${Date.now()}_${userId}`;
        const now = Date.now();
        
        const depositRecord = {
            id: depositId,
            userId: userId,
            amount: parseFloat(amount),
            txHash: txHash,
            comment: comment,
            status: 'pending',
            createdAt: now,
            updatedAt: now
        };
        
        await dbSet(env, `deposits/${depositId}`, depositRecord);
        await dbSet(env, `transactions/${txHash}`, depositRecord);
        await dbSet(env, `users/${userId}/deposits/${depositId}`, depositRecord);
        
        return {
            success: true,
            data: {
                depositId: depositId,
                amount: amount,
                status: 'pending',
                message: 'Transaction received. Verification in progress.'
            }
        };
        
    } catch (error) {
        console.error('Deposit error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DEPOSIT_ERROR'
        };
    }
}

async function handleVerifyDeposit(env, userId, data) {
    try {
        const { txHash, depositId } = data;
        
        let depositRecord = null;
        
        if (txHash) {
            const txResult = await dbGet(env, `transactions/${txHash}`);
            if (txResult.success && txResult.data) {
                depositRecord = txResult.data;
            }
        }
        
        if (!depositRecord && depositId) {
            const depositResult = await dbGet(env, `deposits/${depositId}`);
            if (depositResult.success && depositResult.data) {
                depositRecord = depositResult.data;
            }
        }
        
        if (!depositRecord) {
            return {
                success: false,
                error: 'Deposit record not found',
                errorCode: 'DEPOSIT_NOT_FOUND'
            };
        }
        
        if (depositRecord.userId !== userId) {
            return {
                success: false,
                error: 'Unauthorized access',
                errorCode: 'UNAUTHORIZED'
            };
        }
        
        if (depositRecord.status === 'completed') {
            return {
                success: true,
                data: {
                    status: 'completed',
                    amount: depositRecord.amount,
                    verified: true,
                    timestamp: depositRecord.updatedAt
                }
            };
        }
        
        const isDevelopment = env.ENVIRONMENT === 'development';
        
        if (isDevelopment && depositRecord.createdAt) {
            const timeElapsed = Date.now() - depositRecord.createdAt;
            if (timeElapsed > 30000) {
                await dbUpdate(env, `deposits/${depositRecord.id}`, {
                    status: 'completed',
                    verified: true,
                    updatedAt: Date.now()
                });
                
                await dbUpdate(env, `transactions/${depositRecord.txHash}`, {
                    status: 'completed',
                    verified: true,
                    updatedAt: Date.now()
                });
                
                await dbUpdate(env, `users/${userId}/deposits/${depositRecord.id}`, {
                    status: 'completed',
                    verified: true,
                    updatedAt: Date.now()
                });
                
                const userResult = await dbGet(env, `users/${userId}`);
                if (userResult.success && userResult.data) {
                    const user = userResult.data;
                    await dbUpdate(env, `users/${userId}`, {
                        tonBalance: (user.tonBalance || 0) + depositRecord.amount,
                        updatedAt: Date.now()
                    });
                    
                    await notifyDepositSuccess(env, userId, depositRecord.amount);
                }
                
                return {
                    success: true,
                    data: {
                        status: 'completed',
                        amount: depositRecord.amount,
                        verified: true,
                        timestamp: Date.now()
                    }
                };
            }
        }
        
        return {
            success: true,
            data: {
                status: depositRecord.status,
                amount: depositRecord.amount,
                verified: depositRecord.verified || false,
                timestamp: depositRecord.createdAt
            }
        };
        
    } catch (error) {
        console.error('Verify deposit error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_DEPOSIT_ERROR'
        };
    }
}

// ============================================
// WITHDRAWAL SYSTEM - MODIFIED (0.1 MIN)
// ============================================

async function handleWithdraw(env, userId, data) {
    try {
        const { amount, address } = data;
        const withdrawAmount = parseFloat(amount);
        
        if (!withdrawAmount || withdrawAmount < GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT) {
            return {
                success: false,
                error: `Minimum withdrawal amount is ${GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT} TON`,
                errorCode: 'INVALID_AMOUNT'
            };
        }
        
        if (!address || address.trim().length < 10) {
            return {
                success: false,
                error: 'Valid TON wallet address is required',
                errorCode: 'INVALID_ADDRESS'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        const fee = withdrawAmount * (GAME_CONSTANTS.WITHDRAW_FEE_PERCENT / 100);
        const netAmount = withdrawAmount - fee;
        
        if ((user.tonBalance || 0) < withdrawAmount) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        const withdrawalId = `wd_${Date.now()}_${userId}`;
        const now = Date.now();
        
        const withdrawalRecord = {
            id: withdrawalId,
            userId: userId,
            amount: withdrawAmount,
            fee: fee,
            netAmount: netAmount,
            address: address,
            status: 'pending',
            createdAt: now,
            updatedAt: now
        };
        
        await dbUpdate(env, `users/${userId}`, {
            tonBalance: (user.tonBalance || 0) - withdrawAmount,
            updatedAt: now
        });
        
        await dbSet(env, `withdrawals/${withdrawalId}`, withdrawalRecord);
        await dbSet(env, `users/${userId}/withdrawals/${withdrawalId}`, withdrawalRecord);
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'withdrawal',
            withdrawalId: withdrawalId,
            amount: withdrawAmount,
            fee: fee,
            netAmount: netAmount,
            address: address,
            status: 'pending',
            timestamp: now
        });
        
        return {
            success: true,
            data: {
                withdrawalId: withdrawalId,
                amount: withdrawAmount,
                fee: fee,
                netAmount: netAmount,
                newBalance: (user.tonBalance || 0) - withdrawAmount,
                status: 'pending'
            }
        };
        
    } catch (error) {
        console.error('Withdrawal error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'WITHDRAWAL_ERROR'
        };
    }
}

// ============================================
// REFERRAL SYSTEM - MODIFIED (Auto-add to balance)
// ============================================

async function handleClaimReferralEarnings(env, userId) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        const earnings = parseFloat(user.referralEarnings || 0);
        
        if (earnings <= 0) {
            return {
                success: false,
                error: 'No referral earnings to claim',
                errorCode: 'NO_EARNINGS'
            };
        }
        
        const currentTonBalance = parseFloat(user.tonBalance || 0);
        const currentClaimed = parseFloat(user.referralEarningsClaimed || 0);
        
        const userUpdates = {
            tonBalance: currentTonBalance + earnings,
            referralEarnings: 0,
            referralEarningsClaimed: currentClaimed + earnings,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'claim_referral',
            amount: earnings,
            timestamp: Date.now()
        });
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                claimedAmount: earnings,
                newTonBalance: updatedUser.tonBalance,
                totalClaimed: updatedUser.referralEarningsClaimed
            }
        };
        
    } catch (error) {
        console.error('Claim referral earnings error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'CLAIM_REFERRAL_ERROR'
        };
    }
}

async function handleGetReferralInfo(env, userId) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const user = userResult.data;
        
        const referralsResult = await dbGet(env, `users/${userId}/referrals`);
        
        let referrals = [];
        if (referralsResult.success && referralsResult.data) {
            const referralsObj = referralsResult.data;
            referrals = Object.entries(referralsObj).map(([key, value]) => ({
                id: key,
                ...value
            }));
            
            referrals.sort((a, b) => (b.joinedAt || 0) - (a.joinedAt || 0));
        }
        
        const earningsResult = await dbGet(env, `users/${userId}/referralEarnings`);
        let earnings = [];
        if (earningsResult.success && earningsResult.data) {
            const earningsObj = earningsResult.data;
            earnings = Object.values(earningsObj);
            earnings.sort((a, b) => b.timestamp - a.timestamp);
        }
        
        const totalEarnings = earnings.reduce((sum, e) => sum + parseFloat(e.amount || 0), 0);
        
        return {
            success: true,
            data: {
                referralCode: user.referralCode,
                referralEarnings: parseFloat(user.referralEarnings || 0),
                referralEarningsClaimed: parseFloat(user.referralEarningsClaimed || 0),
                totalEarnings: totalEarnings,
                referrals: referrals.slice(0, 50),
                earnings: earnings.slice(0, 50)
            }
        };
        
    } catch (error) {
        console.error('Get referral info error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_REFERRAL_ERROR'
        };
    }
}

// ============================================
// TASK SYSTEM - NEW
// ============================================

async function handleCreateTask(env, userId, data) {
    try {
        const { type, link, targetUsers, reward } = data;
        
        if (!['channel', 'bot'].includes(type)) {
            return {
                success: false,
                error: 'Invalid task type. Must be channel or bot',
                errorCode: 'INVALID_TASK_TYPE'
            };
        }
        
        const target = parseInt(targetUsers);
        
        if (!target || target < GAME_CONSTANTS.MIN_TASK_TARGET) {
            return {
                success: false,
                error: `Minimum target users is ${GAME_CONSTANTS.MIN_TASK_TARGET}`,
                errorCode: 'INVALID_TARGET'
            };
        }
        
        if (!link || !link.includes('t.me/')) {
            return {
                success: false,
                error: 'Valid Telegram link is required',
                errorCode: 'INVALID_LINK'
            };
        }
        
        // Fixed reward from constants - don't trust client
        const taskReward = GAME_CONSTANTS.TASK_REWARD;
        const totalCost = target * taskReward;
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        if ((user.tonBalance || 0) < totalCost) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        const now = Date.now();
        const taskId = `task_${now}_${Math.random().toString(36).substring(2, 10)}`;
        
        const taskData = {
            id: taskId,
            creatorId: userId,
            type: type,
            link: link,
            targetUsers: target,
            reward: taskReward,
            completions: 0,
            completedBy: [],
            status: 'active',
            createdAt: now,
            expiresAt: now + (GAME_CONSTANTS.MAX_TASK_DURATION_DAYS * 24 * 60 * 60 * 1000),
            updatedAt: now
        };
        
        // Deduct cost from creator
        await dbUpdate(env, `users/${userId}`, {
            tonBalance: (user.tonBalance || 0) - totalCost,
            updatedAt: now
        });
        
        // Save task in community tasks
        await dbSet(env, `tasks/community/${taskId}`, taskData);
        
        // Record transaction
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'create_task',
            taskId: taskId,
            taskType: type,
            targetUsers: target,
            cost: totalCost,
            timestamp: now
        });
        
        await notifyTaskCreated(env, userId, type, target, totalCost);
        
        return {
            success: true,
            data: {
                taskId: taskId,
                type: type,
                targetUsers: target,
                totalCost: totalCost,
                reward: taskReward
            }
        };
        
    } catch (error) {
        console.error('Create task error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'CREATE_TASK_ERROR'
        };
    }
}

async function handleVerifyTask(env, userId, data) {
    try {
        const { taskId, taskType } = data;
        
        // Try to find task in community or partner tasks
        let taskResult = await dbGet(env, `tasks/community/${taskId}`);
        let task = taskResult.data;
        let taskCategory = 'community';
        
        if (!task) {
            taskResult = await dbGet(env, `tasks/partner/${taskId}`);
            task = taskResult.data;
            taskCategory = 'partner';
        }
        
        if (!task) {
            return {
                success: false,
                error: 'Task not found',
                errorCode: 'TASK_NOT_FOUND'
            };
        }
        
        if (task.status !== 'active') {
            return {
                success: false,
                error: 'Task is no longer active',
                errorCode: 'TASK_INACTIVE'
            };
        }
        
        // Check if user already completed this task
        if (task.completedBy && task.completedBy.includes(userId)) {
            return {
                success: false,
                error: 'Task already completed',
                errorCode: 'TASK_ALREADY_COMPLETED'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        // For channel tasks, verify membership
        if (task.type === 'channel') {
            const isMember = await checkTelegramMembership(env, userId, task.link);
            
            if (!isMember) {
                return {
                    success: false,
                    error: 'Not a member of the channel',
                    errorCode: 'NOT_MEMBER'
                };
            }
        }
        
        // For bot tasks, no verification needed, just mark as completed
        
        // Check if task has reached target
        const currentCompletions = task.completions || 0;
        const newCompletions = currentCompletions + 1;
        
        const taskUpdates = {
            completions: newCompletions,
            completedBy: [...(task.completedBy || []), userId],
            updatedAt: Date.now()
        };
        
        // If task reached target, deactivate it
        if (newCompletions >= task.targetUsers) {
            taskUpdates.status = 'completed';
        }
        
        await dbUpdate(env, `tasks/${taskCategory}/${taskId}`, taskUpdates);
        
        // Add reward to user
        const reward = task.reward || GAME_CONSTANTS.TASK_REWARD;
        
        await dbUpdate(env, `users/${userId}`, {
            tonBalance: (user.tonBalance || 0) + reward,
            updatedAt: Date.now()
        });
        
        // Add to user's completed tasks
        const completedTasks = user.completedTasks || [];
        completedTasks.push(taskId);
        
        await dbUpdate(env, `users/${userId}`, {
            completedTasks: completedTasks
        });
        
        // Record transaction
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'task_reward',
            taskId: taskId,
            taskType: task.type,
            reward: reward,
            timestamp: Date.now()
        });
        
        await notifyTaskCompleted(env, userId, task.type, reward);
        
        return {
            success: true,
            data: {
                taskId: taskId,
                reward: reward,
                completions: newCompletions,
                taskCompleted: newCompletions >= task.targetUsers
            }
        };
        
    } catch (error) {
        console.error('Verify task error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_TASK_ERROR'
        };
    }
}

async function handleGetTasks(env, userId) {
    try {
        // Get partner tasks (system tasks)
        const partnerTasksResult = await dbGet(env, 'tasks/partner');
        let partnerTasks = [];
        
        if (partnerTasksResult.success && partnerTasksResult.data) {
            partnerTasks = Object.values(partnerTasksResult.data)
                .filter(t => t.status === 'active')
                .map(task => ({
                    ...task,
                    completedByUser: task.completedBy && task.completedBy.includes(userId)
                }));
        }
        
        // Get community tasks
        const communityTasksResult = await dbGet(env, 'tasks/community');
        let communityTasks = [];
        
        if (communityTasksResult.success && communityTasksResult.data) {
            communityTasks = Object.values(communityTasksResult.data)
                .filter(t => t.status === 'active')
                .map(task => ({
                    ...task,
                    completedByUser: task.completedBy && task.completedBy.includes(userId)
                }));
        }
        
        return {
            success: true,
            data: {
                partner: partnerTasks,
                community: communityTasks
            }
        };
        
    } catch (error) {
        console.error('Get tasks error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_TASKS_ERROR'
        };
    }
}

// ============================================
// INITIALIZATION HANDLER
// ============================================

async function handleInitializeUser(env, userId, data) {
    try {
        const { startParam, userInfo } = data;
        
        let referredBy = null;
        if (startParam) {
            referredBy = extractReferrerFromStartParam(startParam);
            console.log('Extracted referrer:', referredBy, 'from startParam:', startParam);
        }
        
        const existingUser = await dbGet(env, `users/${userId}`);
        
        if (existingUser.success && existingUser.data) {
            console.log('User already exists:', userId);
            
            if (userInfo) {
                const updates = {};
                if (userInfo.first_name) updates.firstName = userInfo.first_name;
                if (userInfo.last_name) updates.lastName = userInfo.last_name;
                if (userInfo.username) updates.username = userInfo.username;
                if (userInfo.photo_url) updates.photoUrl = userInfo.photo_url;
                
                if (Object.keys(updates).length > 0) {
                    updates.updatedAt = Date.now();
                    await dbUpdate(env, `users/${userId}`, updates);
                    
                    if (existingUser.data.referredBy) {
                        await dbUpdate(env, `users/${existingUser.data.referredBy}/referrals/${userId}`, {
                            firstName: updates.firstName || existingUser.data.firstName,
                            lastName: updates.lastName || existingUser.data.lastName,
                            username: updates.username || existingUser.data.username,
                            photoUrl: updates.photoUrl || existingUser.data.photoUrl
                        });
                    }
                }
            }
            
            return {
                success: true,
                data: {
                    message: 'User already exists',
                    user: existingUser.data,
                    referredBy: existingUser.data.referredBy
                }
            };
        }
        
        console.log('Creating new user:', userId, 'referred by:', referredBy);
        
        const userData = await initializeUser(env, userId, userInfo || {}, startParam);
        
        return {
            success: true,
            data: {
                message: 'User initialized successfully',
                user: userData,
                referredBy: referredBy
            }
        };
        
    } catch (error) {
        console.error('Initialize user error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'INIT_USER_ERROR'
        };
    }
}

// ============================================
// LANGUAGE HANDLING
// ============================================

async function handleSetLanguage(env, userId, data) {
    try {
        const { language } = data;
        
        if (!['en', 'ru'].includes(language)) {
            return {
                success: false,
                error: 'Invalid language. Supported: en, ru',
                errorCode: 'INVALID_LANGUAGE'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        await dbUpdate(env, `users/${userId}`, {
            language: language,
            updatedAt: Date.now()
        });
        
        return {
            success: true,
            data: {
                language: language,
                message: language === 'en' ? 'Language set to English' : '–Ø–∑—ã–∫ –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ –†—É—Å—Å–∫–∏–π'
            }
        };
        
    } catch (error) {
        console.error('Set language error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'SET_LANGUAGE_ERROR'
        };
    }
}

// ============================================
// GET STATE - MAIN STATE FUNCTION WITH TASKS
// ============================================

async function handleGetState(env, userId) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        const globalResult = await dbGet(env, 'global');
        
        let global = globalResult.data;
        
        if (!global) {
            global = await initializeGlobalState(env);
        }
        
        let user = userResult.data;
        
        if (user) {
            const productionResult = await calculateProduction(env, userId, user);
            
            if (productionResult) {
                user = productionResult.user;
            }
        } else {
            user = {
                tonBalance: 0,
                milk: 0,
                eggs: 0,
                diamond: 0,
                cows_owned: 0,
                chickens_owned: 0,
                diamond_engines_owned: 0,
                lastProduction: Date.now(),
                milkPerHour: 0,
                eggsPerHour: 0,
                secondsUntilNext: 0,
                referralCode: null,
                referredBy: null,
                referralEarnings: 0,
                referralEarningsClaimed: 0,
                language: 'en',
                firstName: '',
                lastName: '',
                username: '',
                photoUrl: '',
                activeOrdersCount: 0,
                completedTasks: []
            };
        }
        
        let referralStats = {
            totalReferrals: 0,
            totalEarnings: 0,
            recentReferrals: [],
            recentEarnings: []
        };
        
        const referralsResult = await dbGet(env, `users/${userId}/referrals`);
        
        if (referralsResult.success && referralsResult.data) {
            const referralsObj = referralsResult.data;
            const referrals = Object.entries(referralsObj).map(([key, value]) => ({
                id: key,
                userId: value.userId,
                firstName: value.firstName || 'Farmer',
                lastName: value.lastName || '',
                username: value.username || '',
                photoUrl: value.photoUrl || '',
                joinedAt: value.joinedAt,
                totalEarnedFromThisUser: value.totalEarnedFromThisUser || 0,
                lastPurchase: value.lastPurchase
            }));
            
            referralStats.totalReferrals = referrals.length;
            
            referralStats.recentReferrals = referrals
                .sort((a, b) => (b.joinedAt || 0) - (a.joinedAt || 0))
                .slice(0, 50);
        }
        
        const earningsResult = await dbGet(env, `users/${userId}/referralEarnings`);
        
        if (earningsResult.success && earningsResult.data) {
            const earningsObj = earningsResult.data;
            const earnings = Object.values(earningsObj);
            referralStats.totalEarnings = earnings.reduce((sum, e) => sum + parseFloat(e.amount || 0), 0);
            
            const recentEarnings = earnings
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, 50);
            
            referralStats.recentEarnings = recentEarnings;
        }
        
        let pendingDeposits = [];
        
        const depositsResult = await dbGet(env, `users/${userId}/deposits`);
        
        if (depositsResult.success && depositsResult.data) {
            pendingDeposits = Object.values(depositsResult.data)
                .filter(d => d.status === 'pending' || d.status === 'verifying')
                .map(d => ({
                    depositId: d.id,
                    amount: d.amount,
                    timestamp: d.createdAt,
                    status: d.status,
                    txHash: d.txHash
                }))
                .slice(0, 3);
        }
        
        let activeOrdersCount = 0;
        
        const ordersResult = await dbGet(env, `users/${userId}/orders`);
        
        if (ordersResult.success && ordersResult.data) {
            activeOrdersCount = Object.values(ordersResult.data)
                .filter(o => o.status === 'active')
                .length;
        }
        
        let marketStats = {
            milk: { sellOrders: 0, buyOrders: 0, bestSellPrice: 0, bestBuyPrice: 0, totalMilk: 0, totalEggs: 0 },
            eggs: { sellOrders: 0, buyOrders: 0, bestSellPrice: 0, bestBuyPrice: 0 }
        };
        
        const marketOrdersResult = await dbGet(env, 'orders');
        
        if (marketOrdersResult.success && marketOrdersResult.data) {
            const allOrders = Object.values(marketOrdersResult.data);
            
            const milkSellOrders = allOrders.filter(o => 
                o.resource === 'milk' && o.type === 'sell' && o.status === 'active');
            
            marketStats.milk.sellOrders = milkSellOrders.length;
            marketStats.milk.totalMilk = milkSellOrders.reduce((sum, o) => sum + o.remaining, 0);
            
            if (milkSellOrders.length > 0) {
                marketStats.milk.bestSellPrice = Math.min(...milkSellOrders.map(o => o.pricePerUnit));
            }
            
            const milkBuyOrders = allOrders.filter(o => 
                o.resource === 'milk' && o.type === 'buy' && o.status === 'active');
            
            marketStats.milk.buyOrders = milkBuyOrders.length;
            
            if (milkBuyOrders.length > 0) {
                marketStats.milk.bestBuyPrice = Math.max(...milkBuyOrders.map(o => o.pricePerUnit));
            }
            
            const eggSellOrders = allOrders.filter(o => 
                o.resource === 'eggs' && o.type === 'sell' && o.status === 'active');
            
            marketStats.eggs.sellOrders = eggSellOrders.length;
            marketStats.eggs.totalEggs = eggSellOrders.reduce((sum, o) => sum + o.remaining, 0);
            
            if (eggSellOrders.length > 0) {
                marketStats.eggs.bestSellPrice = Math.min(...eggSellOrders.map(o => o.pricePerUnit));
            }
            
            const eggBuyOrders = allOrders.filter(o => 
                o.resource === 'eggs' && o.type === 'buy' && o.status === 'active');
            
            marketStats.eggs.buyOrders = eggBuyOrders.length;
            
            if (eggBuyOrders.length > 0) {
                marketStats.eggs.bestBuyPrice = Math.max(...eggBuyOrders.map(o => o.pricePerUnit));
            }
        }
        
        // Get tasks
        const tasksResult = await handleGetTasks(env, userId);
        let tasks = tasksResult.success ? tasksResult.data : { partner: [], community: [] };
        
        const milkPerHour = (user.cows_owned || 0) * GAME_CONSTANTS.COW_PRODUCTION_RATE;
        const eggsPerHour = (user.chickens_owned || 0) * GAME_CONSTANTS.CHICKEN_PRODUCTION_RATE;
        
        const lastProduction = user.lastProduction || Date.now();
        const nextProduction = lastProduction + GAME_CONSTANTS.HOUR_IN_MS;
        const msUntilNext = Math.max(0, nextProduction - Date.now());
        const secondsUntilNext = Math.floor(msUntilNext / 1000);
        const minutesUntilNext = Math.floor(secondsUntilNext / 60);
        const secondsRemaining = secondsUntilNext % 60;
        
        return {
            success: true,
            data: {
                user: {
                    tonBalance: parseFloat(user.tonBalance || 0),
                    milk: parseFloat(user.milk || 0),
                    eggs: parseFloat(user.eggs || 0),
                    diamond: parseFloat(user.diamond || 0),
                    
                    cows_owned: user.cows_owned || 0,
                    chickens_owned: user.chickens_owned || 0,
                    diamond_engines_owned: user.diamond_engines_owned || 0,
                    
                    milkPerHour: milkPerHour,
                    eggsPerHour: eggsPerHour,
                    
                    lastProduction: user.lastProduction,
                    secondsUntilNext: secondsUntilNext,
                    minutesUntilNext: minutesUntilNext,
                    secondsRemaining: secondsRemaining,
                    
                    referralCode: user.referralCode,
                    referredBy: user.referredBy,
                    referralEarnings: parseFloat(user.referralEarnings || 0),
                    referralEarningsClaimed: parseFloat(user.referralEarningsClaimed || 0),
                    
                    language: user.language || 'en',
                    firstName: user.firstName || '',
                    lastName: user.lastName || '',
                    username: user.username || '',
                    photoUrl: user.photoUrl || '',
                    
                    activeOrdersCount: activeOrdersCount,
                    completedTasks: user.completedTasks || []
                },
                
                global: {
                    cows_sold: global.cows_sold || 0,
                    cows_cap: GAME_CONSTANTS.COW_GLOBAL_CAP,
                    cows_remaining: Math.max(0, GAME_CONSTANTS.COW_GLOBAL_CAP - (global.cows_sold || 0)),
                    cows_progress: ((global.cows_sold || 0) / GAME_CONSTANTS.COW_GLOBAL_CAP) * 100,
                    
                    chickens_sold: global.chickens_sold || 0,
                    chickens_cap: GAME_CONSTANTS.CHICKEN_GLOBAL_CAP,
                    chickens_remaining: Math.max(0, GAME_CONSTANTS.CHICKEN_GLOBAL_CAP - (global.chickens_sold || 0)),
                    chickens_progress: ((global.chickens_sold || 0) / GAME_CONSTANTS.CHICKEN_GLOBAL_CAP) * 100,
                    
                    chicken_unlocked: (global.cows_sold || 0) >= GAME_CONSTANTS.COW_GLOBAL_CAP,
                    diamond_unlocked: (global.cows_sold || 0) >= GAME_CONSTANTS.COW_GLOBAL_CAP && 
                                    (global.chickens_sold || 0) >= GAME_CONSTANTS.CHICKEN_GLOBAL_CAP,
                    
                    diamond_price: global.diamond_price || GAME_CONSTANTS.DIAMOND_BASE_PRICE,
                    
                    cows_until_chicken: Math.max(0, GAME_CONSTANTS.COW_GLOBAL_CAP - (global.cows_sold || 0)),
                    chickens_until_diamond: Math.max(0, GAME_CONSTANTS.CHICKEN_GLOBAL_CAP - (global.chickens_sold || 0))
                },
                
                constants: {
                    COW_PRICE: GAME_CONSTANTS.COW_PRICE,
                    COW_PRODUCTION_RATE: GAME_CONSTANTS.COW_PRODUCTION_RATE,
                    COW_HATCH_COST: GAME_CONSTANTS.COW_HATCH_COST,
                    
                    CHICKEN_PRICE: GAME_CONSTANTS.CHICKEN_PRICE,
                    CHICKEN_PRODUCTION_RATE: GAME_CONSTANTS.CHICKEN_PRODUCTION_RATE,
                    CHICKEN_HATCH_COST: GAME_CONSTANTS.CHICKEN_HATCH_COST,
                    
                    DIAMOND_ENGINE_PRICE: GAME_CONSTANTS.DIAMOND_ENGINE_PRICE,
                    DIAMOND_PRODUCTION_COST_MILK: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK,
                    DIAMOND_PRODUCTION_COST_EGG: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG,
                    
                    MIN_WITHDRAW_AMOUNT: GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT,
                    WITHDRAW_FEE_PERCENT: GAME_CONSTANTS.WITHDRAW_FEE_PERCENT,
                    MIN_DEPOSIT_AMOUNT: GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT,
                    REFERRAL_REWARD_PERCENT: GAME_CONSTANTS.REFERRAL_REWARD_PERCENT,
                    MIN_ORDER_AMOUNT: GAME_CONSTANTS.MIN_ORDER_AMOUNT,
                    MARKET_FEE_PERCENT: GAME_CONSTANTS.MARKET_FEE_PERCENT,
                    TASK_REWARD: GAME_CONSTANTS.TASK_REWARD
                },
                
                referral: referralStats,
                market: marketStats,
                tasks: tasks,
                pendingDeposits: pendingDeposits
            }
        };
        
    } catch (error) {
        console.error('Get state error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_STATE_ERROR'
        };
    }
}
