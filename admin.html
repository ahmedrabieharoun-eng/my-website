// ============================================
// FARM ECONOMY WORKER v5.5 - COMPLETE RACE CONDITION FIX WITH ETAG & ORDER LOCKING
// FIXED: ALL operations now use atomicUpdateUserResource with ETag
// FIXED: ExecuteOrder now properly locks the order to prevent multiple executions
// ADDED: Max active orders limit (2 orders per user)
// ADDED: Total price input for sell orders
// ADDED: Leaderboard competition system (150 TON prizes based on cow ownership)
// FIXED: Leaderboard counter now uses global cows_sold statistic (same as main page progress bar)
// UPDATED: Leaderboard prizes distribution (40,30,20,10,8,6,5,4,3,3,2,2,2,2,2,2,2,2,2,1)
// ============================================

export default {
    async fetch(request, env, ctx) {
        // ===== CORS HANDLING =====
        if (request.method === 'OPTIONS') {
            return new Response(null, {
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Action, X-CSRF-Token, X-Idempotency-Key',
                    'Access-Control-Max-Age': '86400',
                }
            });
        }
        
        const url = new URL(request.url);
        const path = url.pathname;
        
        // ===== TON CONNECT MANIFEST =====
        if (path === '/tonconnect-manifest.json') {
            return new Response(JSON.stringify({
                url: "https://withdrw.vercel.app",
                name: "Crystal_Ranch_bot",
                iconUrl: "https://i.ibb.co/cfMm2bV/photo-5805343424280988997-c.jpg",
                description: "Crystal Ranch Game"
            }), {
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
        }
        
        // ===== HEALTH CHECK =====
        if (path === '/health') {
            return new Response(JSON.stringify({
                status: 'ok',
                timestamp: Date.now(),
                environment: env.ENVIRONMENT || 'production'
            }), {
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
        }
        
        // ===== MAIN API ENDPOINT =====
        if (path === '/api') {
            try {
                // === SECURITY ENHANCEMENTS ===
                const clientIp = request.headers.get('CF-Connecting-IP') || 'unknown';
                const rateLimitKey = `ratelimit:${clientIp}`;
                
                const idempotencyKey = request.headers.get('X-Idempotency-Key');
                if (idempotencyKey) {
                    const existingResult = await checkIdempotency(env, idempotencyKey);
                    if (existingResult) {
                        return new Response(JSON.stringify(existingResult), {
                            headers: { 
                                'Content-Type': 'application/json',
                                'Access-Control-Allow-Origin': '*'
                            }
                        });
                    }
                }
                
                const requestCount = await checkRateLimit(env, rateLimitKey);
                if (requestCount > 60) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Rate limit exceeded. Too many requests.',
                        errorCode: 'RATE_LIMIT_EXCEEDED'
                    }), {
                        status: 429,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const csrfToken = request.headers.get('X-CSRF-Token');
                const method = request.method;
                
                if (method === 'POST' && !isValidCsrfToken(csrfToken, env)) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Invalid CSRF token',
                        errorCode: 'CSRF_INVALID'
                    }), {
                        status: 403,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const rawBody = await request.text();
                const sanitizedBody = sanitizeInput(rawBody);
                const requestData = JSON.parse(sanitizedBody);
                
                const authHeader = request.headers.get('Authorization');
                
                if (!authHeader || !authHeader.startsWith('Telegram ')) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Telegram authentication required',
                        errorCode: 'AUTH_REQUIRED',
                        details: 'Missing Telegram authorization header'
                    }), {
                        status: 401,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const initData = authHeader.replace('Telegram ', '');
                
                const isDevelopment = env.ENVIRONMENT === 'development' || !env.BOT_TOKEN;
                let validationResult;
                
                if (isDevelopment) {
                    validationResult = await validateTelegramInitDataDev(initData, env.BOT_TOKEN);
                    console.log('Development mode: using simplified validation');
                } else {
                    validationResult = await validateTelegramInitData(initData, env.BOT_TOKEN);
                }
                
                if (!validationResult.valid) {
                    console.error('Telegram validation failed:', validationResult.error);
                    
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Invalid Telegram authentication',
                        errorCode: 'INVALID_TELEGRAM_AUTH',
                        details: validationResult.error,
                        debug: {
                            hasInitData: !!initData,
                            initDataLength: initData?.length,
                            botTokenConfigured: !!env.BOT_TOKEN,
                            environment: env.ENVIRONMENT || 'production'
                        }
                    }), {
                        status: 401,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const params = new URLSearchParams(initData);
                const userParam = params.get('user');
                
                if (!userParam) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'User data not found in Telegram init data',
                        errorCode: 'USER_DATA_MISSING'
                    }), {
                        status: 401,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                let userData;
                try {
                    userData = JSON.parse(decodeURIComponent(userParam));
                } catch (e) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Invalid user data format',
                        errorCode: 'INVALID_USER_DATA'
                    }), {
                        status: 401,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const userId = String(userData.id);
                const authDate = params.get('auth_date');
                
                console.log(`[${new Date().toISOString()}] ‚úÖ Valid Telegram auth - User: ${userId}, Auth Date: ${authDate || 'unknown'}, Env: ${env.ENVIRONMENT || 'production'}`);
                
                const action = request.headers.get('X-Action') || requestData.action;
                const data = requestData.data || {};
                
                console.log(`[${new Date().toISOString()}] Action: ${action}, User: ${userId}`);
                
                let result;
                
                switch (action) {
                    case 'getState':
                        result = await handleGetState(env, userId);
                        break;
                    
                    case 'buyCow':
                        result = await handleBuyCow(env, userId, data);
                        break;
                    case 'buyChicken':
                        result = await handleBuyChicken(env, userId, data);
                        break;
                    case 'buyDiamondEngine':
                        result = await handleBuyDiamondEngine(env, userId, data);
                        break;
                    
                    case 'hatchCow':
                        result = await handleHatchCow(env, userId, data);
                        break;
                    case 'hatchChicken':
                        result = await handleHatchChicken(env, userId, data);
                        break;
                    
                    case 'startDiamondProduction':
                        result = await handleStartDiamondProduction(env, userId, data);
                        break;
                    
                    case 'convertDiamond':
                        result = await handleConvertDiamond(env, userId, data);
                        break;
                    
                    case 'createSellOrder':
                        result = await handleCreateSellOrder(env, userId, data);
                        break;
                    case 'createBuyOrder':
                        result = await handleCreateBuyOrder(env, userId, data);
                        break;
                    case 'executeOrder':
                        result = await handleExecuteOrder(env, userId, data);
                        break;
                    case 'getMarketOrders':
                        result = await handleGetMarketOrders(env, data);
                        break;
                    case 'getMyOrders':
                        result = await handleGetMyOrders(env, userId);
                        break;
                    case 'cancelOrder':
                        result = await handleCancelOrder(env, userId, data);
                        break;
                    
                    case 'deposit':
                        result = await handleDeposit(env, userId, data);
                        break;
                    case 'verifyDeposit':
                        result = await handleVerifyDeposit(env, userId, data);
                        break;
                    
                    case 'withdraw':
                        result = await handleWithdraw(env, userId, data);
                        break;
                    
                    case 'claimReferralEarnings':
                        result = await handleClaimReferralEarnings(env, userId);
                        break;
                    case 'getReferralInfo':
                        result = await handleGetReferralInfo(env, userId);
                        break;
                    
                    case 'initializeUser':
                        result = await handleInitializeUser(env, userId, data);
                        break;
                    
                    case 'setLanguage':
                        result = await handleSetLanguage(env, userId, data);
                        break;
                    
                    case 'createTask':
                        result = await handleCreateTask(env, userId, data);
                        break;
                    case 'verifyTask':
                        result = await handleVerifyTask(env, userId, data);
                        break;
                    case 'getTasks':
                        result = await handleGetTasks(env, userId);
                        break;
                    
                    // ===== LEADERBOARD ACTIONS =====
                    case 'getLeaderboard':
                        result = await handleGetLeaderboard(env, userId);
                        break;
                    case 'distributeLeaderboardPrizes':
                        result = await handleDistributeLeaderboardPrizes(env, userId);
                        break;
                    
                    default:
                        result = {
                            success: false,
                            error: 'Unknown action',
                            errorCode: 'UNKNOWN_ACTION'
                        };
                }
                
                if (idempotencyKey && result.success) {
                    await saveIdempotencyResult(env, idempotencyKey, result);
                }
                
                return new Response(JSON.stringify(result), {
                    headers: {
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
                
            } catch (error) {
                console.error(`Worker Error: ${error.message}`, error.stack);
                
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Internal server error',
                    errorCode: 'INTERNAL_SERVER_ERROR',
                    message: error.message
                }), {
                    status: 500,
                    headers: { 
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
            }
        }
        
        return new Response(JSON.stringify({
            success: false,
            error: 'Endpoint not found'
        }), {
            status: 404,
            headers: { 'Content-Type': 'application/json' }
        });
    }
};

// ============================================
// IDEMPOTENCY FUNCTIONS
// ============================================

async function checkIdempotency(env, key) {
    try {
        const result = await dbGet(env, `idempotency/${key}`);
        if (result.success && result.data) {
            return result.data;
        }
        return null;
    } catch (error) {
        console.error('Idempotency check error:', error);
        return null;
    }
}

async function saveIdempotencyResult(env, key, result) {
    try {
        await dbSet(env, `idempotency/${key}`, {
            result: result,
            timestamp: Date.now()
        });
        
        setTimeout(async () => {
            await dbDelete(env, `idempotency/${key}`);
        }, 24 * 60 * 60 * 1000);
        
    } catch (error) {
        console.error('Save idempotency error:', error);
    }
}

// ============================================
// SECURITY FUNCTIONS
// ============================================

async function checkRateLimit(env, key) {
    return 0;
}

function isValidCsrfToken(token, env) {
    if (!env.CSRF_SECRET) return true;
    if (!token) return false;
    const expected = generateCsrfToken(env);
    return token === expected;
}

function generateCsrfToken(env) {
    return 'fixed-csrf-token-for-demo';
}

function sanitizeInput(input) {
    if (!input) return input;
    let sanitized = input.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
    sanitized = sanitized.replace(/[<>]/g, function(match) {
        return match === '<' ? '&lt;' : '&gt;';
    });
    return sanitized;
}

// ============================================
// GAME CONSTANTS
// ============================================

const GAME_CONSTANTS = {
    COW_PRICE: 1,
    COW_GLOBAL_CAP: 1000,
    COW_PRODUCTION_RATE: 41,
    COW_HATCH_COST: 5000,
    
    CHICKEN_PRICE: 1,
    CHICKEN_GLOBAL_CAP: 1000,
    CHICKEN_PRODUCTION_RATE: 41,
    CHICKEN_HATCH_COST: 5000,
    
    DIAMOND_ENGINE_PRICE: 20,
    DIAMOND_PRODUCTION_COST_MILK: 20000,
    DIAMOND_PRODUCTION_COST_EGG: 20000,
    DIAMOND_PRODUCTION_YIELD: 1,
    DIAMOND_BASE_PRICE: 25,
    
    MIN_ORDER_AMOUNT: 100,
    MAX_ACTIVE_ORDERS: 2, // Maximum 2 active orders per user
    MARKET_FEE_PERCENT: 10,
    MIN_ORDER_PRICE: 0.0002, // Minimum price per unit to avoid penalty
    ORDER_PENALTY_FEE: 0.2, // Penalty fee for orders below minimum price
    
    MIN_WITHDRAW_AMOUNT: 0.1,
    WITHDRAW_FEE_PERCENT: 5,
    
    MIN_DEPOSIT_AMOUNT: 0.1,
    
    REFERRAL_REWARD_PERCENT: 10,
    
    HOUR_IN_MS: 3600000,
    
    TASK_REWARD: 0.001,
    MIN_TASK_TARGET: 100,
    MAX_TASK_DURATION_DAYS: 30,
    
    MAX_RETRY_ATTEMPTS: 3,
    RETRY_DELAY_MS: 100,
    
    // ===== LEADERBOARD CONSTANTS - UPDATED PRIZES =====
    LEADERBOARD_COW_CAP: 1000,
    LEADERBOARD_TOTAL_PRIZE: 150,
    LEADERBOARD_PRIZES: {
        1: 40,
        2: 30,
        3: 20,
        4: 10,
        5: 8,
        6: 6,
        7: 5,
        8: 4,
        9: 3,
        10: 3,
        11: 2,
        12: 2,
        13: 2,
        14: 2,
        15: 2,
        16: 2,
        17: 2,
        18: 2,
        19: 2,
        20: 1
    }
};

const PARTNER_TASKS = [
    {
        id: 'partner_news_channel',
        type: 'channel',
        link: 'https://t.me/earnmoney139482',
        name: 'News Channel',
        reward: 0.02,
        targetUsers: 1000000,
        completions: 0,
        completedBy: [],
        status: 'active',
        createdAt: Date.now(),
        expiresAt: Date.now() + (365 * 24 * 60 * 60 * 1000)
    },
    {
        id: 'partner_support_channel',
        type: 'channel',
        link: 'https://t.me/Crystal_Ranch_chat',
        name: 'Chat & Support',
        reward: 0.02,
        targetUsers: 1000000,
        completions: 0,
        completedBy: [],
        status: 'active',
        createdAt: Date.now(),
        expiresAt: Date.now() + (365 * 24 * 60 * 60 * 1000)
    }
];

const ADMIN_IDS = ['123456789', '987654321'];

// ============================================
// LEADERBOARD FUNCTIONS - FIXED TO USE GLOBAL COW SALES
// ============================================

async function initializeLeaderboard(env) {
    try {
        const leaderboardResult = await dbGet(env, 'leaderboard');
        
        if (!leaderboardResult.success || !leaderboardResult.data) {
            const now = Date.now();
            await dbSet(env, 'leaderboard', {
                isActive: true,
                endedAt: null,
                prizesDistributed: false,
                lastUpdated: now,
                createdAt: now
            });
        }
        
        const winnersResult = await dbGet(env, 'leaderboard_winners');
        if (!winnersResult.success || !winnersResult.data) {
            await dbSet(env, 'leaderboard_winners', {});
        }
        
    } catch (error) {
        console.error('Initialize leaderboard error:', error);
    }
}

async function updateLeaderboard(env, userId, oldCowCount, newCowCount) {
    try {
        const leaderboardResult = await dbGet(env, 'leaderboard');
        if (!leaderboardResult.success || !leaderboardResult.data) {
            await initializeLeaderboard(env);
        }
        
        const leaderboard = leaderboardResult.data || { isActive: true };
        
        if (!leaderboard.isActive) {
            return null;
        }
        
        const cowsResult = await dbGet(env, 'leaderboard_cows');
        let cowsData = cowsResult.success ? cowsResult.data || {} : {};
        
        const now = Date.now();
        const currentCowCount = newCowCount;
        const previousCowCount = oldCowCount;
        
        const userRecord = cowsData[userId] || {
            userId: userId,
            cowCount: 0,
            achievedAt: now,
            firstName: '',
            lastName: '',
            username: '',
            photoUrl: ''
        };
        
        const userResult = await dbGet(env, `users/${userId}`);
        if (userResult.success && userResult.data) {
            userRecord.firstName = userResult.data.firstName || '';
            userRecord.lastName = userResult.data.lastName || '';
            userRecord.username = userResult.data.username || '';
            userRecord.photoUrl = userResult.data.photoUrl || '';
        }
        
        if (currentCowCount > previousCowCount) {
            userRecord.cowCount = currentCowCount;
            userRecord.achievedAt = now;
            
            await dbSet(env, `leaderboard_cows/${userId}`, userRecord);
            
            // ÿ™ÿ≠ÿØŸäÿ´ ŸàŸÇÿ™ ÿ¢ÿÆÿ± ÿ™ÿ≠ÿØŸäÿ´ ŸÅŸÇÿ∑ÿå ŸÑÿß ŸÜÿπÿØŸÑ totalCowSales ŸáŸÜÿß
            await dbUpdate(env, 'leaderboard', {
                lastUpdated: now
            });
        }
        
        return userRecord;
        
    } catch (error) {
        console.error('Update leaderboard error:', error);
        return null;
    }
}

async function getLeaderboardData(env, currentUserId) {
    try {
        await initializeLeaderboard(env);
        
        const leaderboardResult = await dbGet(env, 'leaderboard');
        const cowsResult = await dbGet(env, 'leaderboard_cows');
        const globalResult = await dbGet(env, 'global'); // ŸÜÿ¨ŸÑÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿπÿßŸÑŸÖŸäÿ©
        
        let leaderboard = leaderboardResult.data || { 
            isActive: true, 
            prizesDistributed: false 
        };
        let cowsData = cowsResult.success ? cowsResult.data || {} : {};
        let global = globalResult.success ? globalResult.data : { cows_sold: 0 }; // ŸÜÿ£ÿÆÿ∞ cows_sold ŸÖŸÜ global
        
        // ŸÜÿ≥ÿ™ÿÆÿØŸÖ cows_sold ŸÖŸÜ global ÿ®ÿØŸÑÿßŸã ŸÖŸÜ leaderboard.totalCowSales
        const totalCowSales = global.cows_sold || 0;
        
        const usersArray = Object.values(cowsData);
        
        usersArray.sort((a, b) => {
            if (b.cowCount !== a.cowCount) {
                return b.cowCount - a.cowCount;
            }
            return (a.achievedAt || 0) - (b.achievedAt || 0);
        });
        
        const rankedUsers = usersArray.map((user, index) => ({
            rank: index + 1,
            userId: user.userId,
            firstName: user.firstName || '',
            lastName: user.lastName || '',
            username: user.username || '',
            photoUrl: user.photoUrl || '',
            cowCount: user.cowCount || 0,
            points: user.cowCount || 0,
            prize: leaderboard.isActive ? 
                (index < 20 ? GAME_CONSTANTS.LEADERBOARD_PRIZES[index + 1] || 0 : 0) : 
                (user.prizeAwarded || 0)
        }));
        
        const currentUserEntry = rankedUsers.find(u => u.userId === currentUserId) || {
            rank: rankedUsers.length + 1,
            cowCount: 0,
            points: 0,
            prize: 0
        };
        
        const winnersResult = await dbGet(env, 'leaderboard_winners');
        const winners = winnersResult.success ? winnersResult.data || {} : {};
        
        return {
            success: true,
            data: {
                isActive: leaderboard.isActive,
                totalCowSales: totalCowSales, // ÿßŸÑÿ¢ŸÜ Ÿäÿ≥ÿ™ÿÆÿØŸÖ global.cows_sold
                cowCap: GAME_CONSTANTS.LEADERBOARD_COW_CAP,
                remainingCows: Math.max(0, GAME_CONSTANTS.LEADERBOARD_COW_CAP - totalCowSales),
                leaderboard: rankedUsers.slice(0, 100),
                currentUser: currentUserEntry,
                prizesDistributed: leaderboard.prizesDistributed || false,
                winners: winners
            }
        };
        
    } catch (error) {
        console.error('Get leaderboard error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'LEADERBOARD_ERROR'
        };
    }
}

async function finalizeLeaderboard(env) {
    try {
        const leaderboardResult = await dbGet(env, 'leaderboard');
        const cowsResult = await dbGet(env, 'leaderboard_cows');
        const globalResult = await dbGet(env, 'global');
        
        if (!leaderboardResult.success || !leaderboardResult.data) {
            return null;
        }
        
        const leaderboard = leaderboardResult.data;
        
        if (!leaderboard.isActive || leaderboard.prizesDistributed) {
            return leaderboard;
        }
        
        let cowsData = cowsResult.success ? cowsResult.data || {} : {};
        let global = globalResult.success ? globalResult.data : { cows_sold: 0 };
        
        const usersArray = Object.values(cowsData);
        
        usersArray.sort((a, b) => {
            if (b.cowCount !== a.cowCount) {
                return b.cowCount - a.cowCount;
            }
            return (a.achievedAt || 0) - (b.achievedAt || 0);
        });
        
        const winners = {};
        const now = Date.now();
        
        for (let i = 0; i < Math.min(20, usersArray.length); i++) {
            const user = usersArray[i];
            const rank = i + 1;
            const prize = GAME_CONSTANTS.LEADERBOARD_PRIZES[rank] || 0;
            
            if (prize > 0) {
                winners[user.userId] = {
                    rank: rank,
                    prize: prize,
                    cowCount: user.cowCount,
                    awardedAt: now,
                    firstName: user.firstName || '',
                    lastName: user.lastName || '',
                    username: user.username || ''
                };
                
                const userResult = await dbGet(env, `users/${user.userId}`);
                if (userResult.success && userResult.data) {
                    const currentTon = parseFloat(userResult.data.tonBalance || 0);
                    await atomicUpdateUserResource(env, user.userId, 'tonBalance', -prize);
                    
                    await dbPush(env, `users/${user.userId}/transactions`, {
                        type: 'leaderboard_prize',
                        rank: rank,
                        amount: prize,
                        timestamp: now
                    });
                }
            }
        }
        
        await dbSet(env, 'leaderboard_winners', winners);
        
        await dbUpdate(env, 'leaderboard', {
            isActive: false,
            prizesDistributed: true,
            endedAt: now,
            winners: winners,
            lastUpdated: now
        });
        
        return {
            winners: winners,
            finalizedAt: now
        };
        
    } catch (error) {
        console.error('Finalize leaderboard error:', error);
        return null;
    }
}

async function handleGetLeaderboard(env, userId) {
    return await getLeaderboardData(env, userId);
}

async function handleDistributeLeaderboardPrizes(env, userId) {
    if (!ADMIN_IDS.includes(userId)) {
        return {
            success: false,
            error: 'Unauthorized',
            errorCode: 'UNAUTHORIZED'
        };
    }
    
    try {
        const result = await finalizeLeaderboard(env);
        
        if (!result) {
            return {
                success: false,
                error: 'Failed to finalize leaderboard',
                errorCode: 'FINALIZE_FAILED'
            };
        }
        
        return {
            success: true,
            data: result
        };
        
    } catch (error) {
        console.error('Distribute prizes error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DISTRIBUTE_ERROR'
        };
    }
}

// ============================================
// CHECK MAX ACTIVE ORDERS (LIMIT 2)
// ============================================

async function checkUserActiveOrders(env, userId) {
    try {
        const ordersResult = await dbGet(env, `users/${userId}/orders`);
        
        if (!ordersResult.success || !ordersResult.data) {
            return {
                success: true,
                activeCount: 0,
                activeOrders: []
            };
        }
        
        const orders = ordersResult.data;
        const activeOrders = [];
        
        for (const [orderId, order] of Object.entries(orders)) {
            if (order.status === 'active') {
                activeOrders.push({
                    id: orderId,
                    ...order
                });
            }
        }
        
        return {
            success: true,
            activeCount: activeOrders.length,
            activeOrders: activeOrders
        };
        
    } catch (error) {
        console.error('Check user active orders error:', error);
        return {
            success: false,
            error: error.message,
            activeCount: 0,
            activeOrders: []
        };
    }
}

// ============================================
// TELEGRAM VALIDATION
// ============================================

async function validateTelegramInitData(initData, botToken) {
    try {
        if (!initData || !botToken) {
            return {
                valid: false,
                error: !initData ? 'No init data provided' : 'Bot token not configured'
            };
        }

        const params = new URLSearchParams(initData);
        const hash = params.get('hash');
        
        if (!hash) {
            return {
                valid: false,
                error: 'No hash parameter in init data'
            };
        }

        params.delete('hash');
        
        const sortedKeys = Array.from(params.keys()).sort();
        let dataCheckArray = [];
        
        for (const key of sortedKeys) {
            dataCheckArray.push(`${key}=${params.get(key)}`);
        }
        
        const dataCheckString = dataCheckArray.join('\n');
        
        const encoder = new TextEncoder();
        
        const secretKeyMaterial = await crypto.subtle.importKey(
            'raw',
            encoder.encode('WebAppData'),
            { name: 'HMAC', hash: 'SHA-256' },
            false,
            ['sign']
        );
        
        const secretKey = await crypto.subtle.sign(
            'HMAC',
            secretKeyMaterial,
            encoder.encode(botToken)
        );
        
        const hmacKey = await crypto.subtle.importKey(
            'raw',
            secretKey,
            { name: 'HMAC', hash: 'SHA-256' },
            false,
            ['sign']
        );
        
        const signature = await crypto.subtle.sign(
            'HMAC',
            hmacKey,
            encoder.encode(dataCheckString)
        );
        
        const hashHex = Array.from(new Uint8Array(signature))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
        
        const isValid = hashHex.toLowerCase() === hash.toLowerCase();
        
        const authDate = params.get('auth_date');
        if (authDate) {
            const authTimestamp = parseInt(authDate) * 1000;
            const now = Date.now();
            const oneDayMs = 24 * 60 * 60 * 1000;
            
            if (now - authTimestamp > oneDayMs) {
                console.warn('Telegram auth data is older than 24 hours');
            }
        }
        
        if (!isValid) {
            console.error('Hash validation failed');
            console.error('Expected:', hashHex);
            console.error('Received:', hash);
            console.error('Data string:', dataCheckString);
            
            return {
                valid: false,
                error: 'Hash validation failed - data tampered'
            };
        }
        
        return {
            valid: true,
            hash: hashHex,
            authDate: params.get('auth_date')
        };
        
    } catch (error) {
        console.error('Telegram validation error:', error);
        return {
            valid: false,
            error: `Validation error: ${error.message}`
        };
    }
}

async function validateTelegramInitDataDev(initData, botToken) {
    try {
        if (!initData) {
            return { valid: false, error: 'No init data' };
        }
        
        const params = new URLSearchParams(initData);
        const userParam = params.get('user');
        const hash = params.get('hash');
        
        if (!userParam) {
            return { valid: false, error: 'No user data' };
        }
        
        try {
            JSON.parse(decodeURIComponent(userParam));
        } catch (e) {
            return { valid: false, error: 'Invalid user data format' };
        }
        
        return { 
            valid: true, 
            hash: hash || 'dev-mode',
            devMode: true 
        };
        
    } catch (error) {
        return { valid: false, error: error.message };
    }
}

// ============================================
// TELEGRAM CHANNEL VERIFICATION
// ============================================

async function checkTelegramMembership(env, userId, channelUsername) {
    try {
        if (!env.BOT_TOKEN) {
            console.log('No bot token, skipping channel verification');
            return true;
        }
        
        let username = channelUsername;
        if (channelUsername.includes('t.me/')) {
            username = channelUsername.split('t.me/')[1].split('?')[0].split('/')[0];
        }
        if (username.startsWith('@')) {
            username = username.substring(1);
        }
        
        const url = `https://api.telegram.org/bot${env.BOT_TOKEN}/getChatMember`;
        
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: `@${username}`,
                user_id: parseInt(userId)
            })
        });
        
        const result = await response.json();
        
        if (!result.ok) {
            console.error('Telegram API error:', result);
            return false;
        }
        
        const status = result.result?.status;
        const isMember = ['member', 'administrator', 'creator'].includes(status);
        
        return isMember;
        
    } catch (error) {
        console.error('Channel verification error:', error);
        return false;
    }
}

// ============================================
// DATABASE OPERATIONS - FIREBASE REST API
// ============================================

async function getFirebaseUrl(env, path) {
    const baseUrl = env.FIREBASE_DATABASE_URL?.replace(/\/$/, '');
    if (!baseUrl) {
        throw new Error('FIREBASE_DATABASE_URL is not configured');
    }
    
    const cleanPath = path.replace(/^\//, '');
    const apiKey = env.FIREBASE_API_KEY;
    
    if (!apiKey) {
        throw new Error('FIREBASE_API_KEY is not configured');
    }
    
    return `${baseUrl}/${cleanPath}.json?key=${apiKey}`;
}

async function dbGet(env, path) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase GET error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        const data = await response.json();
        
        return {
            success: true,
            data: data
        };
    } catch (error) {
        console.error(`DB GET Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_GET_ERROR'
        };
    }
}

async function dbSet(env, path, data) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase SET error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error(`DB SET Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_SET_ERROR'
        };
    }
}

async function dbUpdate(env, path, updates) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updates)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase UPDATE error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error(`DB UPDATE Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_UPDATE_ERROR'
        };
    }
}

async function dbPush(env, path, data) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase PUSH error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: { id: result.name }
        };
    } catch (error) {
        console.error(`DB PUSH Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_PUSH_ERROR'
        };
    }
}

async function dbDelete(env, path) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url, {
            method: 'DELETE'
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase DELETE error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        return {
            success: true
        };
    } catch (error) {
        console.error(`DB DELETE Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_DELETE_ERROR'
        };
    }
}

// ============================================
// ATOMIC UPDATE FUNCTION - ENHANCED WITH ETAG
// ============================================

async function atomicUpdateUserResource(env, userId, resource, deductAmount) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;

    const baseUrl = env.FIREBASE_DATABASE_URL?.replace(/\/$/, '');
    const apiKey = env.FIREBASE_API_KEY;

    if (!baseUrl || !apiKey) {
        return { 
            success: false, 
            error: 'Firebase configuration missing',
            errorCode: 'FIREBASE_CONFIG_MISSING' 
        };
    }

    const resourcePath = `users/${userId}/${resource}.json?key=${apiKey}`;

    while (attempt < maxAttempts) {
        try {
            const getResponse = await fetch(`${baseUrl}/${resourcePath}`, {
                method: 'GET',
                headers: {
                    'X-Firebase-ETag': 'true'
                }
            });

            if (!getResponse.ok) {
                const errorText = await getResponse.text();
                throw new Error(`Failed to fetch current balance: ${getResponse.status} ${errorText.substring(0, 100)}`);
            }

            const etag = getResponse.headers.get('ETag');
            if (!etag) {
                throw new Error('ETag not returned by Firebase');
            }

            const currentBalance = await getResponse.json();
            const currentValue = currentBalance === null ? 0 : parseFloat(currentBalance);

            if (deductAmount > 0 && currentValue < deductAmount) {
                return {
                    success: false,
                    error: `Insufficient ${resource}`,
                    errorCode: 'INSUFFICIENT_RESOURCE',
                    currentBalance: currentValue,
                    required: deductAmount
                };
            }

            const newBalance = currentValue - deductAmount;

            const putResponse = await fetch(`${baseUrl}/${resourcePath}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'If-Match': etag
                },
                body: JSON.stringify(newBalance)
            });

            if (putResponse.status === 412) {
                attempt++;
                if (attempt < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                    continue;
                } else {
                    return {
                        success: false,
                        error: 'Resource changed during operation',
                        errorCode: 'RACE_CONDITION_DETECTED',
                        currentBalance: currentValue
                    };
                }
            }

            if (!putResponse.ok) {
                const errorText = await putResponse.text();
                throw new Error(`Atomic update failed: ${putResponse.status} ${errorText.substring(0, 100)}`);
            }

            return {
                success: true,
                data: {
                    newBalance: newBalance,
                    oldBalance: currentValue,
                    deducted: deductAmount
                }
            };

        } catch (error) {
            console.error(`Atomic update error (attempt ${attempt + 1}):`, error);
            attempt++;
            
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'ATOMIC_UPDATE_ERROR'
                };
            }
        }
    }

    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

// ============================================
// NOTIFICATION FUNCTIONS
// ============================================

async function sendTelegramNotification(env, userId, message) {
    try {
        if (!env.BOT_TOKEN) {
            console.log('No bot token configured, skipping notification');
            return false;
        }
        
        const url = `https://api.telegram.org/bot${env.BOT_TOKEN}/sendMessage`;
        
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: userId,
                text: message,
                parse_mode: 'HTML'
            })
        });
        
        const result = await response.json();
        return result.ok;
    } catch (error) {
        console.error('Failed to send notification:', error);
        return false;
    }
}

async function notifyOrderFilled(env, userId, order, quantity, totalTon, fee = 0) {
    const resourceEmoji = order.resource === 'milk' ? 'ü•õ' : 'ü•ö';
    const resourceName = order.resource === 'milk' ? 'MILK' : 'EGG';
    const netAmount = order.type === 'sell' ? totalTon - fee : totalTon;
    
    let message = '';
    
    if (order.type === 'sell') {
        message = `üéâ <b>Order Sold!</b>\n\nYour sell order for ${formatNumber(quantity)} ${resourceEmoji} ${resourceName} has been filled!\n\nüí∞ You received: ${formatTON(netAmount)} TON`;
        if (fee > 0) {
            message += `\nüìâ Fee (10%): ${formatTON(fee)} TON`;
        }
        message += `\nüì¶ Order ID: #${order.id.substring(0, 6)}`;
    } else {
        message = `üéâ <b>Order Filled!</b>\n\nYour buy order for ${formatNumber(quantity)} ${resourceEmoji} ${resourceName} has been filled!\n\nüì¶ Order ID: #${order.id.substring(0, 6)}`;
    }
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyMachinePurchase(env, userId, machineType) {
    const machineEmoji = machineType === 'cow' ? 'üêÆ' : machineType === 'chicken' ? 'üêî' : 'üíé';
    const machineName = machineType === 'cow' ? 'Cow' : machineType === 'chicken' ? 'Chicken' : 'Crystal Engine';
    
    const message = `üéâ <b>Purchase Successful!</b>\n\nYou just bought a ${machineName} Machine ${machineEmoji}!\n\nStart producing resources now! üöÄ`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyReferralReward(env, userId, amount, referrerName) {
    const message = `üéÅ <b>Referral Reward!</b>\n\nYour referral ${referrerName || 'friend'} just purchased a machine!\n\nüíé You received: ${formatTON(amount)} TON\n\nKeep sharing your link to earn more! üöÄ`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyDepositSuccess(env, userId, amount) {
    const message = `üí∞ <b>Deposit Successful!</b>\n\nYour deposit of ${formatTON(amount)} TON has been confirmed and added to your balance.\n\nHappy farming! üöú`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyTaskCompleted(env, userId, taskType, reward) {
    const message = `‚úÖ <b>Task Completed!</b>\n\nYou have successfully completed the ${taskType === 'channel' ? 'üì¢ Channel' : 'ü§ñ Bot'} task!\n\nüí∞ Reward: ${formatTON(reward)} TON added to your balance.\n\nKeep completing tasks to earn more! üöÄ`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyTaskCreated(env, userId, taskType, targetUsers, totalCost) {
    const message = `üì¢ <b>Task Created!</b>\n\nYour ${taskType === 'channel' ? 'üì¢ Channel' : 'ü§ñ Bot'} task has been created successfully!\n\nüë• Target: ${targetUsers} users\nüí∞ Total Cost: ${formatTON(totalCost)} TON\n\nIt will appear in Community Tasks section. üöÄ`;
    
    await sendTelegramNotification(env, userId, message);
}

function formatNumber(num) {
    if (num === null || num === undefined) return '0';
    if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num.toString();
}

function formatTON(amount) {
    if (amount === null || amount === undefined) return '0.0000';
    return parseFloat(amount).toFixed(4);
}

// ============================================
// INITIALIZATION FUNCTIONS
// ============================================

async function initializeGlobalState(env) {
    const now = Date.now();
    
    const initialState = {
        cows_sold: 0,
        chickens_sold: 0,
        diamond_price: GAME_CONSTANTS.DIAMOND_BASE_PRICE,
        createdAt: now,
        updatedAt: now
    };
    
    await dbSet(env, 'global', initialState);
    return initialState;
}

function generateReferralCode(userId) {
    return `ref_${userId}`;
}

function extractReferrerFromStartParam(startParam) {
    if (!startParam) return null;
    
    if (startParam.startsWith('ref_')) {
        const referrerId = startParam.replace('ref_', '');
        if (!isNaN(parseInt(referrerId))) {
            return referrerId;
        }
    }
    return null;
}

async function initializeUser(env, userId, userInfo = {}, startParam = null) {
    const now = Date.now();
    
    const referredBy = extractReferrerFromStartParam(startParam);
    const referralCode = generateReferralCode(userId);
    
    const userData = {
        tonBalance: 0,
        milk: 0,
        eggs: 0,
        diamond: 0,
        
        cows_owned: 0,
        chickens_owned: 0,
        diamond_engines_owned: 0,
        
        lastProduction: now,
        
        referralCode: referralCode,
        referredBy: referredBy,
        referralEarnings: 0,
        referralEarningsClaimed: 0,
        
        firstName: userInfo.first_name || '',
        lastName: userInfo.last_name || '',
        username: userInfo.username || '',
        photoUrl: userInfo.photo_url || '',
        
        language: 'en',
        
        completedTasks: [],
        
        createdAt: now,
        updatedAt: now
    };
    
    await dbSet(env, `users/${userId}`, userData);
    
    if (referredBy) {
        await recordReferral(env, referredBy, userId, userData);
    }
    
    return userData;
}

async function recordReferral(env, referrerId, newUserId, newUserData) {
    const now = Date.now();
    
    const referralRecord = {
        userId: newUserId,
        firstName: newUserData.firstName || 'Farmer',
        lastName: newUserData.lastName || '',
        username: newUserData.username || '',
        photoUrl: newUserData.photoUrl || '',
        joinedAt: now,
        totalEarnedFromThisUser: 0,
        lastPurchase: null
    };
    
    await dbSet(env, `users/${referrerId}/referrals/${newUserId}`, referralRecord);
    
    await sendTelegramNotification(
        env,
        referrerId,
        `üéâ <b>New Referral!</b>\n\n${newUserData.firstName || 'A new farmer'} just joined using your link!\n\nYou'll earn 10% commission on their purchases. üöÄ`
    );
}

async function updateReferralEarnings(env, referrerId, referredUserId, purchaseAmount, purchaseType) {
    const now = Date.now();
    
    const commission = purchaseAmount * (GAME_CONSTANTS.REFERRAL_REWARD_PERCENT / 100);
    
    const referrerResult = await dbGet(env, `users/${referrerId}`);
    if (!referrerResult.success || !referrerResult.data) {
        console.error('Referrer not found:', referrerId);
        return null;
    }
    
    const referrer = referrerResult.data;
    
    const currentEarnings = parseFloat(referrer.referralEarnings || 0);
    const newEarnings = currentEarnings + commission;
    
    const tonUpdate = await atomicUpdateUserResource(env, referrerId, 'tonBalance', -commission);
    if (!tonUpdate.success) {
        console.error('Failed to update referrer TON balance:', tonUpdate.error);
        return null;
    }
    
    await dbUpdate(env, `users/${referrerId}`, {
        referralEarnings: newEarnings,
        updatedAt: now
    });
    
    const referredUserResult = await dbGet(env, `users/${referredUserId}`);
    let referredUserInfo = {};
    if (referredUserResult.success && referredUserResult.data) {
        referredUserInfo = referredUserResult.data;
    }
    
    const referralRecordResult = await dbGet(env, `users/${referrerId}/referrals/${referredUserId}`);
    if (referralRecordResult.success && referralRecordResult.data) {
        const currentTotal = parseFloat(referralRecordResult.data.totalEarnedFromThisUser || 0);
        
        await dbUpdate(env, `users/${referrerId}/referrals/${referredUserId}`, {
            totalEarnedFromThisUser: currentTotal + commission,
            lastPurchase: {
                amount: purchaseAmount,
                commission: commission,
                type: purchaseType,
                timestamp: now
            },
            firstName: referredUserInfo.firstName || referralRecordResult.data.firstName,
            lastName: referredUserInfo.lastName || '',
            username: referredUserInfo.username || '',
            photoUrl: referredUserInfo.photoUrl || ''
        });
    }
    
    await dbPush(env, `users/${referrerId}/referralEarnings`, {
        userId: referredUserId,
        amount: commission,
        type: purchaseType,
        purchaseAmount: purchaseAmount,
        timestamp: now,
        firstName: referredUserInfo.firstName || 'Farmer',
        username: referredUserInfo.username || ''
    });
    
    const buyerName = referredUserInfo.firstName || referredUserInfo.username || 'Your referral';
    await notifyReferralReward(env, referrerId, commission, buyerName);
    
    return commission;
}

// ============================================
// PRODUCTION CALCULATION
// ============================================

async function calculateProduction(env, userId, user = null) {
    try {
        if (!user) {
            const userResult = await dbGet(env, `users/${userId}`);
            
            if (!userResult.success || !userResult.data) {
                return null;
            }
            
            user = userResult.data;
        }
        
        const now = Date.now();
        const lastProduction = user.lastProduction || now;
        
        const msPassed = now - lastProduction;
        const hoursPassed = Math.floor(msPassed / GAME_CONSTANTS.HOUR_IN_MS);
        
        if (hoursPassed <= 0) {
            return {
                user: user,
                hoursPassed: 0,
                milkProduced: 0,
                eggsProduced: 0
            };
        }
        
        const milkProduced = (user.cows_owned || 0) * GAME_CONSTANTS.COW_PRODUCTION_RATE * hoursPassed;
        const eggsProduced = (user.chickens_owned || 0) * GAME_CONSTANTS.CHICKEN_PRODUCTION_RATE * hoursPassed;
        
        const updates = {
            milk: (user.milk || 0) + milkProduced,
            eggs: (user.eggs || 0) + eggsProduced,
            lastProduction: lastProduction + (hoursPassed * GAME_CONSTANTS.HOUR_IN_MS),
            updatedAt: now
        };
        
        await dbUpdate(env, `users/${userId}`, updates);
        
        const updatedUser = {
            ...user,
            ...updates
        };
        
        return {
            user: updatedUser,
            hoursPassed: hoursPassed,
            milkProduced: milkProduced,
            eggsProduced: eggsProduced
        };
        
    } catch (error) {
        console.error('Production calculation error:', error);
        return null;
    }
}

// ============================================
// MACHINE PURCHASES - ALL FIXED WITH ATOMIC UPDATES
// ============================================

async function handleBuyCow(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { quantity = 1 } = data;
            const buyQuantity = parseInt(quantity);
            
            if (buyQuantity <= 0) {
                return {
                    success: false,
                    error: 'Invalid quantity',
                    errorCode: 'INVALID_QUANTITY'
                };
            }
            
            const userResult = await dbGet(env, `users/${userId}`);
            const globalResult = await dbGet(env, 'global');
            
            if (!userResult.success || !globalResult.success) {
                return {
                    success: false,
                    error: 'Failed to load game state',
                    errorCode: 'STATE_LOAD_ERROR'
                };
            }
            
            let user = userResult.data;
            let global = globalResult.data;
            
            if (!global) {
                global = await initializeGlobalState(env);
            }
            
            if (!user) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            const productionResult = await calculateProduction(env, userId, user);
            
            if (productionResult) {
                user = productionResult.user;
            }
            
            const cowsRemaining = GAME_CONSTANTS.COW_GLOBAL_CAP - (global.cows_sold || 0);
            if (cowsRemaining < buyQuantity) {
                return {
                    success: false,
                    error: `Only ${cowsRemaining} Cow machines left`,
                    errorCode: 'INSUFFICIENT_GLOBAL_SUPPLY'
                };
            }
            
            const totalPrice = GAME_CONSTANTS.COW_PRICE * buyQuantity;
            
            const atomicResult = await atomicUpdateUserResource(
                env,
                userId,
                'tonBalance',
                totalPrice
            );
            
            if (!atomicResult.success) {
                if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId} (buyCow), retry attempt ${attempt}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else if (atomicResult.errorCode === 'INSUFFICIENT_RESOURCE') {
                    return {
                        success: false,
                        error: `Insufficient TON balance. Need ${totalPrice} TON`,
                        errorCode: 'INSUFFICIENT_TON',
                        currentBalance: atomicResult.currentBalance
                    };
                } else {
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode || 'ATOMIC_UPDATE_FAILED'
                    };
                }
            }
            
            const userUpdates = {
                cows_owned: (user.cows_owned || 0) + buyQuantity,
                updatedAt: Date.now()
            };
            
            const globalUpdates = {
                cows_sold: (global.cows_sold || 0) + buyQuantity,
                updatedAt: Date.now()
            };
            
            await dbUpdate(env, `users/${userId}`, userUpdates);
            await dbUpdate(env, 'global', globalUpdates);
            
            // Update leaderboard
            await updateLeaderboard(env, userId, user.cows_owned || 0, (user.cows_owned || 0) + buyQuantity);
            
            let referralCommission = 0;
            if (user.referredBy && (user.cows_owned === 0)) {
                referralCommission = await updateReferralEarnings(
                    env, 
                    user.referredBy, 
                    userId, 
                    totalPrice, 
                    'cow_purchase'
                );
            }
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'buy_cow',
                quantity: buyQuantity,
                amount: totalPrice,
                payment: 'TON',
                timestamp: Date.now()
            });
            
            await notifyMachinePurchase(env, userId, 'cow');
            
            const updatedUserResult = await dbGet(env, `users/${userId}`);
            const updatedUser = updatedUserResult.data;
            
            return {
                success: true,
                data: {
                    cows_owned: updatedUser.cows_owned,
                    quantity_bought: buyQuantity,
                    newTonBalance: updatedUser.tonBalance,
                    cows_sold: globalUpdates.cows_sold,
                    cows_remaining: GAME_CONSTANTS.COW_GLOBAL_CAP - globalUpdates.cows_sold,
                    referralCommission: referralCommission || 0
                }
            };
            
        } catch (error) {
            console.error(`Buy cow error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'BUY_COW_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

async function handleBuyChicken(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const userResult = await dbGet(env, `users/${userId}`);
            const globalResult = await dbGet(env, 'global');
            
            if (!userResult.success || !globalResult.success) {
                return {
                    success: false,
                    error: 'Failed to load game state',
                    errorCode: 'STATE_LOAD_ERROR'
                };
            }
            
            let user = userResult.data;
            let global = globalResult.data;
            
            if (!global) {
                global = await initializeGlobalState(env);
            }
            
            if (!user) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            const productionResult = await calculateProduction(env, userId, user);
            
            if (productionResult) {
                user = productionResult.user;
            }
            
            if (global.cows_sold < GAME_CONSTANTS.COW_GLOBAL_CAP) {
                return {
                    success: false,
                    error: 'Chicken machine is locked until all Cow machines are sold',
                    errorCode: 'CHICKEN_LOCKED'
                };
            }
            
            if (global.chickens_sold >= GAME_CONSTANTS.CHICKEN_GLOBAL_CAP) {
                return {
                    success: false,
                    error: 'All Chicken machines are sold out',
                    errorCode: 'CHICKEN_SOLD_OUT'
                };
            }
            
            if (user.chickens_owned > 0) {
                return {
                    success: false,
                    error: 'You can only own one Chicken machine',
                    errorCode: 'CHICKEN_ALREADY_OWNED'
                };
            }
            
            const atomicResult = await atomicUpdateUserResource(
                env,
                userId,
                'tonBalance',
                GAME_CONSTANTS.CHICKEN_PRICE
            );
            
            if (!atomicResult.success) {
                if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId} (buyChicken), retry attempt ${attempt}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else if (atomicResult.errorCode === 'INSUFFICIENT_RESOURCE') {
                    return {
                        success: false,
                        error: `Insufficient TON balance. Need ${GAME_CONSTANTS.CHICKEN_PRICE} TON`,
                        errorCode: 'INSUFFICIENT_TON',
                        currentBalance: atomicResult.currentBalance
                    };
                } else {
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode || 'ATOMIC_UPDATE_FAILED'
                    };
                }
            }
            
            const userUpdates = {
                chickens_owned: 1,
                updatedAt: Date.now()
            };
            
            const globalUpdates = {
                chickens_sold: (global.chickens_sold || 0) + 1,
                updatedAt: Date.now()
            };
            
            await dbUpdate(env, `users/${userId}`, userUpdates);
            await dbUpdate(env, 'global', globalUpdates);
            
            let referralCommission = 0;
            
            if (user.referredBy) {
                referralCommission = await updateReferralEarnings(
                    env, 
                    user.referredBy, 
                    userId, 
                    GAME_CONSTANTS.CHICKEN_PRICE, 
                    'chicken_purchase'
                );
            }
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'buy_chicken',
                amount: GAME_CONSTANTS.CHICKEN_PRICE,
                payment: 'TON',
                timestamp: Date.now()
            });
            
            await notifyMachinePurchase(env, userId, 'chicken');
            
            const updatedUserResult = await dbGet(env, `users/${userId}`);
            const updatedUser = updatedUserResult.data;
            
            return {
                success: true,
                data: {
                    chickens_owned: 1,
                    newTonBalance: updatedUser.tonBalance,
                    chickens_sold: globalUpdates.chickens_sold,
                    chickens_remaining: GAME_CONSTANTS.CHICKEN_GLOBAL_CAP - globalUpdates.chickens_sold,
                    referralCommission: referralCommission || 0
                }
            };
            
        } catch (error) {
            console.error(`Buy chicken error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'BUY_CHICKEN_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

async function handleBuyDiamondEngine(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const userResult = await dbGet(env, `users/${userId}`);
            const globalResult = await dbGet(env, 'global');
            
            if (!userResult.success || !globalResult.success) {
                return {
                    success: false,
                    error: 'Failed to load game state',
                    errorCode: 'STATE_LOAD_ERROR'
                };
            }
            
            let user = userResult.data;
            let global = globalResult.data;
            
            if (!global) {
                global = await initializeGlobalState(env);
            }
            
            if (!user) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            const productionResult = await calculateProduction(env, userId, user);
            
            if (productionResult) {
                user = productionResult.user;
            }
            
            if (global.cows_sold < GAME_CONSTANTS.COW_GLOBAL_CAP || 
                global.chickens_sold < GAME_CONSTANTS.CHICKEN_GLOBAL_CAP) {
                return {
                    success: false,
                    error: 'Diamond Engine is locked until all Cow and Chicken machines are sold',
                    errorCode: 'DIAMOND_LOCKED'
                };
            }
            
            if (user.diamond_engines_owned > 0) {
                return {
                    success: false,
                    error: 'You can only own one Diamond Engine',
                    errorCode: 'DIAMOND_ALREADY_OWNED'
                };
            }
            
            const atomicResult = await atomicUpdateUserResource(
                env,
                userId,
                'tonBalance',
                GAME_CONSTANTS.DIAMOND_ENGINE_PRICE
            );
            
            if (!atomicResult.success) {
                if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId} (buyDiamondEngine), retry attempt ${attempt}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else if (atomicResult.errorCode === 'INSUFFICIENT_RESOURCE') {
                    return {
                        success: false,
                        error: `Insufficient TON balance. Need ${GAME_CONSTANTS.DIAMOND_ENGINE_PRICE} TON`,
                        errorCode: 'INSUFFICIENT_TON',
                        currentBalance: atomicResult.currentBalance
                    };
                } else {
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode || 'ATOMIC_UPDATE_FAILED'
                    };
                }
            }
            
            const userUpdates = {
                diamond_engines_owned: 1,
                updatedAt: Date.now()
            };
            
            await dbUpdate(env, `users/${userId}`, userUpdates);
            
            let referralCommission = 0;
            
            if (user.referredBy) {
                referralCommission = await updateReferralEarnings(
                    env, 
                    user.referredBy, 
                    userId, 
                    GAME_CONSTANTS.DIAMOND_ENGINE_PRICE, 
                    'diamond_engine_purchase'
                );
            }
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'buy_diamond_engine',
                amount: GAME_CONSTANTS.DIAMOND_ENGINE_PRICE,
                payment: 'TON',
                timestamp: Date.now()
            });
            
            await notifyMachinePurchase(env, userId, 'diamond');
            
            const updatedUserResult = await dbGet(env, `users/${userId}`);
            const updatedUser = updatedUserResult.data;
            
            return {
                success: true,
                data: {
                    diamond_engines_owned: 1,
                    newTonBalance: updatedUser.tonBalance,
                    referralCommission: referralCommission || 0
                }
            };
            
        } catch (error) {
            console.error(`Buy diamond engine error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'BUY_DIAMOND_ENGINE_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

// ============================================
// HATCH SYSTEM - ALL FIXED WITH ATOMIC UPDATES
// ============================================

async function handleHatchCow(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { amount } = data;
            const hatchAmount = parseInt(amount) || 1;
            
            if (hatchAmount <= 0) {
                return {
                    success: false,
                    error: 'Invalid hatch amount',
                    errorCode: 'INVALID_AMOUNT'
                };
            }
            
            const userResult = await dbGet(env, `users/${userId}`);
            
            if (!userResult.success || !userResult.data) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            let user = userResult.data;
            
            const productionResult = await calculateProduction(env, userId, user);
            
            if (productionResult) {
                user = productionResult.user;
            }
            
            const milkNeeded = GAME_CONSTANTS.COW_HATCH_COST * hatchAmount;
            
            const atomicResult = await atomicUpdateUserResource(
                env,
                userId,
                'milk',
                milkNeeded
            );
            
            if (!atomicResult.success) {
                if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId} (hatchCow), retry attempt ${attempt}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else if (atomicResult.errorCode === 'INSUFFICIENT_RESOURCE') {
                    return {
                        success: false,
                        error: `Insufficient Milk. Need ${milkNeeded} Milk`,
                        errorCode: 'INSUFFICIENT_MILK',
                        currentBalance: atomicResult.currentBalance
                    };
                } else {
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode || 'ATOMIC_UPDATE_FAILED'
                    };
                }
            }
            
            const userUpdates = {
                cows_owned: (user.cows_owned || 0) + hatchAmount,
                updatedAt: Date.now()
            };
            
            await dbUpdate(env, `users/${userId}`, userUpdates);
            
            // Update leaderboard for hatched cows
            await updateLeaderboard(env, userId, user.cows_owned || 0, (user.cows_owned || 0) + hatchAmount);
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'hatch_cow',
                amount: hatchAmount,
                milkCost: milkNeeded,
                timestamp: Date.now()
            });
            
            const updatedUserResult = await dbGet(env, `users/${userId}`);
            const updatedUser = updatedUserResult.data;
            
            return {
                success: true,
                data: {
                    cows_hatched: hatchAmount,
                    milk_used: milkNeeded,
                    new_milk: updatedUser.milk,
                    new_cows: updatedUser.cows_owned
                }
            };
            
        } catch (error) {
            console.error(`Hatch cow error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'HATCH_COW_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

async function handleHatchChicken(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { amount } = data;
            const hatchAmount = parseInt(amount) || 1;
            
            if (hatchAmount <= 0) {
                return {
                    success: false,
                    error: 'Invalid hatch amount',
                    errorCode: 'INVALID_AMOUNT'
                };
            }
            
            const userResult = await dbGet(env, `users/${userId}`);
            
            if (!userResult.success || !userResult.data) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            let user = userResult.data;
            
            const productionResult = await calculateProduction(env, userId, user);
            
            if (productionResult) {
                user = productionResult.user;
            }
            
            const eggsNeeded = GAME_CONSTANTS.CHICKEN_HATCH_COST * hatchAmount;
            
            const atomicResult = await atomicUpdateUserResource(
                env,
                userId,
                'eggs',
                eggsNeeded
            );
            
            if (!atomicResult.success) {
                if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId} (hatchChicken), retry attempt ${attempt}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else if (atomicResult.errorCode === 'INSUFFICIENT_RESOURCE') {
                    return {
                        success: false,
                        error: `Insufficient Eggs. Need ${eggsNeeded} Eggs`,
                        errorCode: 'INSUFFICIENT_EGGS',
                        currentBalance: atomicResult.currentBalance
                    };
                } else {
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode || 'ATOMIC_UPDATE_FAILED'
                    };
                }
            }
            
            const userUpdates = {
                chickens_owned: (user.chickens_owned || 0) + hatchAmount,
                updatedAt: Date.now()
            };
            
            await dbUpdate(env, `users/${userId}`, userUpdates);
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'hatch_chicken',
                amount: hatchAmount,
                eggsCost: eggsNeeded,
                timestamp: Date.now()
            });
            
            const updatedUserResult = await dbGet(env, `users/${userId}`);
            const updatedUser = updatedUserResult.data;
            
            return {
                success: true,
                data: {
                    chickens_hatched: hatchAmount,
                    eggs_used: eggsNeeded,
                    new_eggs: updatedUser.eggs,
                    new_chickens: updatedUser.chickens_owned
                }
            };
            
        } catch (error) {
            console.error(`Hatch chicken error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'HATCH_CHICKEN_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

// ============================================
// DIAMOND PRODUCTION - FIXED WITH ATOMIC UPDATES
// ============================================

async function handleStartDiamondProduction(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const userResult = await dbGet(env, `users/${userId}`);
            
            if (!userResult.success || !userResult.data) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            let user = userResult.data;
            
            const productionResult = await calculateProduction(env, userId, user);
            
            if (productionResult) {
                user = productionResult.user;
            }
            
            if (!user.diamond_engines_owned || user.diamond_engines_owned < 1) {
                return {
                    success: false,
                    error: 'You need a Diamond Engine first',
                    errorCode: 'NO_DIAMOND_ENGINE'
                };
            }
            
            const milkAtomicResult = await atomicUpdateUserResource(
                env,
                userId,
                'milk',
                GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK
            );
            
            if (!milkAtomicResult.success) {
                if (milkAtomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else if (milkAtomicResult.errorCode === 'INSUFFICIENT_RESOURCE') {
                    return {
                        success: false,
                        error: `Insufficient Milk. Need ${GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK} Milk`,
                        errorCode: 'INSUFFICIENT_MILK',
                        currentBalance: milkAtomicResult.currentBalance
                    };
                } else {
                    return {
                        success: false,
                        error: milkAtomicResult.error,
                        errorCode: milkAtomicResult.errorCode || 'MILK_UPDATE_FAILED'
                    };
                }
            }
            
            const eggsAtomicResult = await atomicUpdateUserResource(
                env,
                userId,
                'eggs',
                GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG
            );
            
            if (!eggsAtomicResult.success) {
                await atomicUpdateUserResource(
                    env,
                    userId,
                    'milk',
                    -GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK
                );
                
                if (eggsAtomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else if (eggsAtomicResult.errorCode === 'INSUFFICIENT_RESOURCE') {
                    return {
                        success: false,
                        error: `Insufficient Eggs. Need ${GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG} Eggs`,
                        errorCode: 'INSUFFICIENT_EGGS',
                        currentBalance: eggsAtomicResult.currentBalance
                    };
                } else {
                    return {
                        success: false,
                        error: eggsAtomicResult.error,
                        errorCode: eggsAtomicResult.errorCode || 'EGGS_UPDATE_FAILED'
                    };
                }
            }
            
            await dbUpdate(env, `users/${userId}`, {
                diamond: (user.diamond || 0) + GAME_CONSTANTS.DIAMOND_PRODUCTION_YIELD,
                updatedAt: Date.now()
            });
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'diamond_production',
                milkUsed: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK,
                eggsUsed: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG,
                diamondProduced: GAME_CONSTANTS.DIAMOND_PRODUCTION_YIELD,
                timestamp: Date.now()
            });
            
            const updatedUserResult = await dbGet(env, `users/${userId}`);
            const updatedUser = updatedUserResult.data;
            
            return {
                success: true,
                data: {
                    diamondProduced: GAME_CONSTANTS.DIAMOND_PRODUCTION_YIELD,
                    newMilk: updatedUser.milk,
                    newEggs: updatedUser.eggs,
                    newDiamond: updatedUser.diamond
                }
            };
            
        } catch (error) {
            console.error(`Diamond production error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'DIAMOND_PRODUCTION_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

// ============================================
// DIAMOND CONVERSION - FIXED WITH ATOMIC UPDATES
// ============================================

async function handleConvertDiamond(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { amount } = data;
            const diamondsToConvert = parseInt(amount);
            
            if (!diamondsToConvert || diamondsToConvert <= 0) {
                return {
                    success: false,
                    error: 'Invalid amount',
                    errorCode: 'INVALID_AMOUNT'
                };
            }
            
            const userResult = await dbGet(env, `users/${userId}`);
            const globalResult = await dbGet(env, 'global');
            
            if (!userResult.success || !globalResult.success) {
                return {
                    success: false,
                    error: 'Failed to load game state',
                    errorCode: 'STATE_LOAD_ERROR'
                };
            }
            
            let user = userResult.data;
            let global = globalResult.data;
            
            if (!user) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            if (!global) {
                global = await initializeGlobalState(env);
            }
            
            const productionResult = await calculateProduction(env, userId, user);
            
            if (productionResult) {
                user = productionResult.user;
            }
            
            const diamondPrice = global.diamond_price || GAME_CONSTANTS.DIAMOND_BASE_PRICE;
            const tonToReceive = diamondsToConvert * diamondPrice;
            
            const diamondAtomicResult = await atomicUpdateUserResource(
                env,
                userId,
                'diamond',
                diamondsToConvert
            );
            
            if (!diamondAtomicResult.success) {
                if (diamondAtomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId} (convertDiamond), retry attempt ${attempt}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else if (diamondAtomicResult.errorCode === 'INSUFFICIENT_RESOURCE') {
                    return {
                        success: false,
                        error: 'Insufficient diamonds',
                        errorCode: 'INSUFFICIENT_DIAMOND',
                        currentBalance: diamondAtomicResult.currentBalance
                    };
                } else {
                    return {
                        success: false,
                        error: diamondAtomicResult.error,
                        errorCode: diamondAtomicResult.errorCode || 'DIAMOND_UPDATE_FAILED'
                    };
                }
            }
            
            const tonAtomicResult = await atomicUpdateUserResource(
                env,
                userId,
                'tonBalance',
                -tonToReceive
            );
            
            if (!tonAtomicResult.success) {
                await atomicUpdateUserResource(
                    env,
                    userId,
                    'diamond',
                    -diamondsToConvert
                );
                
                if (tonAtomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    }
                }
                return {
                    success: false,
                    error: 'Failed to add TON, transaction rolled back',
                    errorCode: 'TON_UPDATE_FAILED'
                };
            }
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'diamond_conversion',
                diamondsUsed: diamondsToConvert,
                diamondPrice: diamondPrice,
                tonReceived: tonToReceive,
                timestamp: Date.now()
            });
            
            const updatedUserResult = await dbGet(env, `users/${userId}`);
            const updatedUser = updatedUserResult.data;
            
            return {
                success: true,
                data: {
                    diamondsConverted: diamondsToConvert,
                    diamondPrice: diamondPrice,
                    tonReceived: tonToReceive,
                    newDiamond: updatedUser.diamond,
                    newTonBalance: updatedUser.tonBalance
                }
            };
            
        } catch (error) {
            console.error(`Diamond conversion error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'DIAMOND_CONVERSION_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

// ============================================
// MARKET - P2P ORDER BOOK - ALL FIXED WITH ETAG
// ============================================

async function handleCreateSellOrder(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { resource, quantity, pricePerUnit } = data;
            
            if (!['milk', 'eggs'].includes(resource)) {
                return {
                    success: false,
                    error: 'Invalid resource. Must be milk or eggs',
                    errorCode: 'INVALID_RESOURCE'
                };
            }
            
            const orderQuantity = parseInt(quantity);
            if (!orderQuantity || orderQuantity < GAME_CONSTANTS.MIN_ORDER_AMOUNT) {
                return {
                    success: false,
                    error: `Minimum order quantity is ${GAME_CONSTANTS.MIN_ORDER_AMOUNT}`,
                    errorCode: 'INVALID_QUANTITY'
                };
            }
            
            const orderPrice = parseFloat(pricePerUnit);
            if (!orderPrice || orderPrice <= 0) {
                return {
                    success: false,
                    error: 'Price must be greater than 0',
                    errorCode: 'INVALID_PRICE'
                };
            }
            
            // ===== CHECK MAX ACTIVE ORDERS (LIMIT 2) =====
            const activeOrdersCheck = await checkUserActiveOrders(env, userId);
            if (!activeOrdersCheck.success) {
                return {
                    success: false,
                    error: 'Failed to check active orders',
                    errorCode: 'ACTIVE_ORDERS_CHECK_FAILED'
                };
            }
            
            if (activeOrdersCheck.activeCount >= GAME_CONSTANTS.MAX_ACTIVE_ORDERS) {
                return {
                    success: false,
                    error: `Maximum ${GAME_CONSTANTS.MAX_ACTIVE_ORDERS} active orders allowed. Please cancel an existing order first.`,
                    errorCode: 'MAX_ACTIVE_ORDERS_REACHED',
                    activeOrders: activeOrdersCheck.activeOrders
                };
            }
            
            // ===== CHECK PRICE PENALTY =====
            let penaltyFee = 0;
            if (orderPrice < GAME_CONSTANTS.MIN_ORDER_PRICE) {
                penaltyFee = GAME_CONSTANTS.ORDER_PENALTY_FEE;
                
                // Check if user has enough balance for penalty
                const userResult = await dbGet(env, `users/${userId}`);
                if (!userResult.success || !userResult.data) {
                    return {
                        success: false,
                        error: 'User not found',
                        errorCode: 'USER_NOT_FOUND'
                    };
                }
                
                if ((userResult.data.tonBalance || 0) < penaltyFee) {
                    return {
                        success: false,
                        error: `Price too low. Penalty fee of ${penaltyFee} TON required. Insufficient balance.`,
                        errorCode: 'INSUFFICIENT_TON_FOR_PENALTY',
                        requiredBalance: penaltyFee,
                        currentBalance: userResult.data.tonBalance
                    };
                }
                
                // Deduct penalty fee
                const penaltyResult = await atomicUpdateUserResource(
                    env,
                    userId,
                    'tonBalance',
                    penaltyFee
                );
                
                if (!penaltyResult.success) {
                    if (penaltyResult.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            console.log(`Race condition detected for user ${userId} (penalty fee), retry attempt ${attempt}/${maxAttempts}`);
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    } else {
                        return {
                            success: false,
                            error: penaltyResult.error,
                            errorCode: penaltyResult.errorCode || 'PENALTY_FEE_FAILED'
                        };
                    }
                }
            }
            
            const userResult = await dbGet(env, `users/${userId}`);
            if (!userResult.success || !userResult.data) {
                // If penalty was deducted and we fail here, we should note that penalty is non-refundable
                if (penaltyFee > 0) {
                    console.log(`Penalty fee ${penaltyFee} deducted from user ${userId} but order creation failed later. Penalty is non-refundable.`);
                }
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            let user = userResult.data;
            
            const productionResult = await calculateProduction(env, userId, user);
            if (productionResult) {
                user = productionResult.user;
            }
            
            const atomicResult = await atomicUpdateUserResource(
                env, 
                userId, 
                resource, 
                orderQuantity
            );
            
            if (!atomicResult.success) {
                // Note: Penalty fee is non-refundable even if resource update fails
                if (penaltyFee > 0) {
                    console.log(`Penalty fee ${penaltyFee} deducted from user ${userId} but resource update failed. Penalty is non-refundable.`);
                }
                
                if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId} (sell order), retry attempt ${attempt}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else if (atomicResult.errorCode === 'INSUFFICIENT_RESOURCE') {
                    return {
                        success: false,
                        error: `Insufficient ${resource}. You have ${atomicResult.currentBalance}, need ${orderQuantity}`,
                        errorCode: 'INSUFFICIENT_RESOURCE'
                    };
                } else {
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode || 'ATOMIC_UPDATE_FAILED'
                    };
                }
            }
            
            const now = Date.now();
            const orderId = `sell_${now}_${Math.random().toString(36).substring(2, 10)}_${attempt}`;
            
            const orderData = {
                id: orderId,
                userId: userId,
                type: 'sell',
                resource: resource,
                quantity: orderQuantity,
                remaining: orderQuantity,
                pricePerUnit: orderPrice,
                status: 'active',
                penaltyPaid: penaltyFee > 0,
                penaltyAmount: penaltyFee,
                createdAt: now,
                updatedAt: now
            };
            
            await dbSet(env, `orders/${orderId}`, orderData);
            await dbSet(env, `users/${userId}/orders/${orderId}`, {
                id: orderId,
                type: 'sell',
                resource: resource,
                quantity: orderQuantity,
                remaining: orderQuantity,
                pricePerUnit: orderPrice,
                status: 'active',
                penaltyPaid: penaltyFee > 0,
                penaltyAmount: penaltyFee,
                createdAt: now
            });
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'create_sell_order',
                orderId: orderId,
                resource: resource,
                quantity: orderQuantity,
                pricePerUnit: orderPrice,
                totalValue: orderQuantity * orderPrice,
                penaltyFee: penaltyFee,
                timestamp: now
            });
            
            let responseData = {
                orderId: orderId,
                order: orderData,
                newBalance: atomicResult.data.newBalance,
                deducted: atomicResult.data.deducted
            };
            
            if (penaltyFee > 0) {
                responseData.penaltyFee = penaltyFee;
                responseData.message = `Warning: Price below ${GAME_CONSTANTS.MIN_ORDER_PRICE} TON. Penalty fee of ${penaltyFee} TON deducted (non-refundable).`;
            }
            
            return {
                success: true,
                data: responseData
            };
            
        } catch (error) {
            console.error(`Create sell order error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'CREATE_SELL_ORDER_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

async function handleCreateBuyOrder(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { resource, quantity, pricePerUnit } = data;
            
            if (!['milk', 'eggs'].includes(resource)) {
                return {
                    success: false,
                    error: 'Invalid resource. Must be milk or eggs',
                    errorCode: 'INVALID_RESOURCE'
                };
            }
            
            const orderQuantity = parseInt(quantity);
            if (!orderQuantity || orderQuantity < GAME_CONSTANTS.MIN_ORDER_AMOUNT) {
                return {
                    success: false,
                    error: `Minimum order quantity is ${GAME_CONSTANTS.MIN_ORDER_AMOUNT}`,
                    errorCode: 'INVALID_QUANTITY'
                };
            }
            
            const orderPrice = parseFloat(pricePerUnit);
            if (!orderPrice || orderPrice <= 0) {
                return {
                    success: false,
                    error: 'Price must be greater than 0',
                    errorCode: 'INVALID_PRICE'
                };
            }
            
            // ===== CHECK MAX ACTIVE ORDERS (LIMIT 2) =====
            const activeOrdersCheck = await checkUserActiveOrders(env, userId);
            if (!activeOrdersCheck.success) {
                return {
                    success: false,
                    error: 'Failed to check active orders',
                    errorCode: 'ACTIVE_ORDERS_CHECK_FAILED'
                };
            }
            
            if (activeOrdersCheck.activeCount >= GAME_CONSTANTS.MAX_ACTIVE_ORDERS) {
                return {
                    success: false,
                    error: `Maximum ${GAME_CONSTANTS.MAX_ACTIVE_ORDERS} active orders allowed. Please cancel an existing order first.`,
                    errorCode: 'MAX_ACTIVE_ORDERS_REACHED',
                    activeOrders: activeOrdersCheck.activeOrders
                };
            }
            
            const userResult = await dbGet(env, `users/${userId}`);
            if (!userResult.success || !userResult.data) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            let user = userResult.data;
            
            const productionResult = await calculateProduction(env, userId, user);
            if (productionResult) {
                user = productionResult.user;
            }
            
            const totalCost = orderQuantity * orderPrice;
            
            const atomicResult = await atomicUpdateUserResource(
                env, 
                userId, 
                'tonBalance', 
                totalCost
            );
            
            if (!atomicResult.success) {
                if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId} (buy order), retry attempt ${attempt}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else if (atomicResult.errorCode === 'INSUFFICIENT_RESOURCE') {
                    return {
                        success: false,
                        error: `Insufficient TON balance. You have ${atomicResult.currentBalance} TON, need ${totalCost} TON`,
                        errorCode: 'INSUFFICIENT_TON'
                    };
                } else {
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode || 'ATOMIC_UPDATE_FAILED'
                    };
                }
            }
            
            const now = Date.now();
            const orderId = `buy_${now}_${Math.random().toString(36).substring(2, 10)}_${attempt}`;
            
            const orderData = {
                id: orderId,
                userId: userId,
                type: 'buy',
                resource: resource,
                quantity: orderQuantity,
                remaining: orderQuantity,
                pricePerUnit: orderPrice,
                status: 'active',
                createdAt: now,
                updatedAt: now
            };
            
            await dbSet(env, `orders/${orderId}`, orderData);
            await dbSet(env, `users/${userId}/orders/${orderId}`, {
                id: orderId,
                type: 'buy',
                resource: resource,
                quantity: orderQuantity,
                remaining: orderQuantity,
                pricePerUnit: orderPrice,
                status: 'active',
                createdAt: now
            });
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'create_buy_order',
                orderId: orderId,
                resource: resource,
                quantity: orderQuantity,
                pricePerUnit: orderPrice,
                totalCost: totalCost,
                timestamp: now
            });
            
            return {
                success: true,
                data: {
                    orderId: orderId,
                    order: orderData,
                    newBalance: atomicResult.data.newBalance,
                    deducted: atomicResult.data.deducted
                }
            };
            
        } catch (error) {
            console.error(`Create buy order error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'CREATE_BUY_ORDER_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

// ============================================
// EXECUTE ORDER - FULLY FIXED WITH ORDER LOCKING
// ============================================

async function handleExecuteOrder(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { orderId, quantity } = data;
            
            const orderResult = await dbGet(env, `orders/${orderId}`);
            if (!orderResult.success || !orderResult.data) {
                return {
                    success: false,
                    error: 'Order not found',
                    errorCode: 'ORDER_NOT_FOUND'
                };
            }
            
            const order = orderResult.data;
            
            if (order.status !== 'active') {
                return {
                    success: false,
                    error: 'Order is not active',
                    errorCode: 'ORDER_NOT_ACTIVE'
                };
            }
            
            if (order.userId === userId) {
                return {
                    success: false,
                    error: 'Cannot execute your own order',
                    errorCode: 'OWN_ORDER'
                };
            }
            
            const executeQuantity = quantity ? parseInt(quantity) : order.remaining;
            if (executeQuantity <= 0 || executeQuantity > order.remaining) {
                return {
                    success: false,
                    error: 'Invalid execution quantity',
                    errorCode: 'INVALID_QUANTITY'
                };
            }
            
            let buyerId, sellerId;
            if (order.type === 'sell') {
                buyerId = userId;
                sellerId = order.userId;
            } else {
                buyerId = order.userId;
                sellerId = userId;
            }
            
            const totalCost = executeQuantity * order.pricePerUnit;
            const fee = order.type === 'sell' ? totalCost * (GAME_CONSTANTS.MARKET_FEE_PERCENT / 100) : 0;
            const sellerReceives = order.type === 'sell' ? totalCost - fee : totalCost;
            
            if (order.type === 'sell') {
                const buyerTonUpdate = await atomicUpdateUserResource(
                    env, buyerId, 'tonBalance', totalCost
                );
                
                if (!buyerTonUpdate.success) {
                    if (buyerTonUpdate.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            console.log(`Race condition detected for buyer ${buyerId} TON, retry attempt ${attempt}/${maxAttempts}`);
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    } else if (buyerTonUpdate.errorCode === 'INSUFFICIENT_RESOURCE') {
                        return {
                            success: false,
                            error: 'Buyer has insufficient TON balance',
                            errorCode: 'BUYER_INSUFFICIENT_TON'
                        };
                    }
                    return {
                        success: false,
                        error: buyerTonUpdate.error,
                        errorCode: 'BUYER_UPDATE_FAILED'
                    };
                }
                
                const buyerResourceUpdate = await atomicUpdateUserResource(
                    env, buyerId, order.resource, -executeQuantity
                );
                
                if (!buyerResourceUpdate.success) {
                    await atomicUpdateUserResource(env, buyerId, 'tonBalance', -totalCost);
                    
                    if (buyerResourceUpdate.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            console.log(`Race condition detected for buyer ${buyerId} resource, retry attempt ${attempt}/${maxAttempts}`);
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    }
                    return {
                        success: false,
                        error: 'Failed to add resources to buyer, transaction rolled back',
                        errorCode: 'BUYER_RESOURCE_UPDATE_FAILED'
                    };
                }
                
                const sellerTonUpdate = await atomicUpdateUserResource(
                    env, sellerId, 'tonBalance', -sellerReceives
                );
                
                if (!sellerTonUpdate.success) {
                    await atomicUpdateUserResource(env, buyerId, 'tonBalance', -totalCost);
                    await atomicUpdateUserResource(env, buyerId, order.resource, executeQuantity);
                    
                    if (sellerTonUpdate.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            console.log(`Race condition detected for seller ${sellerId} TON, retry attempt ${attempt}/${maxAttempts}`);
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    }
                    return {
                        success: false,
                        error: 'Failed to credit seller, transaction rolled back',
                        errorCode: 'SELLER_UPDATE_FAILED'
                    };
                }
                
            } else {
                const sellerResourceUpdate = await atomicUpdateUserResource(
                    env, sellerId, order.resource, executeQuantity
                );
                
                if (!sellerResourceUpdate.success) {
                    if (sellerResourceUpdate.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            console.log(`Race condition detected for seller ${sellerId} resource, retry attempt ${attempt}/${maxAttempts}`);
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    } else if (sellerResourceUpdate.errorCode === 'INSUFFICIENT_RESOURCE') {
                        return {
                            success: false,
                            error: 'Seller has insufficient resource',
                            errorCode: 'SELLER_INSUFFICIENT_RESOURCE'
                        };
                    }
                    return {
                        success: false,
                        error: sellerResourceUpdate.error,
                        errorCode: 'SELLER_UPDATE_FAILED'
                    };
                }
                
                const sellerTonUpdate = await atomicUpdateUserResource(
                    env, sellerId, 'tonBalance', -totalCost
                );
                
                if (!sellerTonUpdate.success) {
                    await atomicUpdateUserResource(env, sellerId, order.resource, -executeQuantity);
                    
                    if (sellerTonUpdate.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            console.log(`Race condition detected for seller ${sellerId} TON, retry attempt ${attempt}/${maxAttempts}`);
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    }
                    return {
                        success: false,
                        error: 'Failed to add TON to seller, transaction rolled back',
                        errorCode: 'SELLER_TON_UPDATE_FAILED'
                    };
                }
                
                const buyerResourceUpdate = await atomicUpdateUserResource(
                    env, buyerId, order.resource, -executeQuantity
                );
                
                if (!buyerResourceUpdate.success) {
                    await atomicUpdateUserResource(env, sellerId, order.resource, executeQuantity);
                    await atomicUpdateUserResource(env, sellerId, 'tonBalance', totalCost);
                    
                    if (buyerResourceUpdate.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            console.log(`Race condition detected for buyer ${buyerId} resource, retry attempt ${attempt}/${maxAttempts}`);
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    }
                    return {
                        success: false,
                        error: 'Failed to add resources to buyer, transaction rolled back',
                        errorCode: 'BUYER_RESOURCE_UPDATE_FAILED'
                    };
                }
            }
            
            const finalOrderCheck = await dbGet(env, `orders/${orderId}`);
            if (!finalOrderCheck.success || !finalOrderCheck.data) {
                await rollbackExecuteOrder(env, buyerId, sellerId, order, executeQuantity, totalCost, sellerReceives, fee);
                return {
                    success: false,
                    error: 'Order disappeared during execution',
                    errorCode: 'ORDER_LOST'
                };
            }
            
            const finalOrder = finalOrderCheck.data;
            
            if (finalOrder.status !== 'active') {
                await rollbackExecuteOrder(env, buyerId, sellerId, order, executeQuantity, totalCost, sellerReceives, fee);
                return {
                    success: false,
                    error: 'Order was already executed by another transaction',
                    errorCode: 'ORDER_ALREADY_EXECUTED'
                };
            }
            
            if (finalOrder.remaining !== order.remaining) {
                await rollbackExecuteOrder(env, buyerId, sellerId, order, executeQuantity, totalCost, sellerReceives, fee);
                return {
                    success: false,
                    error: 'Order quantity changed during execution',
                    errorCode: 'ORDER_MODIFIED'
                };
            }
            
            const newRemaining = finalOrder.remaining - executeQuantity;
            const orderStatus = newRemaining <= 0 ? 'filled' : 'active';
            
            const orderUpdates = {
                remaining: newRemaining,
                status: orderStatus,
                updatedAt: Date.now()
            };
            
            await dbUpdate(env, `orders/${orderId}`, orderUpdates);
            await dbUpdate(env, `users/${order.userId}/orders/${orderId}`, orderUpdates);
            
            const txId = `tx_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
            
            await dbPush(env, `users/${buyerId}/transactions`, {
                id: txId,
                type: 'market_buy',
                orderId: orderId,
                resource: order.resource,
                quantity: executeQuantity,
                pricePerUnit: order.pricePerUnit,
                totalCost: totalCost,
                sellerId: sellerId,
                timestamp: Date.now()
            });
            
            await dbPush(env, `users/${sellerId}/transactions`, {
                id: txId,
                type: 'market_sell',
                orderId: orderId,
                resource: order.resource,
                quantity: executeQuantity,
                pricePerUnit: order.pricePerUnit,
                totalReceived: sellerReceives,
                fee: fee,
                buyerId: buyerId,
                timestamp: Date.now()
            });
            
            await notifyOrderFilled(env, order.userId, order, executeQuantity, totalCost, fee);
            
            return {
                success: true,
                data: {
                    txId: txId,
                    orderId: orderId,
                    resource: order.resource,
                    quantity: executeQuantity,
                    pricePerUnit: order.pricePerUnit,
                    totalCost: totalCost,
                    fee: fee,
                    sellerReceives: sellerReceives,
                    orderRemaining: newRemaining,
                    orderStatus: orderStatus
                }
            };
            
        } catch (error) {
            console.error(`Execute order error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'EXECUTE_ORDER_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

// ============================================
// ROLLBACK FUNCTION FOR EXECUTE ORDER
// ============================================

async function rollbackExecuteOrder(env, buyerId, sellerId, order, quantity, totalCost, sellerReceives, fee) {
    console.log(`Rolling back failed transaction for order ${order.id}`);
    
    try {
        if (order.type === 'sell') {
            await atomicUpdateUserResource(env, buyerId, 'tonBalance', -totalCost);
            await atomicUpdateUserResource(env, buyerId, order.resource, quantity);
            await atomicUpdateUserResource(env, sellerId, 'tonBalance', sellerReceives);
        } else {
            await atomicUpdateUserResource(env, sellerId, order.resource, -quantity);
            await atomicUpdateUserResource(env, sellerId, 'tonBalance', totalCost);
            await atomicUpdateUserResource(env, buyerId, order.resource, quantity);
        }
        console.log('Rollback completed successfully');
    } catch (rollbackError) {
        console.error('CRITICAL: Rollback failed!', rollbackError);
    }
}

async function handleGetMarketOrders(env, data) {
    try {
        const { resource, type, page = 1, limit = 10 } = data;
        
        const ordersResult = await dbGet(env, 'orders');
        
        if (!ordersResult.success || !ordersResult.data) {
            return {
                success: true,
                data: {
                    orders: [],
                    total: 0,
                    page: page,
                    totalPages: 0
                }
            };
        }
        
        const allOrders = ordersResult.data;
        const filteredOrders = [];
        
        for (const [orderId, order] of Object.entries(allOrders)) {
            if (order.status !== 'active') continue;
            
            if (resource && order.resource !== resource) continue;
            
            if (type && order.type !== type) continue;
            
            filteredOrders.push({
                id: orderId,
                userId: order.userId,
                type: order.type,
                resource: order.resource,
                quantity: order.quantity,
                remaining: order.remaining,
                pricePerUnit: order.pricePerUnit,
                createdAt: order.createdAt
            });
        }
        
        if (type === 'sell') {
            filteredOrders.sort((a, b) => a.pricePerUnit - b.pricePerUnit);
        } else if (type === 'buy') {
            filteredOrders.sort((a, b) => b.pricePerUnit - a.pricePerUnit);
        } else {
            filteredOrders.sort((a, b) => b.createdAt - a.createdAt);
        }
        
        const total = filteredOrders.length;
        const totalPages = Math.ceil(total / limit);
        const start = (page - 1) * limit;
        const end = start + limit;
        const paginatedOrders = filteredOrders.slice(start, end);
        
        return {
            success: true,
            data: {
                orders: paginatedOrders,
                total: total,
                page: page,
                totalPages: totalPages,
                hasMore: page < totalPages
            }
        };
        
    } catch (error) {
        console.error('Get market orders error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_MARKET_ORDERS_ERROR'
        };
    }
}

async function handleGetMyOrders(env, userId) {
    try {
        const ordersResult = await dbGet(env, `users/${userId}/orders`);
        
        if (!ordersResult.success || !ordersResult.data) {
            return {
                success: true,
                data: {
                    active: [],
                    filled: []
                }
            };
        }
        
        const userOrders = ordersResult.data;
        const activeOrders = [];
        const filledOrders = [];
        
        for (const [orderId, order] of Object.entries(userOrders)) {
            if (order.status === 'active') {
                activeOrders.push({
                    id: orderId,
                    ...order
                });
            } else {
                filledOrders.push({
                    id: orderId,
                    ...order
                });
            }
        }
        
        activeOrders.sort((a, b) => b.createdAt - a.createdAt);
        filledOrders.sort((a, b) => b.createdAt - a.createdAt);
        
        return {
            success: true,
            data: {
                active: activeOrders.slice(0, 20),
                filled: filledOrders.slice(0, 20)
            }
        };
        
    } catch (error) {
        console.error('Get my orders error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_MY_ORDERS_ERROR'
        };
    }
}

async function handleCancelOrder(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { orderId } = data;
            
            const orderResult = await dbGet(env, `orders/${orderId}`);
            if (!orderResult.success || !orderResult.data) {
                return {
                    success: false,
                    error: 'Order not found',
                    errorCode: 'ORDER_NOT_FOUND'
                };
            }
            
            const order = orderResult.data;
            
            if (order.userId !== userId) {
                return {
                    success: false,
                    error: 'Unauthorized to cancel this order',
                    errorCode: 'UNAUTHORIZED'
                };
            }
            
            if (order.status !== 'active') {
                return {
                    success: false,
                    error: 'Order is not active',
                    errorCode: 'ORDER_NOT_ACTIVE'
                };
            }
            
            const userResult = await dbGet(env, `users/${userId}`);
            if (!userResult.success || !userResult.data) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            let user = userResult.data;
            
            const productionResult = await calculateProduction(env, userId, user);
            if (productionResult) {
                user = productionResult.user;
            }
            
            if (order.type === 'sell') {
                const atomicResult = await atomicUpdateUserResource(
                    env,
                    userId,
                    order.resource,
                    -order.remaining
                );
                
                if (!atomicResult.success) {
                    if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            console.log(`Race condition detected for user ${userId} (cancel sell order), retry attempt ${attempt}/${maxAttempts}`);
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    }
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode
                    };
                }
                
            } else {
                const refundAmount = order.remaining * order.pricePerUnit;
                
                const atomicResult = await atomicUpdateUserResource(
                    env,
                    userId,
                    'tonBalance',
                    -refundAmount
                );
                
                if (!atomicResult.success) {
                    if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            console.log(`Race condition detected for user ${userId} (cancel buy order), retry attempt ${attempt}/${maxAttempts}`);
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    }
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode
                    };
                }
            }
            
            const orderUpdates = {
                status: 'cancelled',
                updatedAt: Date.now()
            };
            
            await dbUpdate(env, `orders/${orderId}`, orderUpdates);
            await dbUpdate(env, `users/${userId}/orders/${orderId}`, orderUpdates);
            
            return {
                success: true,
                data: {
                    orderId: orderId,
                    status: 'cancelled'
                }
            };
            
        } catch (error) {
            console.error(`Cancel order error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'CANCEL_ORDER_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

// ============================================
// DEPOSIT SYSTEM - FIXED WITH ATOMIC UPDATES
// ============================================

async function handleDeposit(env, userId, data) {
    try {
        const { amount, txHash, comment } = data;
        
        if (!amount || amount < GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT) {
            return {
                success: false,
                error: `Minimum deposit amount is ${GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT} TON`,
                errorCode: 'INVALID_AMOUNT'
            };
        }
        
        if (!comment || comment.toString() !== userId) {
            return {
                success: false,
                error: 'Invalid comment. Comment must contain only your User ID',
                errorCode: 'INVALID_COMMENT'
            };
        }
        
        const existingTx = await dbGet(env, `transactions/${txHash}`);
        
        if (existingTx.success && existingTx.data) {
            return {
                success: false,
                error: 'Transaction already processed',
                errorCode: 'DUPLICATE_TRANSACTION'
            };
        }
        
        const depositId = `dep_${Date.now()}_${userId}`;
        const now = Date.now();
        
        const depositRecord = {
            id: depositId,
            userId: userId,
            amount: parseFloat(amount),
            txHash: txHash,
            comment: comment,
            status: 'pending',
            createdAt: now,
            updatedAt: now
        };
        
        await dbSet(env, `deposits/${depositId}`, depositRecord);
        await dbSet(env, `transactions/${txHash}`, depositRecord);
        await dbSet(env, `users/${userId}/deposits/${depositId}`, depositRecord);
        
        return {
            success: true,
            data: {
                depositId: depositId,
                amount: amount,
                status: 'pending',
                message: 'Transaction received. Verification in progress.'
            }
        };
        
    } catch (error) {
        console.error('Deposit error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DEPOSIT_ERROR'
        };
    }
}

async function handleVerifyDeposit(env, userId, data) {
    try {
        const { txHash, depositId } = data;
        
        let depositRecord = null;
        
        if (txHash) {
            const txResult = await dbGet(env, `transactions/${txHash}`);
            if (txResult.success && txResult.data) {
                depositRecord = txResult.data;
            }
        }
        
        if (!depositRecord && depositId) {
            const depositResult = await dbGet(env, `deposits/${depositId}`);
            if (depositResult.success && depositResult.data) {
                depositRecord = depositResult.data;
            }
        }
        
        if (!depositRecord) {
            return {
                success: false,
                error: 'Deposit record not found',
                errorCode: 'DEPOSIT_NOT_FOUND'
            };
        }
        
        if (depositRecord.userId !== userId) {
            return {
                success: false,
                error: 'Unauthorized access',
                errorCode: 'UNAUTHORIZED'
            };
        }
        
        if (depositRecord.status === 'completed') {
            return {
                success: true,
                data: {
                    status: 'completed',
                    amount: depositRecord.amount,
                    verified: true,
                    timestamp: depositRecord.updatedAt
                }
            };
        }
        
        const isDevelopment = env.ENVIRONMENT === 'development';
        
        if (isDevelopment && depositRecord.createdAt) {
            const timeElapsed = Date.now() - depositRecord.createdAt;
            if (timeElapsed > 30000) {
                await dbUpdate(env, `deposits/${depositRecord.id}`, {
                    status: 'completed',
                    verified: true,
                    updatedAt: Date.now()
                });
                
                await dbUpdate(env, `transactions/${depositRecord.txHash}`, {
                    status: 'completed',
                    verified: true,
                    updatedAt: Date.now()
                });
                
                await dbUpdate(env, `users/${userId}/deposits/${depositRecord.id}`, {
                    status: 'completed',
                    verified: true,
                    updatedAt: Date.now()
                });
                
                const atomicResult = await atomicUpdateUserResource(
                    env,
                    userId,
                    'tonBalance',
                    -depositRecord.amount
                );
                
                if (!atomicResult.success) {
                    return {
                        success: false,
                        error: 'Failed to add deposit to balance',
                        errorCode: 'DEPOSIT_UPDATE_FAILED'
                    };
                }
                
                await notifyDepositSuccess(env, userId, depositRecord.amount);
                
                return {
                    success: true,
                    data: {
                        status: 'completed',
                        amount: depositRecord.amount,
                        verified: true,
                        timestamp: Date.now()
                    }
                };
            }
        }
        
        return {
            success: true,
            data: {
                status: depositRecord.status,
                amount: depositRecord.amount,
                verified: depositRecord.verified || false,
                timestamp: depositRecord.createdAt
            }
        };
        
    } catch (error) {
        console.error('Verify deposit error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_DEPOSIT_ERROR'
        };
    }
}

// ============================================
// WITHDRAWAL SYSTEM - FIXED WITH ATOMIC UPDATE
// ============================================

async function handleWithdraw(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { amount, address } = data;
            const withdrawAmount = parseFloat(amount);
            
            if (!withdrawAmount || withdrawAmount < GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT) {
                return {
                    success: false,
                    error: `Minimum withdrawal amount is ${GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT} TON`,
                    errorCode: 'INVALID_AMOUNT'
                };
            }
            
            if (!address || address.trim().length < 10) {
                return {
                    success: false,
                    error: 'Valid TON wallet address is required',
                    errorCode: 'INVALID_ADDRESS'
                };
            }
            
            const userResult = await dbGet(env, `users/${userId}`);
            if (!userResult.success || !userResult.data) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            let user = userResult.data;
            
            const productionResult = await calculateProduction(env, userId, user);
            if (productionResult) {
                user = productionResult.user;
            }
            
            const fee = withdrawAmount * (GAME_CONSTANTS.WITHDRAW_FEE_PERCENT / 100);
            const netAmount = withdrawAmount - fee;
            
            const atomicResult = await atomicUpdateUserResource(
                env,
                userId,
                'tonBalance',
                withdrawAmount
            );
            
            if (!atomicResult.success) {
                if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId} (withdraw), retry attempt ${attempt}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else if (atomicResult.errorCode === 'INSUFFICIENT_RESOURCE') {
                    return {
                        success: false,
                        error: 'Insufficient TON balance',
                        errorCode: 'INSUFFICIENT_TON',
                        currentBalance: atomicResult.currentBalance
                    };
                } else {
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode || 'ATOMIC_UPDATE_FAILED'
                    };
                }
            }
            
            const withdrawalId = `wd_${Date.now()}_${userId}_${attempt}`;
            const now = Date.now();
            
            const withdrawalRecord = {
                id: withdrawalId,
                userId: userId,
                amount: withdrawAmount,
                fee: fee,
                netAmount: netAmount,
                address: address,
                status: 'pending',
                createdAt: now,
                updatedAt: now
            };
            
            await dbSet(env, `withdrawals/${withdrawalId}`, withdrawalRecord);
            await dbSet(env, `users/${userId}/withdrawals/${withdrawalId}`, withdrawalRecord);
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'withdrawal',
                withdrawalId: withdrawalId,
                amount: withdrawAmount,
                fee: fee,
                netAmount: netAmount,
                address: address,
                status: 'pending',
                timestamp: now
            });
            
            return {
                success: true,
                data: {
                    withdrawalId: withdrawalId,
                    amount: withdrawAmount,
                    fee: fee,
                    netAmount: netAmount,
                    newBalance: atomicResult.data.newBalance,
                    status: 'pending'
                }
            };
            
        } catch (error) {
            console.error(`Withdrawal error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'WITHDRAWAL_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

// ============================================
// REFERRAL SYSTEM - FIXED WITH ATOMIC UPDATES
// ============================================

async function handleClaimReferralEarnings(env, userId) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const userResult = await dbGet(env, `users/${userId}`);
            
            if (!userResult.success || !userResult.data) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            let user = userResult.data;
            
            const productionResult = await calculateProduction(env, userId, user);
            
            if (productionResult) {
                user = productionResult.user;
            }
            
            const earnings = parseFloat(user.referralEarnings || 0);
            
            if (earnings <= 0) {
                return {
                    success: false,
                    error: 'No referral earnings to claim',
                    errorCode: 'NO_EARNINGS'
                };
            }
            
            const currentClaimed = parseFloat(user.referralEarningsClaimed || 0);
            
            const atomicResult = await atomicUpdateUserResource(
                env,
                userId,
                'tonBalance',
                -earnings
            );
            
            if (!atomicResult.success) {
                if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId} (claimReferral), retry attempt ${attempt}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else {
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode || 'ATOMIC_UPDATE_FAILED'
                    };
                }
            }
            
            const userUpdates = {
                referralEarnings: 0,
                referralEarningsClaimed: currentClaimed + earnings,
                updatedAt: Date.now()
            };
            
            await dbUpdate(env, `users/${userId}`, userUpdates);
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'claim_referral',
                amount: earnings,
                timestamp: Date.now()
            });
            
            const updatedUserResult = await dbGet(env, `users/${userId}`);
            const updatedUser = updatedUserResult.data;
            
            return {
                success: true,
                data: {
                    claimedAmount: earnings,
                    newTonBalance: updatedUser.tonBalance,
                    totalClaimed: updatedUser.referralEarningsClaimed
                }
            };
            
        } catch (error) {
            console.error(`Claim referral earnings error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'CLAIM_REFERRAL_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

async function handleGetReferralInfo(env, userId) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const user = userResult.data;
        
        const referralsResult = await dbGet(env, `users/${userId}/referrals`);
        
        let referrals = [];
        if (referralsResult.success && referralsResult.data) {
            const referralsObj = referralsResult.data;
            referrals = Object.entries(referralsObj).map(([key, value]) => ({
                id: key,
                ...value
            }));
            
            referrals.sort((a, b) => (b.joinedAt || 0) - (a.joinedAt || 0));
        }
        
        const earningsResult = await dbGet(env, `users/${userId}/referralEarnings`);
        let earnings = [];
        if (earningsResult.success && earningsResult.data) {
            const earningsObj = earningsResult.data;
            earnings = Object.values(earningsObj);
            earnings.sort((a, b) => b.timestamp - a.timestamp);
        }
        
        const totalEarnings = earnings.reduce((sum, e) => sum + parseFloat(e.amount || 0), 0);
        
        return {
            success: true,
            data: {
                referralCode: user.referralCode,
                referralEarnings: parseFloat(user.referralEarnings || 0),
                referralEarningsClaimed: parseFloat(user.referralEarningsClaimed || 0),
                totalEarnings: totalEarnings,
                referrals: referrals.slice(0, 50),
                earnings: earnings.slice(0, 50)
            }
        };
        
    } catch (error) {
        console.error('Get referral info error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_REFERRAL_ERROR'
        };
    }
}

// ============================================
// TASK SYSTEM - FIXED WITH ATOMIC UPDATES
// ============================================

async function initializePartnerTasks(env) {
    for (const task of PARTNER_TASKS) {
        const taskResult = await dbGet(env, `tasks/partner/${task.id}`);
        if (!taskResult.success || !taskResult.data) {
            await dbSet(env, `tasks/partner/${task.id}`, task);
        }
    }
}

async function handleCreateTask(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { type, link, targetUsers, reward } = data;
            
            if (!['channel', 'bot'].includes(type)) {
                return {
                    success: false,
                    error: 'Invalid task type. Must be channel or bot',
                    errorCode: 'INVALID_TASK_TYPE'
                };
            }
            
            const target = parseInt(targetUsers);
            
            if (!target || target < GAME_CONSTANTS.MIN_TASK_TARGET) {
                return {
                    success: false,
                    error: `Minimum target users is ${GAME_CONSTANTS.MIN_TASK_TARGET}`,
                    errorCode: 'INVALID_TARGET'
                };
            }
            
            if (!link || !link.includes('t.me/')) {
                return {
                    success: false,
                    error: 'Valid Telegram link is required',
                    errorCode: 'INVALID_LINK'
                };
            }
            
            const taskReward = GAME_CONSTANTS.TASK_REWARD;
            const totalCost = target * taskReward * 2;
            
            const userResult = await dbGet(env, `users/${userId}`);
            
            if (!userResult.success || !userResult.data) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            let user = userResult.data;
            
            const productionResult = await calculateProduction(env, userId, user);
            
            if (productionResult) {
                user = productionResult.user;
            }
            
            const atomicResult = await atomicUpdateUserResource(
                env,
                userId,
                'tonBalance',
                totalCost
            );
            
            if (!atomicResult.success) {
                if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId} (createTask), retry attempt ${attempt}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else if (atomicResult.errorCode === 'INSUFFICIENT_RESOURCE') {
                    return {
                        success: false,
                        error: 'Insufficient TON balance',
                        errorCode: 'INSUFFICIENT_TON',
                        currentBalance: atomicResult.currentBalance
                    };
                } else {
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode || 'ATOMIC_UPDATE_FAILED'
                    };
                }
            }
            
            const now = Date.now();
            const taskId = `task_${now}_${Math.random().toString(36).substring(2, 10)}`;
            
            const taskData = {
                id: taskId,
                creatorId: userId,
                type: type,
                link: link,
                targetUsers: target,
                reward: taskReward,
                completions: 0,
                completedBy: [],
                status: 'active',
                createdAt: now,
                expiresAt: now + (GAME_CONSTANTS.MAX_TASK_DURATION_DAYS * 24 * 60 * 60 * 1000),
                updatedAt: now
            };
            
            await dbSet(env, `tasks/community/${taskId}`, taskData);
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'create_task',
                taskId: taskId,
                taskType: type,
                targetUsers: target,
                cost: totalCost,
                timestamp: now
            });
            
            await notifyTaskCreated(env, userId, type, target, totalCost);
            
            return {
                success: true,
                data: {
                    taskId: taskId,
                    type: type,
                    targetUsers: target,
                    totalCost: totalCost,
                    reward: taskReward
                }
            };
            
        } catch (error) {
            console.error(`Create task error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'CREATE_TASK_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

async function handleVerifyTask(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { taskId, taskType } = data;
            
            let taskResult = await dbGet(env, `tasks/community/${taskId}`);
            let task = taskResult.data;
            let taskCategory = 'community';
            
            if (!task) {
                taskResult = await dbGet(env, `tasks/partner/${taskId}`);
                task = taskResult.data;
                taskCategory = 'partner';
            }
            
            if (!task) {
                return {
                    success: false,
                    error: 'Task not found',
                    errorCode: 'TASK_NOT_FOUND'
                };
            }
            
            if (task.status !== 'active') {
                return {
                    success: false,
                    error: 'Task is no longer active',
                    errorCode: 'TASK_INACTIVE'
                };
            }
            
            if (task.completedBy && task.completedBy.includes(userId)) {
                return {
                    success: false,
                    error: 'Task already completed',
                    errorCode: 'TASK_ALREADY_COMPLETED'
                };
            }
            
            const userResult = await dbGet(env, `users/${userId}`);
            
            if (!userResult.success || !userResult.data) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            let user = userResult.data;
            
            if (task.type === 'channel') {
                const isMember = await checkTelegramMembership(env, userId, task.link);
                
                if (!isMember) {
                    return {
                        success: false,
                        error: 'Not a member of the channel',
                        errorCode: 'NOT_MEMBER'
                    };
                }
            }
            
            const currentCompletions = task.completions || 0;
            const newCompletions = currentCompletions + 1;
            
            const taskUpdates = {
                completions: newCompletions,
                completedBy: [...(task.completedBy || []), userId],
                updatedAt: Date.now()
            };
            
            if (newCompletions >= task.targetUsers) {
                taskUpdates.status = 'completed';
            }
            
            await dbUpdate(env, `tasks/${taskCategory}/${taskId}`, taskUpdates);
            
            const reward = task.reward || GAME_CONSTANTS.TASK_REWARD;
            
            const atomicResult = await atomicUpdateUserResource(
                env,
                userId,
                'tonBalance',
                -reward
            );
            
            if (!atomicResult.success) {
                if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId} (verifyTask), retry attempt ${attempt}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else {
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode || 'ATOMIC_UPDATE_FAILED'
                    };
                }
            }
            
            const completedTasks = user.completedTasks || [];
            completedTasks.push(taskId);
            
            await dbUpdate(env, `users/${userId}`, {
                completedTasks: completedTasks
            });
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'task_reward',
                taskId: taskId,
                taskType: task.type,
                reward: reward,
                timestamp: Date.now()
            });
            
            await notifyTaskCompleted(env, userId, task.type, reward);
            
            return {
                success: true,
                data: {
                    taskId: taskId,
                    reward: reward,
                    completions: newCompletions,
                    taskCompleted: newCompletions >= task.targetUsers
                }
            };
            
        } catch (error) {
            console.error(`Verify task error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'VERIFY_TASK_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

async function handleGetTasks(env, userId) {
    try {
        await initializePartnerTasks(env);
        
        const partnerTasksResult = await dbGet(env, 'tasks/partner');
        let partnerTasks = [];
        
        if (partnerTasksResult.success && partnerTasksResult.data) {
            partnerTasks = Object.values(partnerTasksResult.data)
                .filter(t => t.status === 'active')
                .map(task => ({
                    ...task,
                    completedByUser: task.completedBy && task.completedBy.includes(userId)
                }));
        }
        
        const communityTasksResult = await dbGet(env, 'tasks/community');
        let communityTasks = [];
        
        if (communityTasksResult.success && communityTasksResult.data) {
            communityTasks = Object.values(communityTasksResult.data)
                .filter(t => t.status === 'active')
                .map(task => ({
                    ...task,
                    completedByUser: task.completedBy && task.completedBy.includes(userId)
                }));
        }
        
        return {
            success: true,
            data: {
                partner: partnerTasks,
                community: communityTasks
            }
        };
        
    } catch (error) {
        console.error('Get tasks error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_TASKS_ERROR'
        };
    }
}

// ============================================
// INITIALIZATION HANDLER
// ============================================

async function handleInitializeUser(env, userId, data) {
    try {
        const { startParam, userInfo } = data;
        
        let referredBy = null;
        if (startParam) {
            referredBy = extractReferrerFromStartParam(startParam);
            console.log('Extracted referrer:', referredBy, 'from startParam:', startParam);
        }
        
        const existingUser = await dbGet(env, `users/${userId}`);
        
        if (existingUser.success && existingUser.data) {
            console.log('User already exists:', userId);
            
            if (userInfo) {
                const updates = {};
                if (userInfo.first_name) updates.firstName = userInfo.first_name;
                if (userInfo.last_name) updates.lastName = userInfo.last_name;
                if (userInfo.username) updates.username = userInfo.username;
                if (userInfo.photo_url) updates.photoUrl = userInfo.photo_url;
                
                if (Object.keys(updates).length > 0) {
                    updates.updatedAt = Date.now();
                    await dbUpdate(env, `users/${userId}`, updates);
                    
                    if (existingUser.data.referredBy) {
                        await dbUpdate(env, `users/${existingUser.data.referredBy}/referrals/${userId}`, {
                            firstName: updates.firstName || existingUser.data.firstName,
                            lastName: updates.lastName || existingUser.data.lastName,
                            username: updates.username || existingUser.data.username,
                            photoUrl: updates.photoUrl || existingUser.data.photoUrl
                        });
                    }
                }
            }
            
            return {
                success: true,
                data: {
                    message: 'User already exists',
                    user: existingUser.data,
                    referredBy: existingUser.data.referredBy
                }
            };
        }
        
        console.log('Creating new user:', userId, 'referred by:', referredBy);
        
        const userData = await initializeUser(env, userId, userInfo || {}, startParam);
        
        return {
            success: true,
            data: {
                message: 'User initialized successfully',
                user: userData,
                referredBy: referredBy
            }
        };
        
    } catch (error) {
        console.error('Initialize user error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'INIT_USER_ERROR'
        };
    }
}

// ============================================
// LANGUAGE HANDLING
// ============================================

async function handleSetLanguage(env, userId, data) {
    try {
        const { language } = data;
        
        if (!['en', 'ru'].includes(language)) {
            return {
                success: false,
                error: 'Invalid language. Supported: en, ru',
                errorCode: 'INVALID_LANGUAGE'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        await dbUpdate(env, `users/${userId}`, {
            language: language,
            updatedAt: Date.now()
        });
        
        return {
            success: true,
            data: {
                language: language,
                message: language === 'en' ? 'Language set to English' : '–Ø–∑—ã–∫ –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ –†—É—Å—Å–∫–∏–π'
            }
        };
        
    } catch (error) {
        console.error('Set language error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'SET_LANGUAGE_ERROR'
        };
    }
}

// ============================================
// GET STATE - MAIN STATE FUNCTION
// ============================================

async function handleGetState(env, userId) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        const globalResult = await dbGet(env, 'global');
        
        let global = globalResult.data;
        
        if (!global) {
            global = await initializeGlobalState(env);
        }
        
        let user = userResult.data;
        
        if (user) {
            const productionResult = await calculateProduction(env, userId, user);
            
            if (productionResult) {
                user = productionResult.user;
            }
        } else {
            user = {
                tonBalance: 0,
                milk: 0,
                eggs: 0,
                diamond: 0,
                cows_owned: 0,
                chickens_owned: 0,
                diamond_engines_owned: 0,
                lastProduction: Date.now(),
                milkPerHour: 0,
                eggsPerHour: 0,
                secondsUntilNext: 0,
                referralCode: null,
                referredBy: null,
                referralEarnings: 0,
                referralEarningsClaimed: 0,
                language: 'en',
                firstName: '',
                lastName: '',
                username: '',
                photoUrl: '',
                activeOrdersCount: 0,
                completedTasks: []
            };
        }
        
        let referralStats = {
            totalReferrals: 0,
            totalEarnings: 0,
            recentReferrals: [],
            recentEarnings: []
        };
        
        const referralsResult = await dbGet(env, `users/${userId}/referrals`);
        
        if (referralsResult.success && referralsResult.data) {
            const referralsObj = referralsResult.data;
            const referrals = Object.entries(referralsObj).map(([key, value]) => ({
                id: key,
                userId: value.userId,
                firstName: value.firstName || 'Farmer',
                lastName: value.lastName || '',
                username: value.username || '',
                photoUrl: value.photoUrl || '',
                joinedAt: value.joinedAt,
                totalEarnedFromThisUser: value.totalEarnedFromThisUser || 0,
                lastPurchase: value.lastPurchase
            }));
            
            referralStats.totalReferrals = referrals.length;
            
            referralStats.recentReferrals = referrals
                .sort((a, b) => (b.joinedAt || 0) - (a.joinedAt || 0))
                .slice(0, 50);
        }
        
        const earningsResult = await dbGet(env, `users/${userId}/referralEarnings`);
        
        if (earningsResult.success && earningsResult.data) {
            const earningsObj = earningsResult.data;
            const earnings = Object.values(earningsObj);
            referralStats.totalEarnings = earnings.reduce((sum, e) => sum + parseFloat(e.amount || 0), 0);
            
            const recentEarnings = earnings
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, 50);
            
            referralStats.recentEarnings = recentEarnings;
        }
        
        let pendingDeposits = [];
        
        const depositsResult = await dbGet(env, `users/${userId}/deposits`);
        
        if (depositsResult.success && depositsResult.data) {
            pendingDeposits = Object.values(depositsResult.data)
                .filter(d => d.status === 'pending' || d.status === 'verifying')
                .map(d => ({
                    depositId: d.id,
                    amount: d.amount,
                    timestamp: d.createdAt,
                    status: d.status,
                    txHash: d.txHash
                }))
                .slice(0, 3);
        }
        
        let activeOrdersCount = 0;
        
        const ordersResult = await dbGet(env, `users/${userId}/orders`);
        
        if (ordersResult.success && ordersResult.data) {
            activeOrdersCount = Object.values(ordersResult.data)
                .filter(o => o.status === 'active')
                .length;
        }
        
        let marketStats = {
            milk: { sellOrders: 0, buyOrders: 0, bestSellPrice: 0, bestBuyPrice: 0, totalMilk: 0, totalEggs: 0 },
            eggs: { sellOrders: 0, buyOrders: 0, bestSellPrice: 0, bestBuyPrice: 0 }
        };
        
        const marketOrdersResult = await dbGet(env, 'orders');
        
        if (marketOrdersResult.success && marketOrdersResult.data) {
            const allOrders = Object.values(marketOrdersResult.data);
            
            const milkSellOrders = allOrders.filter(o => 
                o.resource === 'milk' && o.type === 'sell' && o.status === 'active');
            
            marketStats.milk.sellOrders = milkSellOrders.length;
            marketStats.milk.totalMilk = milkSellOrders.reduce((sum, o) => sum + o.remaining, 0);
            
            if (milkSellOrders.length > 0) {
                marketStats.milk.bestSellPrice = Math.min(...milkSellOrders.map(o => o.pricePerUnit));
            }
            
            const milkBuyOrders = allOrders.filter(o => 
                o.resource === 'milk' && o.type === 'buy' && o.status === 'active');
            
            marketStats.milk.buyOrders = milkBuyOrders.length;
            
            if (milkBuyOrders.length > 0) {
                marketStats.milk.bestBuyPrice = Math.max(...milkBuyOrders.map(o => o.pricePerUnit));
            }
            
            const eggSellOrders = allOrders.filter(o => 
                o.resource === 'eggs' && o.type === 'sell' && o.status === 'active');
            
            marketStats.eggs.sellOrders = eggSellOrders.length;
            marketStats.eggs.totalEggs = eggSellOrders.reduce((sum, o) => sum + o.remaining, 0);
            
            if (eggSellOrders.length > 0) {
                marketStats.eggs.bestSellPrice = Math.min(...eggSellOrders.map(o => o.pricePerUnit));
            }
            
            const eggBuyOrders = allOrders.filter(o => 
                o.resource === 'eggs' && o.type === 'buy' && o.status === 'active');
            
            marketStats.eggs.buyOrders = eggBuyOrders.length;
            
            if (eggBuyOrders.length > 0) {
                marketStats.eggs.bestBuyPrice = Math.max(...eggBuyOrders.map(o => o.pricePerUnit));
            }
        }
        
        const tasksResult = await handleGetTasks(env, userId);
        let tasks = tasksResult.success ? tasksResult.data : { partner: [], community: [] };
        
        // ===== Get Leaderboard Data with Global Cow Sales =====
        const leaderboardResult = await getLeaderboardData(env, userId);
        const leaderboard = leaderboardResult.success ? leaderboardResult.data : {
            isActive: true,
            totalCowSales: global.cows_sold || 0, // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ cows_sold ŸÖŸÜ global
            cowCap: GAME_CONSTANTS.LEADERBOARD_COW_CAP,
            remainingCows: Math.max(0, GAME_CONSTANTS.LEADERBOARD_COW_CAP - (global.cows_sold || 0)),
            leaderboard: [],
            currentUser: { rank: 0, cowCount: 0, points: 0, prize: 0 },
            prizesDistributed: false,
            winners: {}
        };
        
        const milkPerHour = (user.cows_owned || 0) * GAME_CONSTANTS.COW_PRODUCTION_RATE;
        const eggsPerHour = (user.chickens_owned || 0) * GAME_CONSTANTS.CHICKEN_PRODUCTION_RATE;
        
        const lastProduction = user.lastProduction || Date.now();
        const nextProduction = lastProduction + GAME_CONSTANTS.HOUR_IN_MS;
        const msUntilNext = Math.max(0, nextProduction - Date.now());
        const secondsUntilNext = Math.floor(msUntilNext / 1000);
        const minutesUntilNext = Math.floor(secondsUntilNext / 60);
        const secondsRemaining = secondsUntilNext % 60;
        
        return {
            success: true,
            data: {
                user: {
                    tonBalance: parseFloat(user.tonBalance || 0),
                    milk: parseFloat(user.milk || 0),
                    eggs: parseFloat(user.eggs || 0),
                    diamond: parseFloat(user.diamond || 0),
                    
                    cows_owned: user.cows_owned || 0,
                    chickens_owned: user.chickens_owned || 0,
                    diamond_engines_owned: user.diamond_engines_owned || 0,
                    
                    milkPerHour: milkPerHour,
                    eggsPerHour: eggsPerHour,
                    
                    lastProduction: user.lastProduction,
                    secondsUntilNext: secondsUntilNext,
                    minutesUntilNext: minutesUntilNext,
                    secondsRemaining: secondsRemaining,
                    
                    referralCode: user.referralCode,
                    referredBy: user.referredBy,
                    referralEarnings: parseFloat(user.referralEarnings || 0),
                    referralEarningsClaimed: parseFloat(user.referralEarningsClaimed || 0),
                    
                    language: user.language || 'en',
                    firstName: user.firstName || '',
                    lastName: user.lastName || '',
                    username: user.username || '',
                    photoUrl: user.photoUrl || '',
                    
                    activeOrdersCount: activeOrdersCount,
                    completedTasks: user.completedTasks || []
                },
                
                global: {
                    cows_sold: global.cows_sold || 0,
                    cows_cap: GAME_CONSTANTS.COW_GLOBAL_CAP,
                    cows_remaining: Math.max(0, GAME_CONSTANTS.COW_GLOBAL_CAP - (global.cows_sold || 0)),
                    cows_progress: ((global.cows_sold || 0) / GAME_CONSTANTS.COW_GLOBAL_CAP) * 100,
                    
                    chickens_sold: global.chickens_sold || 0,
                    chickens_cap: GAME_CONSTANTS.CHICKEN_GLOBAL_CAP,
                    chickens_remaining: Math.max(0, GAME_CONSTANTS.CHICKEN_GLOBAL_CAP - (global.chickens_sold || 0)),
                    chickens_progress: ((global.chickens_sold || 0) / GAME_CONSTANTS.CHICKEN_GLOBAL_CAP) * 100,
                    
                    chicken_unlocked: (global.cows_sold || 0) >= GAME_CONSTANTS.COW_GLOBAL_CAP,
                    diamond_unlocked: (global.cows_sold || 0) >= GAME_CONSTANTS.COW_GLOBAL_CAP && 
                                    (global.chickens_sold || 0) >= GAME_CONSTANTS.CHICKEN_GLOBAL_CAP,
                    
                    diamond_price: global.diamond_price || GAME_CONSTANTS.DIAMOND_BASE_PRICE,
                    
                    cows_until_chicken: Math.max(0, GAME_CONSTANTS.COW_GLOBAL_CAP - (global.cows_sold || 0)),
                    chickens_until_diamond: Math.max(0, GAME_CONSTANTS.CHICKEN_GLOBAL_CAP - (global.chickens_sold || 0))
                },
                
                constants: {
                    COW_PRICE: GAME_CONSTANTS.COW_PRICE,
                    COW_PRODUCTION_RATE: GAME_CONSTANTS.COW_PRODUCTION_RATE,
                    COW_HATCH_COST: GAME_CONSTANTS.COW_HATCH_COST,
                    
                    CHICKEN_PRICE: GAME_CONSTANTS.CHICKEN_PRICE,
                    CHICKEN_PRODUCTION_RATE: GAME_CONSTANTS.CHICKEN_PRODUCTION_RATE,
                    CHICKEN_HATCH_COST: GAME_CONSTANTS.CHICKEN_HATCH_COST,
                    
                    DIAMOND_ENGINE_PRICE: GAME_CONSTANTS.DIAMOND_ENGINE_PRICE,
                    DIAMOND_PRODUCTION_COST_MILK: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK,
                    DIAMOND_PRODUCTION_COST_EGG: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG,
                    
                    MIN_WITHDRAW_AMOUNT: GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT,
                    WITHDRAW_FEE_PERCENT: GAME_CONSTANTS.WITHDRAW_FEE_PERCENT,
                    MIN_DEPOSIT_AMOUNT: GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT,
                    REFERRAL_REWARD_PERCENT: GAME_CONSTANTS.REFERRAL_REWARD_PERCENT,
                    MIN_ORDER_AMOUNT: GAME_CONSTANTS.MIN_ORDER_AMOUNT,
                    MARKET_FEE_PERCENT: GAME_CONSTANTS.MARKET_FEE_PERCENT,
                    MIN_ORDER_PRICE: GAME_CONSTANTS.MIN_ORDER_PRICE,
                    ORDER_PENALTY_FEE: GAME_CONSTANTS.ORDER_PENALTY_FEE,
                    TASK_REWARD: GAME_CONSTANTS.TASK_REWARD,
                    
                    MIN_TASK_TARGET: GAME_CONSTANTS.MIN_TASK_TARGET,
                    
                    MAX_RETRY_ATTEMPTS: GAME_CONSTANTS.MAX_RETRY_ATTEMPTS,
                    MAX_ACTIVE_ORDERS: GAME_CONSTANTS.MAX_ACTIVE_ORDERS,
                    
                    // Leaderboard constants
                    LEADERBOARD_COW_CAP: GAME_CONSTANTS.LEADERBOARD_COW_CAP,
                    LEADERBOARD_TOTAL_PRIZE: GAME_CONSTANTS.LEADERBOARD_TOTAL_PRIZE,
                    LEADERBOARD_PRIZES: GAME_CONSTANTS.LEADERBOARD_PRIZES
                },
                
                referral: referralStats,
                market: marketStats,
                tasks: tasks,
                pendingDeposits: pendingDeposits,
                leaderboard: leaderboard
            }
        };
        
    } catch (error) {
        console.error('Get state error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_STATE_ERROR'
        };
    }
}
