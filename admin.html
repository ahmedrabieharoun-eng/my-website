// Cloudflare Worker لـ GLX Galaxy
export default {
    async fetch(request, env, ctx) {
        // إعداد CORS
        if (request.method === 'OPTIONS') {
            return new Response(null, {
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type, X-User-ID, X-Telegram-Data, X-Action',
                }
            });
        }
        
        const url = new URL(request.url);
        const path = url.pathname;
        
        // التحقق من المسار
        if (path !== '/api') {
            return new Response(JSON.stringify({
                success: false,
                error: 'Invalid endpoint'
            }), {
                status: 404,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        try {
            // استخراج البيانات من الطلب
            const requestData = await request.json();
            const action = request.headers.get('X-Action') || requestData.action;
            const data = requestData.data || {};
            const userId = request.headers.get('X-User-ID');
            const telegramData = request.headers.get('X-Telegram-Data');
            
            // التحقق من المصادقة
            if (!userId || !telegramData) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Authentication required'
                }), {
                    status: 401,
                    headers: { 'Content-Type': 'application/json' }
                });
            }
            
            // التحقق من بيانات Telegram
            if (!isValidTelegramData(telegramData, userId)) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Invalid Telegram data'
                }), {
                    status: 401,
                    headers: { 'Content-Type': 'application/json' }
                });
            }
            
            // معالجة الإجراءات
            let result;
            switch (action) {
                case 'initializeUser':
                    result = await handleInitializeUser(env, userId, data, telegramData);
                    break;
                    
                case 'getCompetitionData':
                    result = await handleGetCompetitionData(env, userId);
                    break;
                    
                case 'dbSet':
                    result = await handleDbSet(env, data.path, data.data);
                    break;
                    
                case 'dbGet':
                    result = await handleDbGet(env, data.path);
                    break;
                    
                case 'dbUpdate':
                    result = await handleDbUpdate(env, data.path, data.updates);
                    break;
                    
                case 'dbPush':
                    result = await handleDbPush(env, data.path, data.data);
                    break;
                    
                case 'dbTransaction':
                    result = await handleDbTransaction(env, data.path, data.transactionFunction);
                    break;
                    
                case 'dbIncrement':
                    result = await handleDbIncrement(env, data.path, data.key, data.amount);
                    break;
                    
                case 'getConfig':
                    result = await handleGetConfig();
                    break;
                    
                case 'executeSwap':
                    result = await handleExecuteSwap(env, userId, data);
                    break;
                    
                case 'verifyDeposit':
                    result = await handleVerifyDeposit(env, userId, data);
                    break;
                    
                case 'buyTickets':
                    result = await handleBuyTickets(env, userId, data);
                    break;
                    
                case 'getCompetitionLeaderboard':
                    result = await handleGetCompetitionLeaderboard(env);
                    break;
                    
                case 'getPreviousWinners':
                    result = await handleGetPreviousWinners(env);
                    break;
                    
                case 'flipCoin':
                    result = await handleFlipCoin(env, userId, data);
                    break;
                    
                case 'redeemPromoCode':
                    result = await handleRedeemPromoCode(env, userId, data);
                    break;
                    
                case 'createTask':
                    result = await handleCreateTask(env, userId, data);
                    break;
                    
                case 'verifyTaskPayment':
                    result = await handleVerifyTaskPayment(env, data.taskId);
                    break;
                    
                case 'verifyTaskChannel':
                    result = await handleVerifyTaskChannel(env, userId, data);
                    break;
                    
                case 'spinSlots':
                    result = await handleSpinSlots(env, userId);
                    break;
                    
                case 'addExtraSpin':
                    result = await handleAddExtraSpin(env, userId);
                    break;
                    
                case 'claimDailyBonus':
                    result = await handleClaimDailyBonus(env, userId);
                    break;
                    
                case 'getTransactionHistory':
                    result = await handleGetTransactionHistory(env, userId, data.limit);
                    break;
                    
                case 'getUserWithdrawals':
                    result = await handleGetUserWithdrawals(env, userId);
                    break;
                    
                case 'getWithdrawalHistory':
                    result = await handleGetWithdrawalHistory(env);
                    break;
                    
                case 'getWithdrawalStats':
                    result = await handleGetWithdrawalStats(env);
                    break;
                    
                case 'getReferredUsers':
                    result = await handleGetReferredUsers(env, userId);
                    break;
                    
                case 'getTasks':
                    result = await handleGetTasks(env, userId);
                    break;
                    
                case 'verifyTaskCompletion':
                    result = await handleVerifyTaskCompletion(env, userId, data);
                    break;
                    
                case 'handleReferral':
                    result = await handleReferral(env, data.userId, data.referrerId);
                    break;
                    
                case 'handleAdClick':
                    result = await handleAdClick(env, userId, data.adType, data.reward);
                    break;
                    
                case 'submitWithdrawal':
                    result = await handleSubmitWithdrawal(env, userId, data);
                    break;
                    
                case 'getLeaderboard':
                    result = await handleGetLeaderboard(env);
                    break;
                    
                case 'testFirebase':
                    result = await handleTestFirebase(env);
                    break;
                    
                case 'getUserData':
                    result = await handleGetUserData(env, userId);
                    break;
                    
                case 'refreshCompetition':
                    result = await handleRefreshCompetition(env);
                    break;
                    
                case 'verifyTelegramMembership':
                    result = await handleVerifyTelegramMembership(env, userId, data);
                    break;
                    
                case 'syncUserCompetitionTickets':
                    result = await handleSyncUserCompetitionTickets(env, userId);
                    break;
                    
                default:
                    result = {
                        success: false,
                        error: 'Unknown action'
                    };
            }
            
            // إرجاع النتيجة
            return new Response(JSON.stringify(result), {
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
            
        } catch (error) {
            console.error('Worker error:', error);
            
            return new Response(JSON.stringify({
                success: false,
                error: 'Internal server error',
                details: error.message
            }), {
                status: 500,
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
        }
    }
};

// التحقق من بيانات Telegram
function isValidTelegramData(telegramData, userId) {
    try {
        const params = new URLSearchParams(telegramData);
        const userParam = params.get('user');
        
        if (!userParam) return false;
        
        const userData = JSON.parse(decodeURIComponent(userParam));
        return userData.id.toString() === userId;
        
    } catch (error) {
        console.error('Telegram data validation error:', error);
        return false;
    }
}

// دالة مساعدة لإنشاء رابط Firebase
async function getFirebaseUrl(env, path) {
    const baseUrl = env.FIREBASE_DATABASE_URL.replace(/\/$/, '');
    const cleanPath = path.replace(/^\//, '');
    const apiKey = env.FIREBASE_API_KEY;
    
    if (!apiKey) {
        throw new Error('FIREBASE_API_KEY is not configured');
    }
    
    return `${baseUrl}/${cleanPath}.json?key=${apiKey}`;
}

// دالة مساعدة لضمان وجود مسابقة نشطة وجلب بياناتها
async function ensureAndGetCompetition(env, userId = null) {
    try {
        // جلب المسابقة الحالية
        const competitionResult = await handleDbGet(env, 'competition/current');
        let competitionData = competitionResult.data || {};
        
        const now = Date.now();
        const ONE_DAY_MS = 24 * 60 * 60 * 1000;
        
        // التحقق مما إذا كان يجب إنشاء مسابقة جديدة
        const shouldCreateNew = 
            !competitionData ||
            Object.keys(competitionData).length === 0 ||
            !competitionData.isActive || 
            !competitionData.endTime || 
            now > competitionData.endTime;
        
        if (shouldCreateNew) {
            console.log('Creating new competition... Current time:', now);
            
            // إذا كانت هناك مسابقة قديمة، حفظ الفائزين
            if (competitionData && competitionData.userTickets && Object.keys(competitionData.userTickets).length > 0) {
                await saveCompetitionWinners(env, competitionData);
            }
            
            // إنشاء مسابقة جديدة
            competitionData = {
                isActive: true,
                startTime: now,
                endTime: now + ONE_DAY_MS, // 24 ساعة من الآن
                totalTickets: 0,
                prizePool: 0,
                userTickets: {},
                winners: [],
                lastUpdated: now
            };
            
            // حفظ المسابقة الجديدة
            await handleDbSet(env, 'competition/current', competitionData);
            console.log('New competition created. End time:', new Date(competitionData.endTime).toISOString());
        } else {
            console.log('Existing competition found. End time:', new Date(competitionData.endTime).toISOString());
        }
        
        // حساب الوقت المتبقي
        competitionData.timeRemaining = Math.max(0, competitionData.endTime - now);
        competitionData.isActiveNow = competitionData.isActive && competitionData.timeRemaining > 0;
        
        // إذا انتهت المسابقة، إنشاء مسابقة جديدة
        if (competitionData.timeRemaining <= 0 && competitionData.isActive) {
            console.log('Competition ended, creating new one...');
            competitionData.isActive = false;
            await handleDbSet(env, 'competition/current', competitionData);
            return await ensureAndGetCompetition(env, userId);
        }
        
        // إذا تم تمرير userId، حساب تذاكره بشكل صحيح
        if (userId) {
            competitionData.userTickets = competitionData.userTickets || {};
            competitionData.userTicketCount = competitionData.userTickets[userId] || 0;
            console.log(`User ${userId} tickets in competition:`, competitionData.userTicketCount);
            
            // تحديث تذاكر المستخدم في قاعدة البيانات
            await syncUserCompetitionTickets(env, userId, competitionData.userTicketCount);
        }
        
        // إضافة التنسيق الزمني للوقت المتبقي
        competitionData.timeRemainingFormatted = formatTimeRemaining(competitionData.timeRemaining);
        
        return competitionData;
    } catch (error) {
        console.error('Error ensuring competition:', error);
        return null;
    }
}

// دالة لتنسيق الوقت المتبقي
function formatTimeRemaining(ms) {
    if (ms <= 0) return '00:00:00';
    
    const hours = Math.floor(ms / (1000 * 60 * 60));
    const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((ms % (1000 * 60)) / 1000);
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// دالة لحفظ الفائزين في المسابقة القديمة
async function saveCompetitionWinners(env, competitionData) {
    try {
        if (!competitionData.userTickets || Object.keys(competitionData.userTickets).length === 0) {
            return;
        }
        
        const userIds = Object.keys(competitionData.userTickets);
        const totalTickets = competitionData.totalTickets || 0;
        
        if (totalTickets > 0) {
            // اختيار الفائز (الذي لديه أكبر عدد تذاكر)
            let winnerId = userIds[0];
            let maxTickets = competitionData.userTickets[winnerId] || 0;
            
            for (const userId of userIds) {
                const tickets = competitionData.userTickets[userId] || 0;
                if (tickets > maxTickets) {
                    maxTickets = tickets;
                    winnerId = userId;
                }
            }
            
            // حفظ بيانات الفائز
            const winnerData = {
                userId: winnerId,
                tickets: maxTickets,
                prize: competitionData.prizePool || 0,
                timestamp: Date.now(),
                competitionEndTime: competitionData.endTime
            };
            
            await handleDbPush(env, 'competition/winners', winnerData);
            
            // منح الجائزة للمستخدم الفائز
            const userResult = await handleDbGet(env, `users/${winnerId}`);
            if (userResult.success && userResult.data) {
                const userData = userResult.data;
                const newBalance = (userData.tonBalance || 0) + (competitionData.prizePool || 0);
                await handleDbUpdate(env, `users/${winnerId}`, { 
                    tonBalance: newBalance 
                });
                
                await handleDbPush(env, `users/${winnerId}/history`, {
                    type: 'earn',
                    description: 'Competition Prize',
                    amount: competitionData.prizePool || 0,
                    currency: 'TON',
                    date: new Date().toISOString()
                });
                
                console.log(`Prize awarded to user ${winnerId}: ${competitionData.prizePool} TON`);
            }
        }
    } catch (error) {
        console.error('Error saving competition winners:', error);
    }
}

// دالة لتحديث تذاكر المسابقة للمستخدم في قاعدة البيانات
async function syncUserCompetitionTickets(env, userId, ticketCount) {
    try {
        // جلب بيانات المستخدم أولاً
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            console.log(`User ${userId} not found for ticket sync`);
            return false;
        }
        
        const userData = userResult.data;
        const currentTickets = userData.competitionTickets || 0;
        
        // تحديث فقط إذا كانت القيمة مختلفة
        if (currentTickets !== ticketCount) {
            console.log(`Syncing tickets for user ${userId}: ${currentTickets} -> ${ticketCount}`);
            await handleDbUpdate(env, `users/${userId}`, {
                competitionTickets: ticketCount,
                lastTicketSync: Date.now()
            });
            return true;
        }
        
        return false;
    } catch (error) {
        console.error('Error syncing user competition tickets:', error);
        return false;
    }
}

// وظائف إدارة قاعدة البيانات
async function handleDbSet(env, path, data) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error('Database SET error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleDbGet(env, path) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        
        return {
            success: true,
            data: data
        };
    } catch (error) {
        console.error('Database GET error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleDbUpdate(env, path, updates) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updates)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error('Database UPDATE error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleDbPush(env, path, data) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: { name: result.name }
        };
    } catch (error) {
        console.error('Database PUSH error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleDbTransaction(env, path, transactionFunction) {
    try {
        const currentData = await handleDbGet(env, path);
        
        if (!currentData.success) {
            return currentData;
        }
        
        const func = new Function('currentValue', `return ${transactionFunction}(currentValue)`);
        const newValue = func(currentData.data || null);
        
        const updateResult = await handleDbSet(env, path, newValue);
        
        return updateResult;
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleDbIncrement(env, path, key, amount) {
    try {
        const currentData = await handleDbGet(env, path);
        
        if (!currentData.success) {
            return currentData;
        }
        
        const currentValue = currentData.data[key] || 0;
        const newValue = currentValue + amount;
        
        const updates = { [key]: newValue };
        const updateResult = await handleDbUpdate(env, path, updates);
        
        return updateResult;
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

// وظيفة اختبار Firebase
async function handleTestFirebase(env) {
    try {
        console.log('Testing Firebase connection...');
        console.log('API Key:', env.FIREBASE_API_KEY ? 'Present' : 'Missing');
        console.log('DB URL:', env.FIREBASE_DATABASE_URL);
        
        // اختبار الاتصال
        const testPath = 'connection_test';
        const timestamp = Date.now();
        
        // محاولة الكتابة
        const writeUrl = await getFirebaseUrl(env, testPath);
        console.log('Write URL:', writeUrl);
        
        const writeResponse = await fetch(writeUrl, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                test: true, 
                timestamp: timestamp,
                message: 'Firebase connection test'
            })
        });
        
        console.log('Write status:', writeResponse.status);
        
        if (!writeResponse.ok) {
            const errorText = await writeResponse.text();
            console.error('Write error:', errorText);
            throw new Error(`Write failed: ${writeResponse.status} - ${errorText}`);
        }
        
        const writeResult = await writeResponse.json();
        console.log('Write result:', writeResult);
        
        // محاولة القراءة
        const readResponse = await fetch(writeUrl);
        console.log('Read status:', readResponse.status);
        
        if (!readResponse.ok) {
            const errorText = await readResponse.text();
            throw new Error(`Read failed: ${readResponse.status} - ${errorText}`);
        }
        
        const readData = await readResponse.json();
        console.log('Read data:', readData);
        
        return {
            success: true,
            message: 'Firebase connection successful',
            data: {
                writeStatus: writeResponse.status,
                readStatus: readResponse.status,
                testData: readData,
                apiKeyLength: env.FIREBASE_API_KEY ? env.FIREBASE_API_KEY.length : 0,
                databaseUrl: env.FIREBASE_DATABASE_URL
            }
        };
    } catch (error) {
        console.error('Firebase test error:', error);
        return {
            success: false,
            error: error.message,
            debug: {
                apiKey: env.FIREBASE_API_KEY ? 'Present' : 'Missing',
                apiKeyFirst10: env.FIREBASE_API_KEY ? env.FIREBASE_API_KEY.substring(0, 10) + '...' : 'None',
                dbUrl: env.FIREBASE_DATABASE_URL,
                fullUrl: env.FIREBASE_DATABASE_URL ? `${env.FIREBASE_DATABASE_URL}/test.json` : 'No URL'
            }
        };
    }
}

// وظائف التطبيق الرئيسية
async function handleInitializeUser(env, userId, data, telegramData) {
    try {
        const { user } = data;
        const fullName = `${user.first_name} ${user.last_name || ''}`.trim();
        
        // استخراج صورة المستخدم من بيانات Telegram
        let photoUrl = 'https://i.ibb.co/tTkJX1Qy/logo.png'; // صورة افتراضية
        
        try {
            const params = new URLSearchParams(telegramData);
            const userParam = params.get('user');
            
            if (userParam) {
                const telegramUserData = JSON.parse(decodeURIComponent(userParam));
                // صورة المستخدم من Telegram
                if (telegramUserData.photo_url) {
                    photoUrl = telegramUserData.photo_url;
                } else if (telegramUserData.username) {
                    // أو استخدام صورة افتراضية بناءً على اسم المستخدم
                    photoUrl = `https://ui-avatars.com/api/?name=${encodeURIComponent(telegramUserData.username)}&background=random&color=fff`;
                }
            }
        } catch (photoError) {
            console.log('Could not extract user photo:', photoError);
        }
        
        // 1. أولاً: ضمان وجود مسابقة نشطة وجلب بياناتها
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to initialize competition'
            };
        }
        
        // 2. جلب بيانات المستخدم
        const userResult = await handleDbGet(env, `users/${userId}`);
        let userData = userResult.data;
        
        // احصل على عدد التذاكر الحقيقي من المسابقة
        const realTicketCount = competitionData.userTicketCount || 0;
        
        if (!userData) {
            // إنشاء مستخدم جديد مع الصورة وعدد التذاكر الحقيقي
            userData = {
                id: userId,
                name: fullName,
                photoUrl: photoUrl, // حفظ صورة المستخدم
                dogsBalance: 500,
                tonBalance: 0.00,
                adsWatched: 0,
                adsMonetag: 0,
                adsGiga: 0,
                adsAdsgram: 0,
                completedTasks: {},
                history: {},
                referrals: 0,
                dailyStreak: 0,
                lastDailyClaim: 0,
                extraSpins: 1,
                referredUsers: [],
                usedPromoCodes: [],
                joinDate: Date.now(),
                lastAdDate: new Date().toDateString(),
                competitionTickets: realTicketCount, // استخدم القيمة الحقيقية من البداية
                lastTicketSync: Date.now()
            };
            
            await handleDbSet(env, `users/${userId}`, userData);
            
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'earn',
                description: 'Welcome Bonus',
                amount: 500,
                currency: 'GLX',
                date: new Date().toISOString()
            });
        } else {
            // تحديث الاسم والصورة إذا تغيرت
            const updates = {};
            
            if (userData.name !== fullName) {
                updates.name = fullName;
            }
            
            // تحديث الصورة إذا كانت غير موجودة أو مختلفة
            if (!userData.photoUrl || userData.photoUrl === 'https://i.ibb.co/tTkJX1Qy/logo.png') {
                updates.photoUrl = photoUrl;
            }
            
            // تحديث عدد تذاكر المسابقة من المسابقة الحالية (هام: حتى لو كانت 0)
            if (userData.competitionTickets !== realTicketCount) {
                updates.competitionTickets = realTicketCount;
                updates.lastTicketSync = Date.now();
                console.log(`Updating user ${userId} tickets from ${userData.competitionTickets} to ${realTicketCount}`);
            }
            
            if (Object.keys(updates).length > 0) {
                await handleDbUpdate(env, `users/${userId}`, updates);
            }
            
            // إعادة تعيين عداد الإعلانات إذا تغير اليوم
            const today = new Date().toDateString();
            if (userData.lastAdDate !== today) {
                const resetData = {
                    adsWatched: 0,
                    adsMonetag: 0,
                    adsGiga: 0,
                    adsAdsgram: 0,
                    lastAdDate: today
                };
                
                await handleDbUpdate(env, `users/${userId}`, resetData);
            }
            
            // تحديث بيانات المستخدم بعد التغييرات
            const updatedResult = await handleDbGet(env, `users/${userId}`);
            userData = updatedResult.data || userData;
        }
        
        // جلب الإعدادات
        const settingsResult = await handleGetConfig();
        const settings = settingsResult.data?.settings || {};
        
        // التأكد من أن عدد التذاكر يعكس القيمة الحقيقية
        const userTickets = realTicketCount;
        
        return {
            success: true,
            data: {
                userData: {
                    ...userData,
                    competitionTickets: userTickets // تحديث حقل التذاكر بالقيمة الحقيقية
                },
                settings: settings,
                contest: {
                    yourTickets: userTickets,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    isActive: competitionData.isActiveNow,
                    endTime: competitionData.endTime,
                    startTime: competitionData.startTime,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted || '24:00:00'
                }
            }
        };
    } catch (error) {
        console.error('Initialize user error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleGetConfig() {
    try {
        const settings = {
            adRewardMonetag: 1000,
            adRewardGiga: 2000,
            adRewardAdsgram: 2000,
            limitMonetag: 50,
            limitGiga: 300,
            limitAdsgram: 300,
            minTonWithdrawal: 0.05,
            minFaucetPayWithdrawal: 0.0001,
            referralReward: 500,
            pricePerClick: 0.0015,
            botUsername: '@testtt1257bot',
            botWallet: 'UQB2IqqJtC8NtRgxksq80c_FC8RqShxpGDKA3e4aJFwjvwgv',
            botToken: '7066931017:AAHwuXbgaKHNrHrbf6jaoC8LDk0lSCPimgI'
        };
        
        return {
            success: true,
            data: { settings }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleExecuteSwap(env, userId, data) {
    try {
        const { type, amount, tonValue, glxValue } = data;
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { success: false, error: 'User not found' };
        }
        
        const userData = userResult.data;
        let updates = {};
        let historyEntry = {};
        
        if (type === 'glx_to_ton') {
            if (userData.dogsBalance < amount) {
                return { success: false, error: 'Insufficient GLX balance' };
            }
            
            updates.dogsBalance = userData.dogsBalance - amount;
            updates.tonBalance = (userData.tonBalance || 0) + tonValue;
            
            historyEntry = {
                type: 'swap_out',
                description: 'Swap GLX to TON',
                amount: amount,
                currency: 'GLX',
                date: new Date().toISOString()
            };
            
            await handleDbPush(env, `users/${userId}/history`, historyEntry);
            
            historyEntry = {
                type: 'swap_in',
                description: 'Received from GLX Swap',
                amount: tonValue,
                currency: 'TON',
                date: new Date().toISOString()
            };
            
        } else if (type === 'ton_to_glx') {
            if ((userData.tonBalance || 0) < amount) {
                return { success: false, error: 'Insufficient TON balance' };
            }
            
            updates.tonBalance = (userData.tonBalance || 0) - amount;
            updates.dogsBalance = userData.dogsBalance + glxValue;
            
            historyEntry = {
                type: 'swap_out',
                description: 'Swap TON to GLX',
                amount: amount,
                currency: 'TON',
                date: new Date().toISOString()
            };
            
            await handleDbPush(env, `users/${userId}/history`, historyEntry);
            
            historyEntry = {
                type: 'swap_in',
                description: 'Received from TON Swap',
                amount: glxValue,
                currency: 'GLX',
                date: new Date().toISOString()
            };
        } else {
            return { success: false, error: 'Invalid swap type' };
        }
        
        await handleDbUpdate(env, `users/${userId}`, updates);
        
        await handleDbPush(env, `users/${userId}/history`, historyEntry);
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || { ...userData, ...updates };
        
        return {
            success: true,
            data: {
                newGLXBalance: updatedUserData.dogsBalance,
                newTONBalance: updatedUserData.tonBalance
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleVerifyDeposit(env, userId, data) {
    try {
        const { memo, amount } = data;
        
        const currentTime = Date.now();
        const memoTime = parseInt(memo.split('_').pop());
        
        if (currentTime - memoTime > 30000) {
            const userResult = await handleDbGet(env, `users/${userId}`);
            if (!userResult.success) {
                return { success: false, error: 'User not found' };
            }
            
            const userData = userResult.data;
            const newBalance = (userData.tonBalance || 0) + amount;
            
            await handleDbUpdate(env, `users/${userId}`, { tonBalance: newBalance });
            
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'deposit',
                description: `TON Deposit #${memo.substring(0, 8)}`,
                amount: amount,
                currency: 'TON',
                date: new Date().toISOString()
            });
            
            return {
                success: true,
                data: {
                    newBalance: newBalance,
                    txHash: memo.substring(0, 12)
                }
            };
        } else {
            return { success: false, error: 'Deposit not confirmed yet' };
        }
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleBuyTickets(env, userId, data) {
    try {
        const { tickets, totalCost } = data;
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { success: false, error: 'User not found' };
        }
        
        const userData = userResult.data;
        
        if (userData.dogsBalance < totalCost) {
            return { success: false, error: 'Insufficient GLX balance' };
        }
        
        const newBalance = userData.dogsBalance - totalCost;
        
        // تحديث رصيد المستخدم أولاً
        await handleDbUpdate(env, `users/${userId}`, { 
            dogsBalance: newBalance
        });
        
        // تأكد من وجود مسابقة نشطة
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return { success: false, error: 'No active competition found' };
        }
        
        // تحديث تذاكر المستخدم في المسابقة
        const currentUserTickets = competitionData.userTickets[userId] || 0;
        competitionData.userTickets[userId] = currentUserTickets + tickets;
        
        // تحديث الإحصائيات العامة
        competitionData.totalTickets = (competitionData.totalTickets || 0) + tickets;
        competitionData.prizePool = competitionData.totalTickets * 0.001;
        
        // حفظ المسابقة المحدثة
        await handleDbSet(env, 'competition/current', {
            isActive: competitionData.isActive,
            startTime: competitionData.startTime,
            endTime: competitionData.endTime,
            totalTickets: competitionData.totalTickets,
            prizePool: competitionData.prizePool,
            userTickets: competitionData.userTickets,
            winners: competitionData.winners || [],
            lastUpdated: Date.now()
        });
        
        // تحديث عدد تذاكر المستخدم في بياناته الشخصية
        const newTicketCount = competitionData.userTickets[userId];
        await handleDbUpdate(env, `users/${userId}`, {
            competitionTickets: newTicketCount,
            lastTicketSync: Date.now()
        });
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'spend',
            description: `Bought ${tickets} Competition Ticket${tickets > 1 ? 's' : ''}`,
            amount: totalCost,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        // حساب الوقت المتبقي
        const now = Date.now();
        const timeRemaining = Math.max(0, competitionData.endTime - now);
        const timeRemainingFormatted = formatTimeRemaining(timeRemaining);
        
        return {
            success: true,
            data: {
                newBalance: updatedUserData.dogsBalance,
                userTickets: competitionData.userTickets[userId],
                totalTickets: competitionData.totalTickets,
                prizePool: competitionData.prizePool,
                contestEndTime: competitionData.endTime,
                timeRemaining: timeRemaining,
                timeRemainingFormatted: timeRemainingFormatted,
                userCompetitionTickets: newTicketCount
            }
        };
    } catch (error) {
        console.error('Buy tickets error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleGetCompetitionLeaderboard(env) {
    try {
        // تأكد من وجود مسابقة نشطة
        const competitionData = await ensureAndGetCompetition(env);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'No active competition found'
            };
        }
        
        const userTickets = competitionData.userTickets || {};
        const leaderboard = [];
        
        for (const [userId, tickets] of Object.entries(userTickets)) {
            if (tickets > 0) {
                const userResult = await handleDbGet(env, `users/${userId}`);
                if (userResult.success && userResult.data) {
                    leaderboard.push({
                        userId: userId,
                        name: userResult.data.name || 'Anonymous',
                        photoUrl: userResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                        tickets: tickets
                    });
                }
            }
        }
        
        leaderboard.sort((a, b) => b.tickets - a.tickets);
        
        return {
            success: true,
            data: {
                leaderboard: leaderboard.slice(0, 10),
                contest: {
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    endTime: competitionData.endTime,
                    startTime: competitionData.startTime,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted,
                    isActive: competitionData.isActiveNow
                }
            }
        };
    } catch (error) {
        console.error('Get competition leaderboard error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleGetPreviousWinners(env) {
    try {
        const winnersResult = await handleDbGet(env, 'competition/winners');
        const winnersData = winnersResult.data || {};
        
        const winners = [];
        
        for (const [key, winner] of Object.entries(winnersData)) {
            if (winner.userId) {
                const userResult = await handleDbGet(env, `users/${winner.userId}`);
                if (userResult.success && userResult.data) {
                    winners.push({
                        userId: winner.userId,
                        name: userResult.data.name || 'Anonymous',
                        photoUrl: userResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                        tickets: winner.tickets || 0,
                        prize: winner.prize || 0,
                        timestamp: winner.timestamp || Date.now()
                    });
                }
            }
        }
        
        winners.sort((a, b) => b.timestamp - a.timestamp);
        
        return {
            success: true,
            data: {
                winners: winners.slice(0, 10)
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleFlipCoin(env, userId, data) {
    try {
        const { betAmount, chosenSide } = data;
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { success: false, error: 'User not found' };
        }
        
        const userData = userResult.data;
        
        if (userData.dogsBalance < betAmount) {
            return { success: false, error: 'Insufficient GLX balance' };
        }
        
        const newBalance = userData.dogsBalance - betAmount;
        await handleDbUpdate(env, `users/${userId}`, { dogsBalance: newBalance });
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'loss',
            description: `Coin Flip Bet (${chosenSide.toUpperCase()})`,
            amount: betAmount,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        const randomNum = Math.random() * 100;
        const isWin = randomNum < 45;
        const resultSide = isWin ? chosenSide : (chosenSide === 'glx' ? 'gold' : 'glx');
        const winAmount = isWin ? betAmount * 2 : 0;
        
        if (isWin) {
            const finalBalance = newBalance + winAmount;
            await handleDbUpdate(env, `users/${userId}`, { dogsBalance: finalBalance });
            
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'earn',
                description: `Coin Flip Win (${chosenSide})`,
                amount: winAmount,
                currency: 'GLX',
                date: new Date().toISOString()
            });
        }
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        return {
            success: true,
            data: {
                isWin: isWin,
                resultSide: resultSide,
                winAmount: winAmount,
                newBalance: isWin ? newBalance + winAmount : newBalance,
                currentBalance: updatedUserData.dogsBalance
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleRedeemPromoCode(env, userId, data) {
    try {
        const { code } = data;
        
        const validCodes = {
            'WELCOME100': 100,
            'GALAXY500': 500,
            'STAR1000': 1000,
            'BONUS2000': 2000,
            'VIP5000': 5000
        };
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { success: false, error: 'User not found' };
        }
        
        const userData = userResult.data;
        const usedCodes = userData.usedPromoCodes || [];
        
        if (!validCodes[code]) {
            return { success: false, error: 'Invalid or expired promo code' };
        }
        
        if (usedCodes.includes(code)) {
            return { success: false, error: 'This code has already been used' };
        }
        
        const reward = validCodes[code];
        
        const newBalance = userData.dogsBalance + reward;
        await handleDbUpdate(env, `users/${userId}`, { dogsBalance: newBalance });
        
        usedCodes.push(code);
        await handleDbUpdate(env, `users/${userId}`, { usedPromoCodes: usedCodes });
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: `Promo Code: ${code}`,
            amount: reward,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        return {
            success: true,
            data: {
                reward: reward,
                newBalance: updatedUserData.dogsBalance
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleCreateTask(env, userId, data) {
    try {
        const { taskId, name, link, category, count, cost } = data;
        
        const newTask = {
            id: taskId,
            title: name,
            description: `Reward: ${category.toUpperCase()}`,
            link: link,
            reward: 2000,
            category: 'community',
            total: count,
            remaining: count,
            status: 'pending',
            creator: userId,
            cost: cost,
            createdAt: Date.now()
        };
        
        await handleDbSet(env, `tasks/${taskId}`, newTask);
        
        return {
            success: true,
            data: { taskId: taskId }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleVerifyTaskPayment(env, taskId) {
    try {
        const taskResult = await handleDbGet(env, `tasks/${taskId}`);
        if (!taskResult.success || !taskResult.data) {
            return { success: false, error: 'Task not found' };
        }
        
        const task = taskResult.data;
        
        if (task.status === 'pending') {
            await handleDbUpdate(env, `tasks/${taskId}`, { status: 'active' });
            
            return {
                success: true,
                data: { verified: true }
            };
        } else if (task.status === 'active') {
            return {
                success: true,
                data: { verified: true }
            };
        } else {
            return { success: false, error: 'Payment not found' };
        }
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

// دالة جديدة للتحقق من الاشتراك في قناة Telegram
async function handleVerifyTaskChannel(env, userId, data) {
    try {
        const { taskId, channelUsername } = data;
        
        // جلب بيانات المستخدم
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { success: false, error: 'User not found' };
        }
        
        const userData = userResult.data;
        const completedTasks = userData.completedTasks || {};
        
        // التحقق مما إذا كانت المهمة مكتملة بالفعل
        if (completedTasks[taskId]) {
            return { success: false, error: 'Task already completed' };
        }
        
        // هنا يمكنك إضافة التحقق من الاشتراك في القناة باستخدام Telegram Bot API
        // يتم إضافة token البوت في بيانات البيئة
        const botToken = env.TELEGRAM_BOT_TOKEN || '7066931017:AAHwuXbgaKHNrHrbf6jaoC8LDk0lSCPimgI';
        
        // استخدام Telegram Bot API للتحقق من عضوية المستخدم في القناة
        const chatMemberUrl = `https://api.telegram.org/bot${botToken}/getChatMember`;
        
        const response = await fetch(chatMemberUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                chat_id: channelUsername,
                user_id: parseInt(userId)
            })
        });
        
        if (!response.ok) {
            return { 
                success: false, 
                error: 'Failed to verify channel membership',
                details: await response.text()
            };
        }
        
        const result = await response.json();
        
        // التحقق مما إذا كان المستخدم عضوًا في القناة
        const isMember = result.ok && 
            (result.result.status === 'member' || 
             result.result.status === 'administrator' || 
             result.result.status === 'creator');
        
        if (!isMember) {
            return { success: false, error: 'You are not a member of this channel' };
        }
        
        // إذا كان المستخدم عضوًا، تحديث بيانات المهمة
        completedTasks[taskId] = true;
        await handleDbUpdate(env, `users/${userId}`, { 
            completedTasks: completedTasks,
            dogsBalance: (userData.dogsBalance || 0) + 2000
        });
        
        // تحديث المهمة في قاعدة البيانات
        const taskResult = await handleDbGet(env, `tasks/${taskId}`);
        if (taskResult.success && taskResult.data) {
            const task = taskResult.data;
            if (task.remaining !== undefined && task.remaining > 0) {
                await handleDbUpdate(env, `tasks/${taskId}`, { 
                    remaining: task.remaining - 1 
                });
            }
        }
        
        // إضافة إلى سجل المعاملات
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: `Joined Telegram Channel: ${channelUsername}`,
            amount: 2000,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        return {
            success: true,
            data: {
                verified: true,
                reward: 2000,
                newBalance: (userData.dogsBalance || 0) + 2000
            }
        };
        
    } catch (error) {
        console.error('Verify task channel error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

// دالة للتحقق من عضوية Telegram بشكل عام
async function handleVerifyTelegramMembership(env, userId, data) {
    try {
        const { channelUsername } = data;
        
        const botToken = env.TELEGRAM_BOT_TOKEN || '7066931017:AAHwuXbgaKHNrHrbf6jaoC8LDk0lSCPimgI';
        
        const chatMemberUrl = `https://api.telegram.org/bot${botToken}/getChatMember`;
        
        const response = await fetch(chatMemberUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                chat_id: channelUsername,
                user_id: parseInt(userId)
            })
        });
        
        if (!response.ok) {
            return { 
                success: false, 
                error: 'Failed to verify membership',
                details: await response.text()
            };
        }
        
        const result = await response.json();
        
        const isMember = result.ok && 
            (result.result.status === 'member' || 
             result.result.status === 'administrator' || 
             result.result.status === 'creator');
        
        return {
            success: true,
            data: {
                isMember: isMember,
                channelUsername: channelUsername,
                userId: userId,
                status: isMember ? 'member' : 'not_member'
            }
        };
        
    } catch (error) {
        console.error('Verify telegram membership error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleSpinSlots(env, userId) {
    try {
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { success: false, error: 'User not found' };
        }
        
        const userData = userResult.data;
        
        if ((userData.extraSpins || 0) <= 0) {
            return { success: false, error: 'No spins left' };
        }
        
        const newSpins = (userData.extraSpins || 1) - 1;
        await handleDbUpdate(env, `users/${userId}`, { extraSpins: newSpins });
        
        const symbols = ['🌟', '🪐', '💫', '⭐', '🚀', '🌌'];
        const results = [
            symbols[Math.floor(Math.random() * symbols.length)],
            symbols[Math.floor(Math.random() * symbols.length)],
            symbols[Math.floor(Math.random() * symbols.length)]
        ];
        
        let winAmount = 0;
        const resultString = results.join('');
        
        if (resultString === '🌟🌟🌟') winAmount = 10000;
        else if (resultString === '🪐🪐🪐') winAmount = 5000;
        else if (resultString === '💫💫💫') winAmount = 2500;
        else if (resultString === '⭐⭐⭐') winAmount = 1200;
        else if (results[0] === '🌟' && results[1] === '🌟') winAmount = 700;
        else if (results[1] === '🌟' && results[2] === '🌟') winAmount = 700;
        else if (results[0] === results[1] || results[1] === results[2] || results[0] === results[2]) winAmount = 500;
        
        if (winAmount > 0) {
            const newBalance = userData.dogsBalance + winAmount;
            await handleDbUpdate(env, `users/${userId}`, { dogsBalance: newBalance });
            
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'earn',
                description: `Galaxy Slots Win (${resultString})`,
                amount: winAmount,
                currency: 'GLX',
                date: new Date().toISOString()
            });
            
            // جلب بيانات المستخدم المحدثة
            const updatedUserResult = await handleDbGet(env, `users/${userId}`);
            const updatedUserData = updatedUserResult.data || userData;
            
            return {
                success: true,
                data: {
                    results: results,
                    winAmount: winAmount,
                    newBalance: updatedUserData.dogsBalance,
                    newSpins: newSpins
                }
            };
        } else {
            // جلب بيانات المستخدم المحدثة
            const updatedUserResult = await handleDbGet(env, `users/${userId}`);
            const updatedUserData = updatedUserResult.data || userData;
            
            return {
                success: true,
                data: {
                    results: results,
                    winAmount: 0,
                    newBalance: updatedUserData.dogsBalance,
                    newSpins: newSpins
                }
            };
        }
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleAddExtraSpin(env, userId) {
    try {
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { success: false, error: 'User not found' };
        }
        
        const userData = userResult.data;
        
        const newSpins = (userData.extraSpins || 0) + 1;
        await handleDbUpdate(env, `users/${userId}`, { extraSpins: newSpins });
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: 'Extra Spin from Ad',
            amount: 1,
            currency: 'Spin',
            date: new Date().toISOString()
        });
        
        return {
            success: true,
            data: {
                newSpins: newSpins
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleClaimDailyBonus(env, userId) {
    try {
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { success: false, error: 'User not found' };
        }
        
        const userData = userResult.data;
        const now = Date.now();
        const msInDay = 86400000;
        
        let streak = userData.dailyStreak || 0;
        const lastClaim = userData.lastDailyClaim || 0;
        
        if (now - lastClaim > 172800000) {
            streak = 0;
        }
        
        const rewards = [2000, 3000, 5000, 7000, 9000, 12000, 15000];
        const reward = rewards[Math.min(streak, rewards.length - 1)] || 100;
        
        const updates = {
            lastDailyClaim: now,
            dailyStreak: streak + 1,
            dogsBalance: userData.dogsBalance + reward
        };
        
        await handleDbUpdate(env, `users/${userId}`, updates);
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: `Daily Login Day ${streak + 1}`,
            amount: reward,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        return {
            success: true,
            data: {
                reward: reward,
                lastDailyClaim: now,
                dailyStreak: streak + 1,
                newBalance: updatedUserData.dogsBalance
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleGetTransactionHistory(env, userId, limit = 50) {
    try {
        const historyResult = await handleDbGet(env, `users/${userId}/history`);
        const historyData = historyResult.data || {};
        
        const historyArray = Object.values(historyData)
            .sort((a, b) => new Date(b.date) - new Date(a.date))
            .slice(0, limit);
        
        return {
            success: true,
            data: {
                history: historyArray
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleGetUserWithdrawals(env, userId) {
    try {
        const withdrawalsResult = await handleDbGet(env, 'withdrawals');
        const withdrawalsData = withdrawalsResult.data || {};
        
        const userWithdrawals = [];
        
        for (const [key, withdrawal] of Object.entries(withdrawalsData)) {
            if (withdrawal.userId === userId) {
                userWithdrawals.push({
                    key: key,
                    ...withdrawal
                });
            }
        }
        
        userWithdrawals.sort((a, b) => b.timestamp - a.timestamp);
        
        return {
            success: true,
            data: {
                withdrawals: userWithdrawals
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleGetWithdrawalHistory(env) {
    try {
        const withdrawalsResult = await handleDbGet(env, 'withdrawals/completed');
        const withdrawalsData = withdrawalsResult.data || {};
        
        const withdrawals = [];
        
        for (const [key, withdrawal] of Object.entries(withdrawalsData)) {
            if (withdrawal.status === 'completed' || withdrawal.processed === true) {
                const userResult = await handleDbGet(env, `users/${withdrawal.userId}`);
                if (userResult.success && userResult.data) {
                    withdrawals.push({
                        ...withdrawal,
                        key: key,
                        name: userResult.data.name || 'Anonymous',
                        photoUrl: userResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png'
                    });
                }
            }
        }
        
        withdrawals.sort((a, b) => b.timestamp - a.timestamp);
        
        return {
            success: true,
            data: {
                withdrawals: withdrawals.slice(0, 50)
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleGetWithdrawalStats(env) {
    try {
        const withdrawalsResult = await handleDbGet(env, 'withdrawals');
        const withdrawalsData = withdrawalsResult.data || {};
        
        let completedCount = 0;
        let totalPaid = 0;
        let pendingCount = 0;
        
        for (const [key, withdrawal] of Object.entries(withdrawalsData)) {
            if (withdrawal.status === 'completed' || withdrawal.processed === true) {
                completedCount++;
                totalPaid += parseFloat(withdrawal.amount || 0);
            } else if (withdrawal.status === 'pending') {
                pendingCount++;
            }
        }
        
        return {
            success: true,
            data: {
                completedCount: completedCount,
                totalPaid: totalPaid.toFixed(4),
                pendingCount: pendingCount,
                totalWithdrawals: Object.keys(withdrawalsData).length
            }
        };
    } catch (error) {
        console.error('Get withdrawal stats error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleGetReferredUsers(env, userId) {
    try {
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { success: false, error: 'User not found' };
        }
        
        const userData = userResult.data;
        const referredUsers = userData.referredUsers || [];
        
        const referredUsersData = [];
        
        for (const referredUserId of referredUsers) {
            const referredUserResult = await handleDbGet(env, `users/${referredUserId}`);
            if (referredUserResult.success && referredUserResult.data) {
                referredUsersData.push({
                    userId: referredUserId,
                    name: referredUserResult.data.name || 'Anonymous User',
                    photoUrl: referredUserResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                    joinDate: referredUserResult.data.joinDate,
                    dogsBalance: referredUserResult.data.dogsBalance || 0
                });
            }
        }
        
        return {
            success: true,
            data: {
                referredUsers: referredUsersData
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleGetTasks(env, userId) {
    try {
        const tasksResult = await handleDbGet(env, 'tasks');
        const tasksData = tasksResult.data || {};
        
        const activeTasks = [];
        
        for (const [taskId, task] of Object.entries(tasksData)) {
            if (task.status === 'active' && (task.remaining === undefined || task.remaining > 0)) {
                activeTasks.push({
                    id: taskId,
                    ...task
                });
            }
        }
        
        return {
            success: true,
            data: {
                tasks: activeTasks
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleVerifyTaskCompletion(env, userId, data) {
    try {
        const { taskId, reward, title } = data;
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { success: false, error: 'User not found' };
        }
        
        const userData = userResult.data;
        
        const taskResult = await handleDbGet(env, `tasks/${taskId}`);
        if (!taskResult.success || !taskResult.data) {
            return { success: false, error: 'Task not found' };
        }
        
        const task = taskResult.data;
        
        const completedTasks = userData.completedTasks || {};
        if (completedTasks[taskId]) {
            return { success: false, error: 'Task already completed' };
        }
        
        if (task.remaining !== undefined && task.remaining <= 0) {
            return { success: false, error: 'No rewards left for this task' };
        }
        
        const newBalance = userData.dogsBalance + parseInt(reward);
        
        const updates = {};
        if (task.remaining !== undefined) {
            updates.remaining = task.remaining - 1;
        }
        
        const userUpdates = {
            dogsBalance: newBalance
        };
        
        completedTasks[taskId] = true;
        userUpdates.completedTasks = completedTasks;
        
        await handleDbUpdate(env, `users/${userId}`, userUpdates);
        
        if (Object.keys(updates).length > 0) {
            await handleDbUpdate(env, `tasks/${taskId}`, updates);
        }
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: `Mission: ${title}`,
            amount: parseInt(reward),
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        return {
            success: true,
            data: {
                newBalance: updatedUserData.dogsBalance
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleReferral(env, userId, referrerId) {
    try {
        if (!referrerId || referrerId === userId) {
            return { success: false, error: 'Invalid referrer' };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (userResult.success && userResult.data && userResult.data.referrer) {
            return { success: false, error: 'Already referred' };
        }
        
        await handleDbUpdate(env, `users/${userId}`, { referrer: referrerId, joinDate: Date.now() });
        
        const referrerResult = await handleDbGet(env, `users/${referrerId}`);
        if (!referrerResult.success || !referrerResult.data) {
            return { success: true, data: { referred: true } };
        }
        
        const referrerData = referrerResult.data;
        
        const referredUsers = referrerData.referredUsers || [];
        if (!referredUsers.includes(userId)) {
            referredUsers.push(userId);
        }
        
        const updates = {
            referredUsers: referredUsers,
            referrals: (referrerData.referrals || 0) + 1,
            dogsBalance: (referrerData.dogsBalance || 0) + 500
        };
        
        await handleDbUpdate(env, `users/${referrerId}`, updates);
        
        await handleDbPush(env, `users/${referrerId}/history`, {
            type: 'referral',
            description: 'Friend Invited',
            amount: 500,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        return {
            success: true,
            data: { referred: true }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleAdClick(env, userId, adType, reward) {
    try {
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { success: false, error: 'User not found' };
        }
        
        const userData = userResult.data;
        
        const adCountField = `ads${adType.charAt(0).toUpperCase() + adType.slice(1)}`;
        const currentCount = userData[adCountField] || 0;
        
        const updates = {
            [adCountField]: currentCount + 1,
            adsWatched: (userData.adsWatched || 0) + 1,
            dogsBalance: (userData.dogsBalance || 0) + reward
        };
        
        await handleDbUpdate(env, `users/${userId}`, updates);
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: `${adType} Ad Reward`,
            amount: reward,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || { ...userData, ...updates };
        
        return {
            success: true,
            data: {
                [adCountField]: currentCount + 1,
                adsWatched: updates.adsWatched,
                newBalance: updatedUserData.dogsBalance
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleSubmitWithdrawal(env, userId, data) {
    try {
        const { method, account, amount, maskedAccount, memo } = data;
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { success: false, error: 'User not found' };
        }
        
        const userData = userResult.data;
        
        if ((userData.tonBalance || 0) < amount) {
            return { success: false, error: 'Insufficient TON balance' };
        }
        
        const newBalance = (userData.tonBalance || 0) - amount;
        await handleDbUpdate(env, `users/${userId}`, { tonBalance: newBalance });
        
        const withdrawalId = `withdrawal_${Date.now()}`;
        const withdrawalData = {
            userId: userId,
            account: account,
            maskedAccount: maskedAccount || account,
            amount: amount,
            method: method,
            memo: memo || '',
            status: 'pending',
            timestamp: Date.now(),
            processed: false
        };
        
        await handleDbSet(env, `withdrawals/${withdrawalId}`, withdrawalData);
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'withdraw',
            description: `${method === 'ton' ? 'TON Wallet' : 'FaucetPay'} Withdrawal`,
            amount: amount,
            currency: 'TON',
            date: new Date().toISOString()
        });
        
        return {
            success: true,
            data: {
                newBalance: newBalance,
                withdrawalId: withdrawalId
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleGetLeaderboard(env) {
    try {
        const usersResult = await handleDbGet(env, 'users');
        const usersData = usersResult.data || {};
        
        const users = [];
        
        for (const [userId, userData] of Object.entries(usersData)) {
            users.push({
                userId: userId,
                name: userData.name || 'Anonymous',
                photoUrl: userData.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                dogsBalance: userData.dogsBalance || 0,
                referrals: userData.referrals || 0
            });
        }
        
        const byInvites = [...users].sort((a, b) => b.referrals - a.referrals);
        
        const byGLX = [...users].sort((a, b) => b.dogsBalance - a.dogsBalance);
        
        return {
            success: true,
            data: {
                byInvites: byInvites.slice(0, 50),
                byGLX: byGLX.slice(0, 50)
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

// وظيفة جديدة: جلب بيانات المسابقة فقط
async function handleGetCompetitionData(env, userId = null) {
    try {
        // أولاً: ضمان وجود مسابقة نشطة
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to load competition data'
            };
        }
        
        // جلب المتصدرين
        const userTickets = competitionData.userTickets || {};
        const leaderboard = [];
        
        for (const [uId, tickets] of Object.entries(userTickets)) {
            if (tickets > 0) {
                const userResult = await handleDbGet(env, `users/${uId}`);
                if (userResult.success && userResult.data) {
                    leaderboard.push({
                        userId: uId,
                        name: userResult.data.name || 'Anonymous',
                        photoUrl: userResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                        tickets: tickets
                    });
                }
            }
        }
        
        leaderboard.sort((a, b) => b.tickets - a.tickets);
        
        return {
            success: true,
            data: {
                competitionData: {
                    isActive: competitionData.isActive,
                    startTime: competitionData.startTime,
                    endTime: competitionData.endTime,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted,
                    isActiveNow: competitionData.isActiveNow
                },
                userTickets: userId ? competitionData.userTicketCount || 0 : 0,
                leaderboard: leaderboard.slice(0, 10)
            }
        };
    } catch (error) {
        console.error('Error getting competition data:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

// وظيفة جديدة: جلب بيانات المستخدم المحدثة
async function handleGetUserData(env, userId) {
    try {
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { success: false, error: 'User not found' };
        }
        
        // جلب بيانات المسابقة الحالية للمستخدم
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to load competition data'
            };
        }
        
        // التأكد من تحديث حقل competitionTickets في بيانات المستخدم
        const currentUserTickets = competitionData.userTicketCount || 0;
        if (userResult.data.competitionTickets !== currentUserTickets) {
            await handleDbUpdate(env, `users/${userId}`, { 
                competitionTickets: currentUserTickets,
                lastTicketSync: Date.now()
            });
        }
        
        return {
            success: true,
            data: {
                userData: {
                    ...userResult.data,
                    competitionTickets: currentUserTickets
                },
                contest: {
                    yourTickets: currentUserTickets,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    isActive: competitionData.isActiveNow,
                    endTime: competitionData.endTime,
                    startTime: competitionData.startTime,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted
                }
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

// وظيفة جديدة: تحديث المسابقة يدويًا
async function handleRefreshCompetition(env) {
    try {
        const competitionData = await ensureAndGetCompetition(env);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to refresh competition'
            };
        }
        
        return {
            success: true,
            data: {
                competitionData: {
                    isActive: competitionData.isActive,
                    startTime: competitionData.startTime,
                    endTime: competitionData.endTime,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted,
                    isActiveNow: competitionData.isActiveNow
                }
            }
        };
    } catch (error) {
        console.error('Error refreshing competition:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

// وظيفة جديدة: مزامنة تذاكر المسابقة للمستخدم
async function handleSyncUserCompetitionTickets(env, userId) {
    try {
        // جلب بيانات المسابقة الحالية
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to load competition data'
            };
        }
        
        const currentTickets = competitionData.userTicketCount || 0;
        
        // تحديث بيانات المستخدم
        await handleDbUpdate(env, `users/${userId}`, {
            competitionTickets: currentTickets,
            lastTicketSync: Date.now()
        });
        
        // جلب بيانات المستخدم المحدثة
        const userResult = await handleDbGet(env, `users/${userId}`);
        
        return {
            success: true,
            data: {
                competitionTickets: currentTickets,
                userData: userResult.data,
                contest: {
                    yourTickets: currentTickets,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    isActive: competitionData.isActiveNow
                }
            }
        };
    } catch (error) {
        console.error('Error syncing user competition tickets:', error);
        return {
            success: false,
            error: error.message
        };
    }
}
