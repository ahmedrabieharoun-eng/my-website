// Cloudflare Worker لـ GLX Galaxy
export default {
    async fetch(request, env, ctx) {
        // إعداد CORS
        if (request.method === 'OPTIONS') {
            return new Response(null, {
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type, X-User-ID, X-Telegram-Data, X-Action, X-Device-Fingerprint, X-Client-IP',
                }
            });
        }
        
        const url = new URL(request.url);
        const path = url.pathname;
        
        // التحقق من المسار
        if (path !== '/api') {
            return new Response(JSON.stringify({
                success: false,
                error: 'Invalid endpoint'
            }), {
                status: 404,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        try {
            // استخراج البيانات من الطلب
            const requestData = await request.json();
            const action = request.headers.get('X-Action') || requestData.action;
            const data = requestData.data || {};
            const userId = request.headers.get('X-User-ID');
            const telegramData = request.headers.get('X-Telegram-Data');
            const deviceFingerprint = request.headers.get('X-Device-Fingerprint') || data.deviceFingerprint;
            const clientIp = request.headers.get('X-Client-IP') || request.headers.get('CF-Connecting-IP') || 'Unknown';
            
            console.log(`Request received: action=${action}, userId=${userId}, clientIp=${clientIp}`);
            
            // التحقق من المصادقة
            if (!userId || !telegramData) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Authentication required',
                    errorCode: 'AUTH_REQUIRED'
                }), {
                    status: 401,
                    headers: { 'Content-Type': 'application/json' }
                });
            }
            
            // التحقق من بيانات Telegram
            if (!isValidTelegramData(telegramData, userId)) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Invalid Telegram data',
                    errorCode: 'INVALID_TELEGRAM_DATA'
                }), {
                    status: 401,
                    headers: { 'Content-Type': 'application/json' }
                });
            }
            
            // ==================== نظام التحقق من بصمة الجهاز مع الحظر الشامل ====================
            // التحقق من بصمة الجهاز فقط لإجراء initializeUser
            if (action === 'initializeUser') {
                // جلب بيانات المستخدم أولاً للتحقق مما إذا كان جديدًا
                const userResult = await handleDbGet(env, `users/${userId}`);
                const userData = userResult.data;
                
                // إذا كان المستخدم جديدًا (لا توجد بيانات) أو ليس لديه بصمة جهاز
                if ((!userResult.success || !userData || !userData.deviceFingerprint) && deviceFingerprint) {
                    // التحقق مما إذا كانت بصمة الجهاز مستخدمة بالفعل
                    const fingerprintCheck = await checkDeviceFingerprint(env, deviceFingerprint, userId);
                    
                    if (fingerprintCheck.deviceAlreadyUsed) {
                        // حظر الحساب الحالي فورًا
                        await applyBlock(env, userId, {
                            reason: 'Device multi-account violation - New account detected',
                            violation: 'DEVICE_MULTI_ACCOUNT',
                            action: 'initializeUser',
                            details: `Device fingerprint ${deviceFingerprint} already used by ${fingerprintCheck.existingAccounts.length} other accounts`,
                            timestamp: Date.now(),
                            permanent: true,
                            clientIp: clientIp,
                            deviceFingerprint: deviceFingerprint
                        });
                        
                        return new Response(JSON.stringify({
                            success: false,
                            error: 'Device already registered with multiple accounts - All accounts have been blocked',
                            data: {
                                deviceAlreadyUsed: true,
                                existingAccounts: fingerprintCheck.existingAccounts,
                                violationType: 'DEVICE_MULTI_ACCOUNT',
                                accountsBlocked: fingerprintCheck.existingAccounts.length + 1,
                                currentAccountBlocked: true
                            }
                        }), {
                            status: 403,
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }
                    
                    // إذا لم تكن البصمة مستخدمة، سنقوم بحفظها لاحقًا في handleInitializeUser
                    data.deviceFingerprint = deviceFingerprint;
                    data.clientIp = clientIp;
                }
            }
            // ==================== نهاية نظام التحقق من بصمة الجهاز ====================
            
            // ==================== نظام الحظر التلقائي ====================
            // التحقق من الحظر قبل معالجة أي طلب
            const blockCheck = await checkUserBlocked(env, userId);
            if (blockCheck && blockCheck.isBlocked) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Your account has been blocked for violating system rules',
                    errorCode: 'ACCOUNT_BLOCKED',
                    data: {
                        isBlocked: true,
                        blockDetails: {
                            reason: blockCheck.reason,
                            violation: blockCheck.violation,
                            appliedAt: blockCheck.appliedAt,
                            permanent: blockCheck.permanent,
                            details: blockCheck.details
                        }
                    }
                }), {
                    status: 403,
                    headers: { 
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
            }
            
            // التحقق من صحة الطلب
            const validationResult = await validateRequest(env, userId, action, data, requestData.timestamp);
            if (!validationResult.valid) {
                // تسجيل المخالفة وتطبيق الحظر الفوري بعد مخالفة واحدة
                await recordViolation(env, userId, {
                    action: action,
                    violation: validationResult.violation,
                    details: validationResult.details,
                    timestamp: Date.now(),
                    clientIp: clientIp,
                    deviceFingerprint: deviceFingerprint
                });
                
                // تطبيق الحظر الفوري بعد مخالفة واحدة
                await applyBlock(env, userId, {
                    reason: 'System violation detected',
                    violation: validationResult.violation,
                    action: action,
                    details: validationResult.details,
                    timestamp: Date.now(),
                    permanent: true, // حظر دائم
                    clientIp: clientIp,
                    deviceFingerprint: deviceFingerprint
                });
                
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Invalid request detected - Account has been blocked',
                    errorCode: 'REQUEST_VALIDATION_FAILED',
                    details: validationResult.details
                }), {
                    status: 400,
                    headers: { 'Content-Type': 'application/json' }
                });
            }
            
            // ==================== نهاية نظام الحظر ====================
            
            // معالجة الإجراءات
            let result;
            switch (action) {
                case 'initializeUser':
                    result = await handleInitializeUser(env, userId, data, telegramData, clientIp);
                    break;
                    
                case 'getCompetitionData':
                    result = await handleGetCompetitionData(env, userId);
                    break;
                    
                case 'dbSet':
                    result = await handleDbSet(env, data.path, data.data);
                    break;
                    
                case 'dbGet':
                    result = await handleDbGet(env, data.path);
                    break;
                    
                case 'dbUpdate':
                    result = await handleDbUpdate(env, data.path, data.updates);
                    break;
                    
                case 'dbPush':
                    result = await handleDbPush(env, data.path, data.data);
                    break;
                    
                case 'dbTransaction':
                    result = await handleDbTransaction(env, data.path, data.transactionFunction);
                    break;
                    
                case 'dbIncrement':
                    result = await handleDbIncrement(env, data.path, data.key, data.amount);
                    break;
                    
                case 'getConfig':
                    result = await handleGetConfig();
                    break;
                    
                case 'executeSwap':
                    result = await handleExecuteSwap(env, userId, data);
                    break;
                    
                case 'verifyDeposit':
                    result = await handleVerifyDeposit(env, userId, data);
                    break;
                    
                case 'buyTickets':
                    result = await handleBuyTickets(env, userId, data);
                    break;
                    
                case 'getCompetitionLeaderboard':
                    result = await handleGetCompetitionLeaderboard(env);
                    break;
                    
                case 'getPreviousWinners':
                    result = await handleGetPreviousWinners(env);
                    break;
                    
                case 'flipCoin':
                    result = await handleFlipCoin(env, userId, data);
                    break;
                    
                case 'redeemPromoCode':
                    result = await handleRedeemPromoCode(env, userId, data);
                    break;
                    
                case 'createTask':
                    result = await handleCreateTask(env, userId, data);
                    break;
                    
                case 'verifyTaskPayment':
                    result = await handleVerifyTaskPayment(env, data.taskId);
                    break;
                    
                case 'verifyTaskChannel':
                    result = await handleVerifyTaskChannel(env, userId, data);
                    break;
                    
                case 'spinSlots':
                    result = await handleSpinSlots(env, userId);
                    break;
                    
                case 'addExtraSpin':
                    result = await handleAddExtraSpin(env, userId);
                    break;
                    
                case 'claimDailyBonus':
                    result = await handleClaimDailyBonus(env, userId);
                    break;
                    
                case 'getTransactionHistory':
                    result = await handleGetTransactionHistory(env, userId, data.limit);
                    break;
                    
                case 'getUserWithdrawals':
                    result = await handleGetUserWithdrawals(env, userId);
                    break;
                    
                case 'getWithdrawalHistory':
                    result = await handleGetWithdrawalHistory(env);
                    break;
                    
                case 'getWithdrawalStats':
                    result = await handleGetWithdrawalStats(env);
                    break;
                    
                case 'getReferredUsers':
                    result = await handleGetReferredUsers(env, userId);
                    break;
                    
                case 'getTasks':
                    result = await handleGetTasks(env, userId);
                    break;
                    
                case 'verifyTaskCompletion':
                    result = await handleVerifyTaskCompletion(env, userId, data);
                    break;
                    
                case 'handleReferral':
                    result = await handleReferral(env, data.userId, data.referrerId);
                    break;
                    
                case 'handleAdClick':
                    // التحقق من الحظر قبل معالجة طلب الإعلان
                    const adBlockCheck = await checkUserBlocked(env, userId);
                    if (adBlockCheck && adBlockCheck.isBlocked) {
                        return new Response(JSON.stringify({
                            success: false,
                            error: 'Your account has been blocked for violating system rules',
                            errorCode: 'ACCOUNT_BLOCKED',
                            data: {
                                isBlocked: true,
                                blockDetails: adBlockCheck
                            }
                        }), {
                            status: 403,
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }
                    
                    // التحقق من صحة طلب الإعلان
                    const adValidation = await validateAdRequest(env, userId, data);
                    if (!adValidation.valid) {
                        // حظر فوري لطلب إعلان غير صالح - مخالفة واحدة
                        await applyBlock(env, userId, {
                            reason: 'Invalid ad request - System violation',
                            violation: adValidation.violation,
                            action: 'handleAdClick',
                            details: adValidation.details,
                            timestamp: Date.now(),
                            permanent: true,
                            clientIp: clientIp,
                            deviceFingerprint: deviceFingerprint
                        });
                        
                        return new Response(JSON.stringify({
                            success: false,
                            error: 'Invalid ad request detected - Account has been blocked',
                            errorCode: 'AD_VALIDATION_FAILED'
                        }), {
                            status: 400,
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }
                    
                    result = await handleAdClick(env, userId, data.adType, data.reward);
                    break;
                    
                case 'submitWithdrawal':
                    result = await handleSubmitWithdrawal(env, userId, data);
                    break;
                    
                case 'getLeaderboard':
                    result = await handleGetLeaderboard(env);
                    break;
                    
                case 'testFirebase':
                    result = await handleTestFirebase(env);
                    break;
                    
                case 'getUserData':
                    result = await handleGetUserData(env, userId);
                    break;
                    
                case 'refreshCompetition':
                    result = await handleRefreshCompetition(env);
                    break;
                    
                case 'verifyTelegramMembership':
                    result = await handleVerifyTelegramMembership(env, userId, data);
                    break;
                    
                case 'syncUserCompetitionTickets':
                    result = await handleSyncUserCompetitionTickets(env, userId);
                    break;
                    
                case 'checkDeviceFingerprint':
                    result = await handleCheckDeviceFingerprint(env, userId, data);
                    break;
                    
                case 'saveDeviceFingerprint':
                    result = await handleSaveDeviceFingerprint(env, userId, data, clientIp);
                    break;
                    
                case 'periodicDeviceCheck':
                    result = await handlePeriodicDeviceCheck(env, userId, data);
                    break;
                    
                case 'getClientIP':
                    result = await handleGetClientIP(clientIp);
                    break;
                    
                case 'testTelegramApi':
                    result = await handleTestTelegramApi(env, userId, data);
                    break;
                    
                default:
                    result = {
                        success: false,
                        error: 'Unknown action',
                        errorCode: 'UNKNOWN_ACTION'
                    };
            }
            
            // إرجاع النتيجة
            return new Response(JSON.stringify(result), {
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
            
        } catch (error) {
            console.error('Worker error:', error);
            
            return new Response(JSON.stringify({
                success: false,
                error: 'Internal server error',
                errorCode: 'INTERNAL_SERVER_ERROR',
                details: error.message,
                stack: error.stack
            }), {
                status: 500,
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
        }
    }
};

// ==================== نظام بصمة الجهاز المحسن مع الحظر الشامل ====================

// التحقق مما إذا كانت بصمة الجهاز مستخدمة مسبقًا مع تطبيق الحظر الفوري
async function checkDeviceFingerprint(env, deviceFingerprint, currentUserId = null) {
    try {
        if (!deviceFingerprint) {
            return { deviceAlreadyUsed: false };
        }
        
        // البحث في جميع المستخدمين عن بصمة الجهاز
        const usersResult = await handleDbGet(env, 'users');
        const usersData = usersResult.data || {};
        
        let existingAccounts = [];
        
        for (const [userId, userData] of Object.entries(usersData)) {
            // تخطي المستخدم الحالي إذا كان موجودًا
            if (currentUserId && userId === currentUserId) continue;
            
            if (userData.deviceFingerprint === deviceFingerprint) {
                existingAccounts.push({
                    userId: userId,
                    name: userData.name || 'Anonymous User',
                    photoUrl: userData.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                    joinDate: userData.joinDate,
                    lastLogin: userData.lastLogin
                });
                
                // تطبيق الحظر الفوري على الحساب الموجود
                await applyBlock(env, userId, {
                    reason: 'Device multi-account violation - Existing account detected',
                    violation: 'DEVICE_MULTI_ACCOUNT',
                    action: 'deviceFingerprintCheck',
                    details: `Device fingerprint ${deviceFingerprint} already used by new account ${currentUserId || 'unknown'}`,
                    timestamp: Date.now(),
                    permanent: true,
                    clientIp: 'System Detection',
                    deviceFingerprint: deviceFingerprint
                });
            }
        }
        
        if (existingAccounts.length > 0) {
            return {
                deviceAlreadyUsed: true,
                existingAccounts: existingAccounts,
                violationType: 'DEVICE_MULTI_ACCOUNT',
                accountsCount: existingAccounts.length
            };
        }
        
        return { deviceAlreadyUsed: false };
    } catch (error) {
        console.error('Error checking device fingerprint:', error);
        return { deviceAlreadyUsed: false };
    }
}

// معالجة التحقق من بصمة الجهاز مع الحظر الفوري
async function handleCheckDeviceFingerprint(env, userId, data) {
    try {
        const { deviceFingerprint } = data;
        
        if (!deviceFingerprint) {
            return {
                success: false,
                error: 'Device fingerprint is required',
                errorCode: 'DEVICE_FINGERPRINT_REQUIRED'
            };
        }
        
        const fingerprintCheck = await checkDeviceFingerprint(env, deviceFingerprint, userId);
        
        // إذا كان الجهاز مستخدمًا، تطبيق الحظر على الحساب الحالي أيضًا
        if (fingerprintCheck.deviceAlreadyUsed && userId) {
            await applyBlock(env, userId, {
                reason: 'Device multi-account violation - New account detected',
                violation: 'DEVICE_MULTI_ACCOUNT',
                action: 'checkDeviceFingerprint',
                details: `Device fingerprint ${deviceFingerprint} already used by ${fingerprintCheck.existingAccounts.length} other accounts`,
                timestamp: Date.now(),
                permanent: true,
                clientIp: 'System Detection',
                deviceFingerprint: deviceFingerprint
            });
            
            return {
                success: false,
                error: 'Device already registered with multiple accounts - All accounts have been blocked',
                errorCode: 'DEVICE_MULTI_ACCOUNT_BLOCKED',
                data: {
                    deviceAlreadyUsed: true,
                    existingAccounts: fingerprintCheck.existingAccounts,
                    violationType: 'DEVICE_MULTI_ACCOUNT',
                    accountsBlocked: fingerprintCheck.existingAccounts.length + 1, // +1 للحساب الحالي
                    currentAccountBlocked: true
                }
            };
        }
        
        return {
            success: true,
            data: fingerprintCheck
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'DEVICE_CHECK_ERROR'
        };
    }
}

// معالجة حفظ بصمة الجهاز مع الحظر الشامل
async function handleSaveDeviceFingerprint(env, userId, data, clientIp) {
    try {
        const { deviceFingerprint } = data;
        
        if (!deviceFingerprint) {
            return {
                success: false,
                error: 'Device fingerprint is required',
                errorCode: 'DEVICE_FINGERPRINT_REQUIRED'
            };
        }
        
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        // التحقق من أن المستخدم موجود
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        // التحقق مما إذا كانت البصمة مستخدمة بالفعل من قبل مستخدم آخر
        const fingerprintCheck = await checkDeviceFingerprint(env, deviceFingerprint, userId);
        
        if (fingerprintCheck.deviceAlreadyUsed) {
            // حظر الحساب الحالي فورًا
            await applyBlock(env, userId, {
                reason: 'Device multi-account violation',
                violation: 'DEVICE_MULTI_ACCOUNT',
                action: 'saveDeviceFingerprint',
                details: 'Attempt to use device registered with another account',
                timestamp: Date.now(),
                permanent: true,
                clientIp: clientIp,
                deviceFingerprint: deviceFingerprint
            });
            
            return {
                success: false,
                error: 'Device already registered with multiple accounts - All accounts have been blocked',
                errorCode: 'DEVICE_MULTI_ACCOUNT_BLOCKED',
                data: {
                    deviceAlreadyUsed: true,
                    existingAccounts: fingerprintCheck.existingAccounts,
                    violationType: 'DEVICE_MULTI_ACCOUNT',
                    accountsBlocked: fingerprintCheck.existingAccounts.length + 1,
                    currentAccountBlocked: true
                }
            };
        }
        
        // تحديث المستخدم بإضافة بصمة الجهاز وعنوان IP
        let ipAddresses = userData.ipAddresses || [];
        
        if (clientIp && clientIp !== 'Unknown' && !ipAddresses.includes(clientIp)) {
            ipAddresses.push(clientIp);
            if (ipAddresses.length > 3) {
                ipAddresses = ipAddresses.slice(-3); // حفظ آخر 3 عناوين IP فقط
            }
        }
        
        const updateData = {
            deviceFingerprint: deviceFingerprint,
            deviceRegisteredAt: Date.now(),
            lastDeviceCheck: Date.now(),
            deviceInfo: data.deviceInfo || {},
            lastIpAddress: clientIp,
            ipAddresses: ipAddresses,
            deviceLoginCount: (userData.deviceLoginCount || 0) + 1
        };
        
        await handleDbUpdate(env, `users/${userId}`, updateData);
        
        return {
            success: true,
            data: {
                message: 'Device fingerprint saved successfully',
                deviceRegisteredAt: Date.now(),
                ipAddressesCount: ipAddresses.length
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'DEVICE_SAVE_ERROR'
        };
    }
}

// معالجة الفحص الدوري للجهاز
async function handlePeriodicDeviceCheck(env, userId, data) {
    try {
        const { deviceFingerprint } = data;
        
        if (!deviceFingerprint) {
            return {
                success: false,
                error: 'Device fingerprint is required',
                errorCode: 'DEVICE_FINGERPRINT_REQUIRED'
            };
        }
        
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        // التحقق من بصمة الجهاز
        const fingerprintCheck = await checkDeviceFingerprint(env, deviceFingerprint, userId);
        
        if (fingerprintCheck.deviceAlreadyUsed) {
            // حظر الحساب الحالي فورًا
            await applyBlock(env, userId, {
                reason: 'Session multi-account violation',
                violation: 'PERIODIC_DEVICE_MULTI_ACCOUNT',
                action: 'periodicDeviceCheck',
                details: 'Multiple accounts detected from same device during session',
                timestamp: Date.now(),
                permanent: true,
                deviceFingerprint: deviceFingerprint
            });
            
            return {
                success: true,
                data: {
                    securityViolation: true,
                    deviceAlreadyUsed: true,
                    existingAccounts: fingerprintCheck.existingAccounts,
                    violationType: 'SESSION_MULTI_ACCOUNT_DETECTED',
                    actionRequired: 'SESSION_TERMINATION',
                    currentAccountBlocked: true
                }
            };
        }
        
        // تحديث وقت آخر فحص
        await handleDbUpdate(env, `users/${userId}`, {
            lastPeriodicCheck: Date.now(),
            deviceCheckCount: (data.deviceCheckCount || 0) + 1
        });
        
        return {
            success: true,
            data: {
                securityViolation: false,
                lastCheck: Date.now()
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'PERIODIC_CHECK_ERROR'
        };
    }
}

// معالجة الحصول على IP العميل
async function handleGetClientIP(clientIp) {
    return {
        success: true,
        data: {
            clientIp: clientIp,
            timestamp: Date.now()
        }
    };
}

// ==================== نظام الحظر التلقائي المحسن ====================

// التحقق من صحة الطلب
async function validateRequest(env, userId, action, data, requestTimestamp) {
    const now = Date.now();
    const MAX_TIME_DIFF = 30000; // 30 ثانية كحد أقصى للفرق الزمني
    
    // 1. التحقق من الطابع الزمني
    if (requestTimestamp) {
        const timeDiff = Math.abs(now - parseInt(requestTimestamp));
        
        if (timeDiff > MAX_TIME_DIFF) {
            return {
                valid: false,
                violation: 'TIMESTAMP_MANIPULATION',
                details: `Timestamp difference too large: ${timeDiff}ms`
            };
        }
        
        // التحقق من استخدام نفس الطابع الزمني مسبقًا
        const isDuplicate = await checkDuplicateTimestamp(env, userId, requestTimestamp);
        if (isDuplicate) {
            return {
                valid: false,
                violation: 'DUPLICATE_TIMESTAMP',
                details: 'Timestamp already used'
            };
        }
    }
    
    // 2. التحقق من قيم المكافآت بناءً على نوع الإجراء
    if (action === 'handleAdClick') {
        return await validateAdRequest(env, userId, data);
    }
    
    if (action === 'redeemPromoCode') {
        return await validatePromoCodeRequest(env, userId, data);
    }
    
    if (action === 'verifyTaskCompletion') {
        return await validateTaskRequest(env, userId, data);
    }
    
    if (action === 'buyTickets') {
        return await validateTicketPurchase(env, userId, data);
    }
    
    if (action === 'flipCoin') {
        return await validateCoinFlip(env, userId, data);
    }
    
    if (action === 'spinSlots') {
        return await validateSlotSpin(env, userId);
    }
    
    if (action === 'claimDailyBonus') {
        return await validateDailyBonus(env, userId);
    }
    
    // 3. التحقق من صحة المهام والمكافآت
    if (action === 'verifyTaskCompletion' || action === 'verifyTaskChannel') {
        return await validateTaskReward(env, userId, data, action);
    }
    
    // 4. التحقق من متطلبات الإجراءات الحساسة
    if (action === 'submitWithdrawal') {
        return await validateWithdrawalRequest(env, userId, data);
    }
    
    if (action === 'executeSwap') {
        return await validateSwapRequest(env, userId, data);
    }
    
    if (action === 'verifyDeposit') {
        return await validateDepositRequest(env, userId, data);
    }
    
    return { valid: true };
}

// التحقق من صحة طلب الإعلان
async function validateAdRequest(env, userId, data) {
    const { adType, reward } = data;
    
    // جلب الإعدادات للتحقق من القيم الصحيحة
    const configResult = await handleGetConfig();
    const settings = configResult.data?.settings || {};
    
    // القيم المسموح بها لكل نوع إعلان (من الإعدادات)
    const allowedRewards = {
        'monetag': settings.adRewardMonetag || 1000,
        'giga': settings.adRewardGiga || 2000,
        'adsgram': settings.adRewardAdsgram || 2000
    };
    
    // التحقق من وجود نوع الإعلان
    if (!allowedRewards[adType]) {
        return {
            valid: false,
            violation: 'INVALID_AD_TYPE',
            details: `Invalid ad type: ${adType}`
        };
    }
    
    // التحقق من قيمة المكافأة (يجب أن تطابق القيمة في الإعدادات بالضبط)
    const allowedReward = allowedRewards[adType];
    const requestedReward = parseInt(reward);
    
    if (requestedReward !== allowedReward) {
        return {
            valid: false,
            violation: 'REWARD_MANIPULATION',
            details: `Ad reward manipulation: Expected ${allowedReward}, got ${requestedReward}`
        };
    }
    
    // التحقق من الحد الأقصى للإعلانات اليومية
    const userResult = await handleDbGet(env, `users/${userId}`);
    if (userResult.success && userResult.data) {
        const userData = userResult.data;
        const adCountField = `ads${adType.charAt(0).toUpperCase() + adType.slice(1)}`;
        
        // جلب الحد الأقصى من الإعدادات
        const adLimitField = `limit${adType.charAt(0).toUpperCase() + adType.slice(1)}`;
        const limit = settings[adLimitField] || 50;
        
        if (userData[adCountField] >= limit) {
            return {
                valid: false,
                violation: 'AD_LIMIT_EXCEEDED',
                details: `Ad limit exceeded for ${adType}`
            };
        }
    }
    
    return { valid: true };
}

// التحقق من صحة طلب البرومو كود
async function validatePromoCodeRequest(env, userId, data) {
    const { code } = data;
    
    // البرومو كودات المسموح بها
    const validCodes = {
        'WELCOME100': 100,
        'GALAXY500': 500,
        'STAR1000': 1000,
        'BONUS2000': 2000,
        'VIP5000': 5000
    };
    
    // التحقق من قيمة المكافأة إذا كانت زائدة عن الحد المسموح
    const expectedReward = validCodes[code] || 0;
    if (expectedReward > 10000) { // الحد الأقصى للمكافأة لبرومو كود
        return {
            valid: false,
            violation: 'EXCESSIVE_PROMO_REWARD',
            details: `Promo code reward too high: ${expectedReward} (max 10000)`
        };
    }
    
    return { valid: true };
}

// التحقق من صحة طلب المهمة
async function validateTaskRequest(env, userId, data) {
    const { taskId, reward, title } = data;
    
    // الحد الأقصى لمكافأة المهمة
    const MAX_TASK_REWARD = 10000;
    
    if (parseInt(reward) > MAX_TASK_REWARD) {
        return {
            valid: false,
            violation: 'EXCESSIVE_TASK_REWARD',
            details: `Task reward too high: ${reward}`
        };
    }
    
    // التحقق من عدم إكمال المهمة مسبقًا
    const userResult = await handleDbGet(env, `users/${userId}`);
    if (userResult.success && userResult.data) {
        const userData = userResult.data;
        const completedTasks = userData.completedTasks || {};
        
        if (completedTasks[taskId]) {
            return {
                valid: false,
                violation: 'TASK_ALREADY_COMPLETED',
                details: `Task already completed: ${taskId}`
            };
        }
    }
    
    return { valid: true };
}

// التحقق من صحة شراء التذاكر
async function validateTicketPurchase(env, userId, data) {
    const { tickets, totalCost } = data;
    
    // سعر التذكرة الواحدة
    const TICKET_PRICE = 10000; // سعر التذكرة = 10,000 GLX
    
    // الحد الأقصى للتذاكر في كل عملية
    const MAX_TICKETS_PER_PURCHASE = 100;
    
    // الحد الأدنى للتذاكر
    const MIN_TICKETS_PER_PURCHASE = 1;
    
    const ticketsCount = parseInt(tickets);
    const costAmount = parseInt(totalCost);
    
    // التحقق من عدد التذاكر
    if (ticketsCount < MIN_TICKETS_PER_PURCHASE) {
        return {
            valid: false,
            violation: 'INSUFFICIENT_TICKETS',
            details: `Too few tickets: ${ticketsCount}`
        };
    }
    
    if (ticketsCount > MAX_TICKETS_PER_PURCHASE) {
        return {
            valid: false,
            violation: 'EXCESSIVE_TICKET_PURCHASE',
            details: `Too many tickets: ${ticketsCount} (max ${MAX_TICKETS_PER_PURCHASE})`
        };
    }
    
    // التحقق من أن التكلفة متناسبة مع عدد التذاكر
    const expectedCost = ticketsCount * TICKET_PRICE;
    
    if (costAmount !== expectedCost) {
        return {
            valid: false,
            violation: 'COST_MANIPULATION',
            details: `Ticket cost manipulation: Expected ${expectedCost}, got ${costAmount}`
        };
    }
    
    return { valid: true };
}

// التحقق من صحة لعبة قلب العملة
async function validateCoinFlip(env, userId, data) {
    const { betAmount } = data;
    
    // الحد الأقصى للرهان
    const MAX_BET_AMOUNT = 100000; // 100,000 GLX كحد أقصى
    
    // الحد الأدنى للرهان
    const MIN_BET_AMOUNT = 1000; // 1,000 GLX كحد أدنى
    
    const betAmountNum = parseInt(betAmount);
    
    if (betAmountNum > MAX_BET_AMOUNT) {
        return {
            valid: false,
            violation: 'EXCESSIVE_BET_AMOUNT',
            details: `Bet amount too high: ${betAmountNum} (max ${MAX_BET_AMOUNT})`
        };
    }
    
    if (betAmountNum < MIN_BET_AMOUNT) {
        return {
            valid: false,
            violation: 'INSUFFICIENT_BET_AMOUNT',
            details: `Bet amount too low: ${betAmountNum} (min ${MIN_BET_AMOUNT})`
        };
    }
    
    return { valid: true };
}

// التحقق من صحة مكافأة المهمة
async function validateTaskReward(env, userId, data, action) {
    let reward;
    let taskId;
    
    if (action === 'verifyTaskCompletion') {
        reward = data.reward;
        taskId = data.taskId;
    } else if (action === 'verifyTaskChannel') {
        reward = 2000; // مكافأة ثابتة للانضمام للقناة
    } else {
        return { valid: true };
    }
    
    // جلب بيانات المهمة للتحقق
    if (taskId) {
        const taskResult = await handleDbGet(env, `tasks/${taskId}`);
        if (taskResult.success && taskResult.data) {
            const task = taskResult.data;
            const taskReward = task.reward || 0;
            
            // إذا كانت المهمة لها مكافأة محددة، التحقق منها
            if (taskReward > 0 && parseInt(reward) !== taskReward) {
                return {
                    valid: false,
                    violation: 'TASK_REWARD_MANIPULATION',
                    details: `Task reward manipulation: Expected ${taskReward}, got ${reward}`
                };
            }
        }
    }
    
    // الحد الأقصى لمكافأة المهمة
    const MAX_TASK_REWARD = 20000;
    
    if (parseInt(reward) > MAX_TASK_REWARD) {
        return {
            valid: false,
            violation: 'EXCESSIVE_TASK_REWARD',
            details: `Task reward too high: ${reward}`
        };
    }
    
    return { valid: true };
}

// التحقق من صحة لعبة السلوتس
async function validateSlotSpin(env, userId) {
    // التحقق من وجود محاولات دوران كافية
    const userResult = await handleDbGet(env, `users/${userId}`);
    if (userResult.success && userResult.data) {
        const userData = userResult.data;
        
        if ((userData.extraSpins || 0) <= 0) {
            return {
                valid: false,
                violation: 'NO_SPINS_AVAILABLE',
                details: 'No spins available'
            };
        }
    }
    
    return { valid: true };
}

// التحقق من صحة المكافأة اليومية
async function validateDailyBonus(env, userId) {
    const userResult = await handleDbGet(env, `users/${userId}`);
    if (userResult.success && userResult.data) {
        const userData = userResult.data;
        const now = Date.now();
        const lastClaim = userData.lastDailyClaim || 0;
        const msInDay = 86400000;
        
        // التحقق من أنه لم يحصل على المكافأة اليوم
        if (now - lastClaim < msInDay) {
            return {
                valid: false,
                violation: 'DAILY_BONUS_ALREADY_CLAIMED',
                details: 'Daily bonus already claimed today'
            };
        }
    }
    
    return { valid: true };
}

// التحقق من صحة طلب السحب
async function validateWithdrawalRequest(env, userId, data) {
    const { amount, method } = data;
    
    const userResult = await handleDbGet(env, `users/${userId}`);
    if (userResult.success && userResult.data) {
        const userData = userResult.data;
        
        // التحقق من الحد الأدنى للسحب
        const configResult = await handleGetConfig();
        const settings = configResult.data?.settings || {};
        
        let minAmount = 0.05; // الحد الأدنى الافتراضي
        if (method === 'ton') {
            minAmount = settings.minTonWithdrawal || 0.05;
        } else if (method === 'faucetpay') {
            minAmount = settings.minFaucetPayWithdrawal || 0.0001;
        }
        
        if (parseFloat(amount) < minAmount) {
            return {
                valid: false,
                violation: 'INSUFFICIENT_WITHDRAWAL_AMOUNT',
                details: `Withdrawal amount too low: ${amount} (min ${minAmount})`
            };
        }
        
        // التحقق من الرصيد الكافي
        if ((userData.tonBalance || 0) < parseFloat(amount)) {
            return {
                valid: false,
                violation: 'INSUFFICIENT_BALANCE_FOR_WITHDRAWAL',
                details: 'Insufficient TON balance for withdrawal'
            };
        }
    }
    
    return { valid: true };
}

// التحقق من صحة طلب التحويل
async function validateSwapRequest(env, userId, data) {
    const { type, amount, tonValue, glxValue } = data;
    
    const userResult = await handleDbGet(env, `users/${userId}`);
    if (userResult.success && userResult.data) {
        const userData = userResult.data;
        
        if (type === 'glx_to_ton') {
            if (userData.dogsBalance < amount) {
                return {
                    valid: false,
                    violation: 'INSUFFICIENT_GLX_FOR_SWAP',
                    details: 'Insufficient GLX balance for swap'
                };
            }
        } else if (type === 'ton_to_glx') {
            if ((userData.tonBalance || 0) < amount) {
                return {
                    valid: false,
                    violation: 'INSUFFICIENT_TON_FOR_SWAP',
                    details: 'Insufficient TON balance for swap'
                };
            }
        }
    }
    
    return { valid: true };
}

// التحقق من صحة طلب الإيداع
async function validateDepositRequest(env, userId, data) {
    const { memo, amount } = data;
    
    // التحقق من صحة تنسيق memo
    if (!memo || typeof memo !== 'string') {
        return {
            valid: false,
            violation: 'INVALID_DEPOSIT_MEMO',
            details: 'Invalid deposit memo format'
        };
    }
    
    // التحقق من أن المبلغ إيجابي
    if (parseFloat(amount) <= 0) {
        return {
            valid: false,
            violation: 'INVALID_DEPOSIT_AMOUNT',
            details: 'Deposit amount must be positive'
        };
    }
    
    return { valid: true };
}

// التحقق من استخدام نفس الطابع الزمني مسبقًا
async function checkDuplicateTimestamp(env, userId, timestamp) {
    try {
        const timestampsResult = await handleDbGet(env, `users/${userId}/requestTimestamps`);
        const timestamps = timestampsResult.data || {};
        
        // البحث عن طابع زمني مطابق
        for (const [key, tsData] of Object.entries(timestamps)) {
            if (tsData.timestamp === timestamp) {
                return true;
            }
        }
        
        // حفظ الطابع الزمني الجديد
        await handleDbPush(env, `users/${userId}/requestTimestamps`, {
            timestamp: timestamp,
            recordedAt: Date.now()
        });
        
        // تنظيف الطوابع الزمنية القديمة (أقدم من 5 دقائق)
        const cleanTimestamps = {};
        const fiveMinutesAgo = Date.now() - 300000;
        
        for (const [key, tsData] of Object.entries(timestamps)) {
            if (tsData.recordedAt > fiveMinutesAgo) {
                cleanTimestamps[key] = tsData;
            }
        }
        
        await handleDbSet(env, `users/${userId}/requestTimestamps`, cleanTimestamps);
        
        return false;
    } catch (error) {
        console.error('Error checking duplicate timestamp:', error);
        return false;
    }
}

// التحقق من حظر المستخدم
async function checkUserBlocked(env, userId) {
    try {
        const blockResult = await handleDbGet(env, `blocks/${userId}`);
        if (blockResult.success && blockResult.data) {
            const blockData = blockResult.data;
            
            // التحقق من انتهاء مدة الحظر
            if (blockData.expiresAt && blockData.expiresAt > Date.now()) {
                return {
                    isBlocked: true,
                    reason: blockData.reason || 'Account blocked',
                    violation: blockData.violation || 'UNKNOWN',
                    appliedAt: blockData.appliedAt,
                    expiresAt: blockData.expiresAt,
                    permanent: blockData.permanent || false,
                    details: blockData.details || 'No details provided'
                };
            } else if (blockData.permanent) {
                return {
                    isBlocked: true,
                    reason: blockData.reason || 'Permanently blocked',
                    violation: blockData.violation || 'UNKNOWN',
                    appliedAt: blockData.appliedAt,
                    permanent: true,
                    details: blockData.details || 'Account permanently blocked'
                };
            }
            
            // إذا انتهت مدة الحظر المؤقت، إزالته
            if (blockData.expiresAt && blockData.expiresAt <= Date.now()) {
                await handleDbSet(env, `blocks/${userId}`, null);
                await handleDbUpdate(env, `users/${userId}`, {
                    isBlocked: false,
                    blockReason: null,
                    blockedAt: null
                });
                return false;
            }
        }
        
        return false;
    } catch (error) {
        console.error('Error checking user block:', error);
        return false;
    }
}

// تسجيل مخالفة
async function recordViolation(env, userId, violationData) {
    try {
        // تسجيل المخالفة
        await handleDbPush(env, `violations/${userId}`, violationData);
        
        // زيادة عداد المخالفات
        const violationsResult = await handleDbGet(env, `violationCounts/${userId}`);
        const currentCount = violationsResult.data?.count || 0;
        const newCount = currentCount + 1;
        
        await handleDbSet(env, `violationCounts/${userId}`, {
            count: newCount,
            lastViolation: Date.now(),
            userId: userId,
            violationDetails: violationData
        });
        
        console.log(`Violation recorded for user ${userId}: ${violationData.violation}`);
        
        return true;
    } catch (error) {
        console.error('Error recording violation:', error);
        return false;
    }
}

// تطبيق الحظر
async function applyBlock(env, userId, blockData) {
    try {
        const blockInfo = {
            userId: userId,
            reason: blockData.reason || 'System violation detected',
            violation: blockData.violation || 'UNKNOWN',
            appliedAt: Date.now(),
            expiresAt: null, // حظر دائم بعد مخالفة واحدة
            permanent: true, // حظر دائم
            blockData: blockData,
            action: blockData.action || 'UNKNOWN',
            details: blockData.details || 'No details',
            clientIp: blockData.clientIp || 'Unknown',
            deviceFingerprint: blockData.deviceFingerprint || 'Unknown'
        };
        
        // حفظ معلومات الحظر
        await handleDbSet(env, `blocks/${userId}`, blockInfo);
        
        // تحديث حالة المستخدم
        await handleDbUpdate(env, `users/${userId}`, {
            isBlocked: true,
            blockReason: blockInfo.reason,
            blockedAt: Date.now(),
            violationCount: 1,
            lastViolation: Date.now()
        });
        
        // تسجيل الحظر في سجل الحظر العام
        await handleDbPush(env, 'system/blocks', {
            userId: userId,
            reason: blockInfo.reason,
            violation: blockInfo.violation,
            appliedAt: Date.now(),
            permanent: true,
            action: blockData.action,
            details: blockData.details,
            clientIp: blockData.clientIp,
            deviceFingerprint: blockData.deviceFingerprint
        });
        
        console.log(`User ${userId} permanently blocked after 1 violation: ${blockInfo.reason}`);
        
        return true;
    } catch (error) {
        console.error('Error applying block:', error);
        return false;
    }
}

// ==================== نهاية نظام الحظر ====================

// التحقق من بيانات Telegram
function isValidTelegramData(telegramData, userId) {
    try {
        const params = new URLSearchParams(telegramData);
        const userParam = params.get('user');
        
        if (!userParam) return false;
        
        const userData = JSON.parse(decodeURIComponent(userParam));
        return userData.id.toString() === userId;
        
    } catch (error) {
        console.error('Telegram data validation error:', error);
        return false;
    }
}

// دالة مساعدة لإنشاء رابط Firebase
async function getFirebaseUrl(env, path) {
    const baseUrl = env.FIREBASE_DATABASE_URL.replace(/\/$/, '');
    const cleanPath = path.replace(/^\//, '');
    const apiKey = env.FIREBASE_API_KEY;
    
    if (!apiKey) {
        throw new Error('FIREBASE_API_KEY is not configured');
    }
    
    return `${baseUrl}/${cleanPath}.json?key=${apiKey}`;
}

// دالة مساعدة لضمان وجود مسابقة نشطة وجلب بياناتها
async function ensureAndGetCompetition(env, userId = null) {
    try {
        // جلب المسابقة الحالية
        const competitionResult = await handleDbGet(env, 'competition/current');
        let competitionData = competitionResult.data || {};
        
        const now = Date.now();
        const ONE_DAY_MS = 24 * 60 * 60 * 1000;
        
        // التحقق مما إذا كان يجب إنشاء مسابقة جديدة
        const shouldCreateNew = 
            !competitionData ||
            Object.keys(competitionData).length === 0 ||
            !competitionData.isActive || 
            !competitionData.endTime || 
            now > competitionData.endTime;
        
        if (shouldCreateNew) {
            console.log('Creating new competition... Current time:', now);
            
            // إذا كانت هناك مسابقة قديمة، حفظ الفائزين
            if (competitionData && competitionData.userTickets && Object.keys(competitionData.userTickets).length > 0) {
                await saveCompetitionWinners(env, competitionData);
            }
            
            // إنشاء مسابقة جديدة
            competitionData = {
                isActive: true,
                startTime: now,
                endTime: now + ONE_DAY_MS, // 24 ساعة من الآن
                totalTickets: 0,
                prizePool: 0,
                userTickets: {},
                winners: [],
                lastUpdated: now
            };
            
            // حفظ المسابقة الجديدة
            await handleDbSet(env, 'competition/current', competitionData);
            console.log('New competition created. End time:', new Date(competitionData.endTime).toISOString());
        } else {
            console.log('Existing competition found. End time:', new Date(competitionData.endTime).toISOString());
        }
        
        // حساب الوقت المتبقي
        competitionData.timeRemaining = Math.max(0, competitionData.endTime - now);
        competitionData.isActiveNow = competitionData.isActive && competitionData.timeRemaining > 0;
        
        // إذا انتهت المسابقة، إنشاء مسابقة جديدة
        if (competitionData.timeRemaining <= 0 && competitionData.isActive) {
            console.log('Competition ended, creating new one...');
            competitionData.isActive = false;
            await handleDbSet(env, 'competition/current', competitionData);
            return await ensureAndGetCompetition(env, userId);
        }
        
        // إذا تم تمرير userId، حساب تذاكره بشكل صحيح
        if (userId) {
            competitionData.userTickets = competitionData.userTickets || {};
            competitionData.userTicketCount = competitionData.userTickets[userId] || 0;
            console.log(`User ${userId} tickets in competition:`, competitionData.userTicketCount);
            
            // تحديث تذاكر المستخدم في قاعدة البيانات
            await syncUserCompetitionTickets(env, userId, competitionData.userTicketCount);
        }
        
        // إضافة التنسيق الزمني للوقت المتبقي
        competitionData.timeRemainingFormatted = formatTimeRemaining(competitionData.timeRemaining);
        
        return competitionData;
    } catch (error) {
        console.error('Error ensuring competition:', error);
        return null;
    }
}

// دالة لتنسيق الوقت المتبقي
function formatTimeRemaining(ms) {
    if (ms <= 0) return '00:00:00';
    
    const hours = Math.floor(ms / (1000 * 60 * 60));
    const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((ms % (1000 * 60)) / 1000);
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// دالة لحفظ الفائزين في المسابقة القديمة
async function saveCompetitionWinners(env, competitionData) {
    try {
        if (!competitionData.userTickets || Object.keys(competitionData.userTickets).length === 0) {
            return;
        }
        
        const userIds = Object.keys(competitionData.userTickets);
        const totalTickets = competitionData.totalTickets || 0;
        
        if (totalTickets > 0) {
            // اختيار الفائز (الذي لديه أكبر عدد تذاكر)
            let winnerId = userIds[0];
            let maxTickets = competitionData.userTickets[winnerId] || 0;
            
            for (const userId of userIds) {
                const tickets = competitionData.userTickets[userId] || 0;
                if (tickets > maxTickets) {
                    maxTickets = tickets;
                    winnerId = userId;
                }
            }
            
            // حفظ بيانات الفائز
            const winnerData = {
                userId: winnerId,
                tickets: maxTickets,
                prize: competitionData.prizePool || 0,
                timestamp: Date.now(),
                competitionEndTime: competitionData.endTime
            };
            
            await handleDbPush(env, 'competition/winners', winnerData);
            
            // منح الجائزة للمستخدم الفائز
            const userResult = await handleDbGet(env, `users/${winnerId}`);
            if (userResult.success && userResult.data) {
                const userData = userResult.data;
                const newBalance = (userData.tonBalance || 0) + (competitionData.prizePool || 0);
                await handleDbUpdate(env, `users/${winnerId}`, { 
                    tonBalance: newBalance 
                });
                
                await handleDbPush(env, `users/${winnerId}/history`, {
                    type: 'earn',
                    description: 'Competition Prize',
                    amount: competitionData.prizePool || 0,
                    currency: 'TON',
                    date: new Date().toISOString()
                });
                
                console.log(`Prize awarded to user ${winnerId}: ${competitionData.prizePool} TON`);
            }
        }
    } catch (error) {
        console.error('Error saving competition winners:', error);
    }
}

// دالة لتحديث تذاكر المسابقة للمستخدم في قاعدة البيانات
async function syncUserCompetitionTickets(env, userId, ticketCount) {
    try {
        // جلب بيانات المستخدم أولاً
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            console.log(`User ${userId} not found for ticket sync`);
            return false;
        }
        
        const userData = userResult.data;
        const currentTickets = userData.competitionTickets || 0;
        
        // تحديث فقط إذا كانت القيمة مختلفة
        if (currentTickets !== ticketCount) {
            console.log(`Syncing tickets for user ${userId}: ${currentTickets} -> ${ticketCount}`);
            await handleDbUpdate(env, `users/${userId}`, {
                competitionTickets: ticketCount,
                lastTicketSync: Date.now()
            });
            return true;
        }
        
        return false;
    } catch (error) {
        console.error('Error syncing user competition tickets:', error);
        return false;
    }
}

// وظائف إدارة قاعدة البيانات
async function handleDbSet(env, path, data) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error('Database SET error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_SET_ERROR'
        };
    }
}

async function handleDbGet(env, path) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        
        return {
            success: true,
            data: data
        };
    } catch (error) {
        console.error('Database GET error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_GET_ERROR'
        };
    }
}

async function handleDbUpdate(env, path, updates) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updates)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error('Database UPDATE error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_UPDATE_ERROR'
        };
    }
}

async function handleDbPush(env, path, data) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: { name: result.name }
        };
    } catch (error) {
        console.error('Database PUSH error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_PUSH_ERROR'
        };
    }
}

async function handleDbTransaction(env, path, transactionFunction) {
    try {
        const currentData = await handleDbGet(env, path);
        
        if (!currentData.success) {
            return currentData;
        }
        
        const func = new Function('currentValue', `return ${transactionFunction}(currentValue)`);
        const newValue = func(currentData.data || null);
        
        const updateResult = await handleDbSet(env, path, newValue);
        
        return updateResult;
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_TRANSACTION_ERROR'
        };
    }
}

async function handleDbIncrement(env, path, key, amount) {
    try {
        const currentData = await handleDbGet(env, path);
        
        if (!currentData.success) {
            return currentData;
        }
        
        const currentValue = currentData.data[key] || 0;
        const newValue = currentValue + amount;
        
        const updates = { [key]: newValue };
        const updateResult = await handleDbUpdate(env, path, updates);
        
        return updateResult;
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_INCREMENT_ERROR'
        };
    }
}

// وظيفة اختبار Firebase
async function handleTestFirebase(env) {
    try {
        console.log('Testing Firebase connection...');
        console.log('API Key:', env.FIREBASE_API_KEY ? 'Present' : 'Missing');
        console.log('DB URL:', env.FIREBASE_DATABASE_URL);
        
        // اختبار الاتصال
        const testPath = 'connection_test';
        const timestamp = Date.now();
        
        // محاولة الكتابة
        const writeUrl = await getFirebaseUrl(env, testPath);
        console.log('Write URL:', writeUrl);
        
        const writeResponse = await fetch(writeUrl, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                test: true, 
                timestamp: timestamp,
                message: 'Firebase connection test'
            })
        });
        
        console.log('Write status:', writeResponse.status);
        
        if (!writeResponse.ok) {
            const errorText = await writeResponse.text();
            console.error('Write error:', errorText);
            throw new Error(`Write failed: ${writeResponse.status} - ${errorText}`);
        }
        
        const writeResult = await writeResponse.json();
        console.log('Write result:', writeResult);
        
        // محاولة القراءة
        const readResponse = await fetch(writeUrl);
        console.log('Read status:', readResponse.status);
        
        if (!readResponse.ok) {
            const errorText = await readResponse.text();
            throw new Error(`Read failed: ${writeResponse.status} - ${errorText}`);
        }
        
        const readData = await readResponse.json();
        console.log('Read data:', readData);
        
        return {
            success: true,
            message: 'Firebase connection successful',
            data: {
                writeStatus: writeResponse.status,
                readStatus: readResponse.status,
                testData: readData,
                apiKeyLength: env.FIREBASE_API_KEY ? env.FIREBASE_API_KEY.length : 0,
                databaseUrl: env.FIREBASE_DATABASE_URL
            }
        };
    } catch (error) {
        console.error('Firebase test error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'FIREBASE_TEST_ERROR',
            debug: {
                apiKey: env.FIREBASE_API_KEY ? 'Present' : 'Missing',
                apiKeyFirst10: env.FIREBASE_API_KEY ? env.FIREBASE_API_KEY.substring(0, 10) + '...' : 'None',
                dbUrl: env.FIREBASE_DATABASE_URL,
                fullUrl: env.FIREBASE_DATABASE_URL ? `${env.FIREBASE_DATABASE_URL}/test.json` : 'No URL'
            }
        };
    }
}

// وظائف التطبيق الرئيسية المحسنة
async function handleInitializeUser(env, userId, data, telegramData, clientIp) {
    try {
        const { user } = data;
        const deviceFingerprint = data.deviceFingerprint;
        const fullName = `${user.first_name} ${user.last_name || ''}`.trim();
        
        // التحقق من الحظر مع تفاصيل
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return {
                success: false,
                error: `Your account has been blocked for violating system rules`,
                errorCode: 'ACCOUNT_BLOCKED',
                data: {
                    isBlocked: true,
                    blockDetails: {
                        reason: blockCheck.reason,
                        violation: blockCheck.violation,
                        appliedAt: blockCheck.appliedAt,
                        permanent: blockCheck.permanent,
                        details: blockCheck.details
                    },
                    message: `🚫 Account Blocked\n\nReason: ${blockCheck.reason}\nViolation: ${blockCheck.violation}\nDetails: ${blockCheck.details}\n\nThis decision is final.`
                }
            };
        }
        
        // استخراج صورة المستخدم من بيانات Telegram
        let photoUrl = 'https://i.ibb.co/tTkJX1Qy/logo.png'; // صورة افتراضية
        
        try {
            const params = new URLSearchParams(telegramData);
            const userParam = params.get('user');
            
            if (userParam) {
                const telegramUserData = JSON.parse(decodeURIComponent(userParam));
                // صورة المستخدم من Telegram
                if (telegramUserData.photo_url) {
                    photoUrl = telegramUserData.photo_url;
                } else if (telegramUserData.username) {
                    // أو استخدام صورة افتراضية بناءً على اسم المستخدم
                    photoUrl = `https://ui-avatars.com/api/?name=${encodeURIComponent(telegramUserData.username)}&background=random&color=fff`;
                }
            }
        } catch (photoError) {
            console.log('Could not extract user photo:', photoError);
        }
        
        // ==================== التحقق من بصمة الجهاز ====================
        if (deviceFingerprint) {
            // التحقق مما إذا كانت بصمة الجهاز مستخدمة بالفعل من قبل مستخدم آخر
            const fingerprintCheck = await checkDeviceFingerprint(env, deviceFingerprint, userId);
            
            if (fingerprintCheck.deviceAlreadyUsed) {
                // حظر الحساب الحالي فورًا
                await applyBlock(env, userId, {
                    reason: 'Device multi-account violation during initialization',
                    violation: 'DEVICE_MULTI_ACCOUNT',
                    action: 'initializeUser',
                    details: 'Attempt to create new account with device registered to another account',
                    timestamp: Date.now(),
                    permanent: true,
                    clientIp: clientIp,
                    deviceFingerprint: deviceFingerprint
                });
                
                return {
                    success: false,
                    error: 'Device already registered with multiple accounts - All accounts have been blocked',
                    errorCode: 'DEVICE_MULTI_ACCOUNT_BLOCKED',
                    data: {
                        deviceAlreadyUsed: true,
                        existingAccounts: fingerprintCheck.existingAccounts,
                        violationType: 'DEVICE_MULTI_ACCOUNT',
                        accountsBlocked: fingerprintCheck.existingAccounts.length + 1,
                        currentAccountBlocked: true
                    }
                };
            }
        }
        // ==================== نهاية التحقق من بصمة الجهاز ====================
        
        // 1. أولاً: ضمان وجود مسابقة نشطة وجلب بياناتها
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to initialize competition',
                errorCode: 'COMPETITION_INIT_ERROR'
            };
        }
        
        // 2. جلب بيانات المستخدم
        const userResult = await handleDbGet(env, `users/${userId}`);
        let userData = userResult.data;
        
        // احصل على عدد التذاكر الحقيقي من المسابقة
        const realTicketCount = competitionData.userTicketCount || 0;
        
        // إعداد مصفوفة عناوين IP
        let ipAddresses = [];
        if (clientIp && clientIp !== 'Unknown') {
            ipAddresses.push(clientIp);
        }
        
        if (!userData) {
            // إنشاء مستخدم جديد
            userData = {
                id: userId,
                name: fullName,
                photoUrl: photoUrl,
                dogsBalance: 500,
                tonBalance: 0.00,
                adsWatched: 0,
                adsMonetag: 0,
                adsGiga: 0,
                adsAdsgram: 0,
                completedTasks: {},
                history: {},
                referrals: 0,
                dailyStreak: 0,
                lastDailyClaim: 0,
                extraSpins: 1,
                referredUsers: [],
                usedPromoCodes: [],
                joinDate: Date.now(),
                lastLogin: Date.now(),
                lastAdDate: new Date().toDateString(),
                competitionTickets: realTicketCount,
                lastTicketSync: Date.now(),
                isBlocked: false,
                blockReason: null,
                blockedAt: null,
                violationCount: 0,
                // بيانات الأمان
                ...(deviceFingerprint && {
                    deviceFingerprint: deviceFingerprint,
                    deviceRegisteredAt: Date.now(),
                    lastDeviceCheck: Date.now(),
                    deviceInfo: data.deviceInfo || {},
                    deviceLoginCount: 1
                }),
                // بيانات IP
                lastIpAddress: clientIp,
                ipAddresses: ipAddresses
            };
            
            await handleDbSet(env, `users/${userId}`, userData);
            
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'earn',
                description: 'Welcome Bonus',
                amount: 500,
                currency: 'GLX',
                date: new Date().toISOString(),
                securityCheck: 'initialized'
            });
            
            console.log(`New user created: ${userId} with device fingerprint: ${deviceFingerprint ? 'Yes' : 'No'}`);
        } else {
            // تحديث بيانات المستخدم الموجود
            const updates = {
                name: fullName,
                lastLogin: Date.now()
            };
            
            // تحديث الصورة إذا كانت غير موجودة أو مختلفة
            if (!userData.photoUrl || userData.photoUrl === 'https://i.ibb.co/tTkJX1Qy/logo.png') {
                updates.photoUrl = photoUrl;
            }
            
            // تحديث عدد تذاكر المسابقة من المسابقة الحالية
            if (userData.competitionTickets !== realTicketCount) {
                updates.competitionTickets = realTicketCount;
                updates.lastTicketSync = Date.now();
                console.log(`Updating user ${userId} tickets from ${userData.competitionTickets} to ${realTicketCount}`);
            }
            
            // التحقق من الحظر في بيانات المستخدم
            if (userData.isBlocked) {
                const blockStatus = await checkUserBlocked(env, userId);
                if (blockStatus && blockStatus.isBlocked) {
                    return {
                        success: false,
                        error: 'Your account has been blocked for violating system rules',
                        errorCode: 'ACCOUNT_BLOCKED',
                        data: { 
                            isBlocked: true,
                            blockDetails: blockStatus
                        }
                    };
                } else {
                    updates.isBlocked = false;
                    updates.blockReason = null;
                    updates.blockedAt = null;
                }
            }
            
            // تحديث بصمة الجهاز إذا لم تكن موجودة وكانت متوفرة
            if (!userData.deviceFingerprint && deviceFingerprint) {
                updates.deviceFingerprint = deviceFingerprint;
                updates.deviceRegisteredAt = Date.now();
                updates.lastDeviceCheck = Date.now();
                updates.deviceInfo = data.deviceInfo || {};
                updates.deviceLoginCount = (userData.deviceLoginCount || 0) + 1;
            } else if (deviceFingerprint) {
                // تحديث آخر فحص للجهاز
                updates.lastDeviceCheck = Date.now();
                updates.deviceLoginCount = (userData.deviceLoginCount || 0) + 1;
            }
            
            // تحديث IP
            if (clientIp && clientIp !== 'Unknown') {
                updates.lastIpAddress = clientIp;
                
                // تحديث مصفوفة IPs
                let existingIpAddresses = userData.ipAddresses || [];
                if (!existingIpAddresses.includes(clientIp)) {
                    existingIpAddresses.push(clientIp);
                    if (existingIpAddresses.length > 3) {
                        existingIpAddresses = existingIpAddresses.slice(-3);
                    }
                    updates.ipAddresses = existingIpAddresses;
                }
            }
            
            if (Object.keys(updates).length > 0) {
                await handleDbUpdate(env, `users/${userId}`, updates);
            }
            
            // إعادة تعيين عداد الإعلانات إذا تغير اليوم
            const today = new Date().toDateString();
            if (userData.lastAdDate !== today) {
                const resetData = {
                    adsWatched: 0,
                    adsMonetag: 0,
                    adsGiga: 0,
                    adsAdsgram: 0,
                    lastAdDate: today
                };
                
                await handleDbUpdate(env, `users/${userId}`, resetData);
            }
            
            // تحديث بيانات المستخدم بعد التغييرات
            const updatedResult = await handleDbGet(env, `users/${userId}`);
            userData = updatedResult.data || userData;
            
            console.log(`Existing user logged in: ${userId} with device fingerprint: ${deviceFingerprint ? 'Yes' : 'No'}`);
        }
        
        // جلب الإعدادات
        const settingsResult = await handleGetConfig();
        const settings = settingsResult.data?.settings || {};
        
        // التأكد من أن عدد التذاكر يعكس القيمة الحقيقية
        const userTickets = realTicketCount;
        
        return {
            success: true,
            data: {
                userData: {
                    ...userData,
                    competitionTickets: userTickets,
                    deviceFingerprint: deviceFingerprint || userData.deviceFingerprint,
                    ipAddresses: userData.ipAddresses || ipAddresses,
                    lastIpAddress: clientIp || userData.lastIpAddress
                },
                settings: settings,
                contest: {
                    yourTickets: userTickets,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    isActive: competitionData.isActiveNow,
                    endTime: competitionData.endTime,
                    startTime: competitionData.startTime,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted || '24:00:00'
                },
                securityInfo: {
                    deviceVerified: !!deviceFingerprint,
                    ipAddress: clientIp,
                    multiAccountCheck: true
                }
            }
        };
    } catch (error) {
        console.error('Initialize user error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'INITIALIZE_USER_ERROR'
        };
    }
}

async function handleGetConfig() {
    try {
        const settings = {
            // مكافآت الإعلانات
            adRewardMonetag: 1000,
            adRewardGiga: 2000,
            adRewardAdsgram: 2000,
            
            // حدود الإعلانات اليومية
            limitMonetag: 50,
            limitGiga: 300,
            limitAdsgram: 300,
            
            // سعر التذكرة
            ticketPrice: 10000, // سعر التذكرة الواحدة = 10,000 GLX
            maxTicketsPerPurchase: 100,
            minTicketsPerPurchase: 1,
            
            // حدود السحب
            minTonWithdrawal: 0.05,
            minFaucetPayWithdrawal: 0.0001,
            
            // نظام الإحالة
            referralReward: 500,
            
            // أسعار أخرى
            pricePerClick: 0.0015,
            
            // معلومات البوت
            botUsername: '@testtt1257bot',
            botWallet: 'UQB2IqqJtC8NtRgxksq80c_FC8RqShxpGDKA3e4aJFwjvwgv',
            botToken: '7066931017:AAHwuXbgaKHNrHrbf6jaoC8LDk0lSCPimgI',
            
            // نظام الحظر
            maxTimestampDiff: 30000,
            maxViolations: 1, // مخالفة واحدة فقط للحظر
            blockDuration: 0, // حظر دائم
            instantBlock: true, // حظر فوري بعد مخالفة واحدة
            
            // Coin Flip limits
            coinFlipMinBet: 1000, // الحد الأدنى للرهان
            coinFlipMaxBet: 100000, // الحد الأقصى للرهان
            
            // مكافآت المهام
            taskChannelReward: 2000, // مكافأة الانضمام للقناة
            maxTaskReward: 20000, // الحد الأقصى لمكافأة المهمة
            
            // حدود البرومو كود
            maxPromoReward: 10000, // الحد الأقصى لمكافأة البرومو كود
            
            // نظام بصمة الجهاز
            enableDeviceFingerprint: true, // تفعيل نظام التحقق من بصمة الجهاز
            allowMultipleDevices: false, // عدم السماح بأجهزة متعددة لنفس المستخدم
            deviceCheckRequired: true, // التحقق من الجهاز مطلوب للمستخدمين الجدد
            maxIpsPerUser: 3, // الحد الأقصى لعدد IPs المخزنة لكل مستخدم
            
            // إعدادات الأمان
            periodicDeviceCheckInterval: 30000, // فحص دوري كل 30 ثانية
            enableIpTracking: true, // تتبع عناوين IP
            multiAccountDetection: true, // كشف الحسابات المتعددة
            multiAccountAutoBlock: true, // حظر تلقائي للحسابات المتعددة
            blockAllLinkedAccounts: true // حظر جميع الحسابات المرتبطة بنفس الجهاز
        };
        
        return {
            success: true,
            data: { settings }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_CONFIG_ERROR'
        };
    }
}

async function handleExecuteSwap(env, userId, data) {
    try {
        const { type, amount, tonValue, glxValue } = data;
        
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        let updates = {};
        let historyEntry = {};
        
        if (type === 'glx_to_ton') {
            if (userData.dogsBalance < amount) {
                return { 
                    success: false, 
                    error: 'Insufficient GLX balance',
                    errorCode: 'INSUFFICIENT_GLX_BALANCE'
                };
            }
            
            updates.dogsBalance = userData.dogsBalance - amount;
            updates.tonBalance = (userData.tonBalance || 0) + tonValue;
            
            historyEntry = {
                type: 'swap_out',
                description: 'Swap GLX to TON',
                amount: amount,
                currency: 'GLX',
                date: new Date().toISOString()
            };
            
            await handleDbPush(env, `users/${userId}/history`, historyEntry);
            
            historyEntry = {
                type: 'swap_in',
                description: 'Received from GLX Swap',
                amount: tonValue,
                currency: 'TON',
                date: new Date().toISOString()
            };
            
        } else if (type === 'ton_to_glx') {
            if ((userData.tonBalance || 0) < amount) {
                return { 
                    success: false, 
                    error: 'Insufficient TON balance',
                    errorCode: 'INSUFFICIENT_TON_BALANCE'
                };
            }
            
            updates.tonBalance = (userData.tonBalance || 0) - amount;
            updates.dogsBalance = userData.dogsBalance + glxValue;
            
            historyEntry = {
                type: 'swap_out',
                description: 'Swap TON to GLX',
                amount: amount,
                currency: 'TON',
                date: new Date().toISOString()
            };
            
            await handleDbPush(env, `users/${userId}/history`, historyEntry);
            
            historyEntry = {
                type: 'swap_in',
                description: 'Received from TON Swap',
                amount: glxValue,
                currency: 'GLX',
                date: new Date().toISOString()
            };
        } else {
            return { 
                success: false, 
                error: 'Invalid swap type',
                errorCode: 'INVALID_SWAP_TYPE'
            };
        }
        
        await handleDbUpdate(env, `users/${userId}`, updates);
        
        await handleDbPush(env, `users/${userId}/history`, historyEntry);
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || { ...userData, ...updates };
        
        return {
            success: true,
            data: {
                newGLXBalance: updatedUserData.dogsBalance,
                newTONBalance: updatedUserData.tonBalance
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'EXECUTE_SWAP_ERROR'
        };
    }
}

async function handleVerifyDeposit(env, userId, data) {
    try {
        const { memo, amount } = data;
        
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const currentTime = Date.now();
        const memoTime = parseInt(memo.split('_').pop());
        
        if (currentTime - memoTime > 30000) {
            const userResult = await handleDbGet(env, `users/${userId}`);
            if (!userResult.success) {
                return { 
                    success: false, 
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            const userData = userResult.data;
            const newBalance = (userData.tonBalance || 0) + amount;
            
            await handleDbUpdate(env, `users/${userId}`, { tonBalance: newBalance });
            
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'deposit',
                description: `TON Deposit #${memo.substring(0, 8)}`,
                amount: amount,
                currency: 'TON',
                date: new Date().toISOString()
            });
            
            return {
                success: true,
                data: {
                    newBalance: newBalance,
                    txHash: memo.substring(0, 12)
                }
            };
        } else {
            return { 
                success: false, 
                error: 'Deposit not confirmed yet',
                errorCode: 'DEPOSIT_NOT_CONFIRMED'
            };
        }
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_DEPOSIT_ERROR'
        };
    }
}

async function handleBuyTickets(env, userId, data) {
    try {
        const { tickets, totalCost } = data;
        
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        // جلب سعر التذكرة من الإعدادات
        const configResult = await handleGetConfig();
        const settings = configResult.data?.settings || {};
        const TICKET_PRICE = settings.ticketPrice || 10000;
        
        // حساب التكلفة المتوقعة
        const ticketsCount = parseInt(tickets);
        const expectedCost = ticketsCount * TICKET_PRICE;
        const costAmount = parseInt(totalCost);
        
        // التحقق من صحة التكلفة
        if (costAmount !== expectedCost) {
            return { 
                success: false, 
                error: `Invalid ticket cost: Expected ${expectedCost}, got ${costAmount}`,
                errorCode: 'INVALID_TICKET_COST'
            };
        }
        
        if (userData.dogsBalance < costAmount) {
            return { 
                success: false, 
                error: 'Insufficient GLX balance',
                errorCode: 'INSUFFICIENT_GLX_BALANCE'
            };
        }
        
        const newBalance = userData.dogsBalance - costAmount;
        
        // تحديث رصيد المستخدم أولاً
        await handleDbUpdate(env, `users/${userId}`, { 
            dogsBalance: newBalance
        });
        
        // تأكد من وجود مسابقة نشطة
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return { 
                success: false, 
                error: 'No active competition found',
                errorCode: 'NO_ACTIVE_COMPETITION'
            };
        }
        
        // تحديث تذاكر المستخدم في المسابقة
        const currentUserTickets = competitionData.userTickets[userId] || 0;
        competitionData.userTickets[userId] = currentUserTickets + ticketsCount;
        
        // تحديث الإحصائيات العامة
        competitionData.totalTickets = (competitionData.totalTickets || 0) + ticketsCount;
        competitionData.prizePool = competitionData.totalTickets * 0.001;
        
        // حفظ المسابقة المحدثة
        await handleDbSet(env, 'competition/current', {
            isActive: competitionData.isActive,
            startTime: competitionData.startTime,
            endTime: competitionData.endTime,
            totalTickets: competitionData.totalTickets,
            prizePool: competitionData.prizePool,
            userTickets: competitionData.userTickets,
            winners: competitionData.winners || [],
            lastUpdated: Date.now()
        });
        
        // تحديث عدد تذاكر المستخدم في بياناته الشخصية
        const newTicketCount = competitionData.userTickets[userId];
        await handleDbUpdate(env, `users/${userId}`, {
            competitionTickets: newTicketCount,
            lastTicketSync: Date.now()
        });
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'spend',
            description: `Bought ${ticketsCount} Competition Ticket${ticketsCount > 1 ? 's' : ''}`,
            amount: costAmount,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        // حساب الوقت المتبقي
        const now = Date.now();
        const timeRemaining = Math.max(0, competitionData.endTime - now);
        const timeRemainingFormatted = formatTimeRemaining(timeRemaining);
        
        return {
            success: true,
            data: {
                newBalance: updatedUserData.dogsBalance,
                userTickets: competitionData.userTickets[userId],
                totalTickets: competitionData.totalTickets,
                prizePool: competitionData.prizePool,
                contestEndTime: competitionData.endTime,
                timeRemaining: timeRemaining,
                timeRemainingFormatted: timeRemainingFormatted,
                userCompetitionTickets: newTicketCount
            }
        };
    } catch (error) {
        console.error('Buy tickets error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'BUY_TICKETS_ERROR'
        };
    }
}

async function handleGetCompetitionLeaderboard(env) {
    try {
        // تأكد من وجود مسابقة نشطة
        const competitionData = await ensureAndGetCompetition(env);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'No active competition found',
                errorCode: 'NO_ACTIVE_COMPETITION'
            };
        }
        
        const userTickets = competitionData.userTickets || {};
        const leaderboard = [];
        
        for (const [userId, tickets] of Object.entries(userTickets)) {
            if (tickets > 0) {
                const userResult = await handleDbGet(env, `users/${userId}`);
                if (userResult.success && userResult.data) {
                    // تخطي المستخدمين المحظورين من المتصدرين
                    if (userResult.data.isBlocked) continue;
                    
                    leaderboard.push({
                        userId: userId,
                        name: userResult.data.name || 'Anonymous',
                        photoUrl: userResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                        tickets: tickets
                    });
                }
            }
        }
        
        leaderboard.sort((a, b) => b.tickets - a.tickets);
        
        return {
            success: true,
            data: {
                leaderboard: leaderboard.slice(0, 10),
                contest: {
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    endTime: competitionData.endTime,
                    startTime: competitionData.startTime,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted,
                    isActive: competitionData.isActiveNow
                }
            }
        };
    } catch (error) {
        console.error('Get competition leaderboard error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_COMPETITION_LEADERBOARD_ERROR'
        };
    }
}

async function handleGetPreviousWinners(env) {
    try {
        const winnersResult = await handleDbGet(env, 'competition/winners');
        const winnersData = winnersResult.data || {};
        
        const winners = [];
        
        for (const [key, winner] of Object.entries(winnersData)) {
            if (winner.userId) {
                const userResult = await handleDbGet(env, `users/${winner.userId}`);
                if (userResult.success && userResult.data) {
                    // تخطي المستخدمين المحظورين
                    if (userResult.data.isBlocked) continue;
                    
                    winners.push({
                        userId: winner.userId,
                        name: userResult.data.name || 'Anonymous',
                        photoUrl: userResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                        tickets: winner.tickets || 0,
                        prize: winner.prize || 0,
                        timestamp: winner.timestamp || Date.now()
                    });
                }
            }
        }
        
        winners.sort((a, b) => b.timestamp - a.timestamp);
        
        return {
            success: true,
            data: {
                winners: winners.slice(0, 10)
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_PREVIOUS_WINNERS_ERROR'
        };
    }
}

async function handleFlipCoin(env, userId, data) {
    try {
        const { betAmount, chosenSide } = data;
        
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        const betAmountNum = parseInt(betAmount);
        
        if (userData.dogsBalance < betAmountNum) {
            return { 
                success: false, 
                error: 'Insufficient GLX balance',
                errorCode: 'INSUFFICIENT_GLX_BALANCE'
            };
        }
        
        const newBalance = userData.dogsBalance - betAmountNum;
        await handleDbUpdate(env, `users/${userId}`, { dogsBalance: newBalance });
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'loss',
            description: `Coin Flip Bet (${chosenSide.toUpperCase()})`,
            amount: betAmountNum,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        const randomNum = Math.random() * 100;
        const isWin = randomNum < 45;
        const resultSide = isWin ? chosenSide : (chosenSide === 'glx' ? 'gold' : 'glx');
        const winAmount = isWin ? betAmountNum * 2 : 0;
        
        if (isWin) {
            const finalBalance = newBalance + winAmount;
            await handleDbUpdate(env, `users/${userId}`, { dogsBalance: finalBalance });
            
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'earn',
                description: `Coin Flip Win (${chosenSide})`,
                amount: winAmount,
                currency: 'GLX',
                date: new Date().toISOString()
            });
        }
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        return {
            success: true,
            data: {
                isWin: isWin,
                resultSide: resultSide,
                winAmount: winAmount,
                newBalance: isWin ? newBalance + winAmount : newBalance,
                currentBalance: updatedUserData.dogsBalance
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'FLIP_COIN_ERROR'
        };
    }
}

async function handleRedeemPromoCode(env, userId, data) {
    try {
        const { code } = data;
        
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const validCodes = {
            'WELCOME100': 100,
            'GALAXY500': 500,
            'STAR1000': 1000,
            'BONUS2000': 2000,
            'VIP5000': 5000
        };
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        const usedCodes = userData.usedPromoCodes || [];
        
        if (!validCodes[code]) {
            // ليس خطأ - فقط كود غير صالح
            return { 
                success: false, 
                error: 'Invalid or expired promo code',
                errorCode: 'INVALID_PROMO_CODE'
            };
        }
        
        if (usedCodes.includes(code)) {
            // ليس خطأ - فقط كود مستخدم مسبقاً
            return { 
                success: false, 
                error: 'This code has already been used',
                errorCode: 'PROMO_CODE_ALREADY_USED'
            };
        }
        
        const reward = validCodes[code];
        
        // جلب الحد الأقصى من الإعدادات
        const configResult = await handleGetConfig();
        const settings = configResult.data?.settings || {};
        const MAX_PROMO_REWARD = settings.maxPromoReward || 10000;
        
        // التحقق من أن المكافأة لا تتجاوز الحد الأقصى
        if (reward > MAX_PROMO_REWARD) {
            return { 
                success: false, 
                error: 'Promo code reward exceeds maximum allowed',
                errorCode: 'EXCESSIVE_PROMO_REWARD'
            };
        }
        
        const newBalance = userData.dogsBalance + reward;
        await handleDbUpdate(env, `users/${userId}`, { dogsBalance: newBalance });
        
        usedCodes.push(code);
        await handleDbUpdate(env, `users/${userId}`, { usedPromoCodes: usedCodes });
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: `Promo Code: ${code}`,
            amount: reward,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        return {
            success: true,
            data: {
                reward: reward,
                newBalance: updatedUserData.dogsBalance
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'REDEEM_PROMO_CODE_ERROR'
        };
    }
}

async function handleCreateTask(env, userId, data) {
    try {
        const { taskId, name, link, category, count, cost } = data;
        
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        // إنشاء مهمة جديدة بحالة pending payment
        const newTask = {
            id: taskId,
            title: name,
            description: `Reward: ${category.toUpperCase()}`,
            link: link,
            reward: 2000,
            category: 'community',
            total: parseInt(count),
            remaining: parseInt(count),
            status: 'pending_payment', // حالة جديدة للانتظار
            creator: userId,
            cost: parseFloat(cost),
            createdAt: Date.now(),
            paymentVerified: false,
            paymentCheckCount: 0,
            lastPaymentCheck: null
        };
        
        await handleDbSet(env, `tasks/${taskId}`, newTask);
        
        // تسجيل طلب إنشاء المهمة
        await handleDbPush(env, `task_requests/${taskId}`, {
            userId: userId,
            taskData: newTask,
            requestedAt: Date.now(),
            status: 'awaiting_payment'
        });
        
        return {
            success: true,
            data: { 
                taskId: taskId,
                status: 'pending_payment',
                message: 'Task created successfully. Please wait 10 seconds for payment verification.',
                nextStep: 'verifyPayment',
                verifyAfter: 10000 // 10 ثوانٍ
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'CREATE_TASK_ERROR'
        };
    }
}

async function handleVerifyTaskPayment(env, taskId) {
    try {
        const taskResult = await handleDbGet(env, `tasks/${taskId}`);
        if (!taskResult.success || !taskResult.data) {
            return { 
                success: false, 
                error: 'Task not found',
                errorCode: 'TASK_NOT_FOUND'
            };
        }
        
        const task = taskResult.data;
        const now = Date.now();
        
        // تحديث عدد مرات التحقق
        const checkCount = (task.paymentCheckCount || 0) + 1;
        
        await handleDbUpdate(env, `tasks/${taskId}`, { 
            paymentCheckCount: checkCount,
            lastPaymentCheck: now
        });
        
        // التحقق اليدوي - في الإصدار الحقيقي، هنا ستتحقق من خدمة الدفع
        // محاكاة: بعد 10 ثوانٍ من الإنشاء، يتم التحقق تلقائيًا
        
        const timeSinceCreation = now - (task.createdAt || 0);
        
        if (timeSinceCreation >= 10000) { // 10 ثوانٍ
            // تم التحقق من الدفع (محاكاة)
            await handleDbUpdate(env, `tasks/${taskId}`, { 
                status: 'active',
                paymentVerified: true,
                verifiedAt: now,
                activeSince: now
            });
            
            // تحديث طلب المهمة
            await handleDbUpdate(env, `task_requests/${taskId}`, {
                status: 'payment_verified',
                verifiedAt: now,
                verifiedBy: 'system_auto'
            });
            
            return {
                success: true,
                data: { 
                    verified: true,
                    status: 'active',
                    message: 'Payment verified successfully. Task is now active.',
                    taskId: taskId,
                    verifiedAt: now
                }
            };
        } else {
            // الانتظار لمزيد من الوقت
            const timeRemaining = 10000 - timeSinceCreation;
            
            return {
                success: true,
                data: { 
                    verified: false,
                    status: 'pending_payment',
                    message: 'Payment verification in progress. Please wait...',
                    timeRemaining: Math.max(0, timeRemaining),
                    checkCount: checkCount,
                    nextCheckIn: Math.ceil(timeRemaining / 1000)
                }
            };
        }
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_TASK_PAYMENT_ERROR'
        };
    }
}

// دالة محسنة للتحقق من عضوية قناة Telegram
async function handleVerifyTaskChannel(env, userId, data) {
    try {
        const { taskId, channelUsername } = data;
        
        console.log(`Verifying channel membership for user ${userId} in channel ${channelUsername}`);
        
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        // جلب بيانات المستخدم
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        const completedTasks = userData.completedTasks || {};
        
        // التحقق مما إذا كانت المهمة مكتملة بالفعل
        if (completedTasks[taskId]) {
            return { 
                success: true,
                data: {
                    alreadyCompleted: true,
                    verified: true,
                    message: 'Task already completed.',
                    reward: completedTasks[taskId].reward || 0,
                    newBalance: userData.dogsBalance,
                    taskStatus: 'already_completed'
                }
            };
        }
        
        // تنظيف اسم القناة
        let cleanChannelUsername = channelUsername;
        
        if (cleanChannelUsername.includes('t.me/')) {
            cleanChannelUsername = cleanChannelUsername.split('t.me/')[1];
        }
        
        if (cleanChannelUsername.startsWith('@')) {
            cleanChannelUsername = cleanChannelUsername.substring(1);
        }
        
        console.log(`Cleaned channel username: ${cleanChannelUsername}`);
        
        // جلب Bot Token
        const botToken = env.TELEGRAM_BOT_TOKEN || '7066931017:AAHwuXbgaKHNrHrbf6jaoC8LDk0lSCPimgI';
        
        if (!botToken) {
            return { 
                success: false, 
                error: 'Bot token not configured',
                errorCode: 'BOT_TOKEN_MISSING'
            };
        }
        
        // استخدام Telegram Bot API للتحقق من عضوية المستخدم
        const chatMemberUrl = `https://api.telegram.org/bot${botToken}/getChatMember`;
        
        console.log(`Calling Telegram API: ${chatMemberUrl}`);
        console.log(`Request data: chat_id=@${cleanChannelUsername}, user_id=${userId}`);
        
        let telegramResult;
        
        try {
            // المحاولة الأولى: استخدام @username
            const response = await fetch(chatMemberUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: `@${cleanChannelUsername}`,
                    user_id: parseInt(userId)
                })
            });
            
            console.log(`Telegram API response status: ${response.status}`);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error(`Telegram API error: ${errorText}`);
                
                // محاولة بديلة باستخدام numeric chat_id
                try {
                    // استعلام عن معلومات القناة للحصول على chat_id الرقمي
                    const getChatUrl = `https://api.telegram.org/bot${botToken}/getChat`;
                    const getChatResponse = await fetch(getChatUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chat_id: `@${cleanChannelUsername}`
                        })
                    });
                    
                    if (getChatResponse.ok) {
                        const chatInfo = await getChatResponse.json();
                        console.log(`Chat info: ${JSON.stringify(chatInfo)}`);
                        
                        if (chatInfo.ok && chatInfo.result) {
                            const numericChatId = chatInfo.result.id;
                            console.log(`Found numeric chat ID: ${numericChatId}`);
                            
                            // إعادة المحاولة باستخدام numeric chat_id
                            const retryResponse = await fetch(chatMemberUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    chat_id: numericChatId,
                                    user_id: parseInt(userId)
                                })
                            });
                            
                            if (retryResponse.ok) {
                                telegramResult = await retryResponse.json();
                            } else {
                                throw new Error('Failed with numeric chat ID too');
                            }
                        }
                    }
                } catch (fallbackError) {
                    console.error('Fallback verification failed:', fallbackError);
                    return { 
                        success: false, 
                        error: 'Failed to verify channel membership. Please make sure you have joined the channel and try again.',
                        errorCode: 'TELEGRAM_API_ERROR',
                        data: {
                            verificationStatus: 'failed',
                            errorDetails: errorText,
                            debug: {
                                channelUsername: cleanChannelUsername,
                                userId: userId
                            }
                        }
                    };
                }
            } else {
                telegramResult = await response.json();
            }
            
            console.log(`Telegram API result: ${JSON.stringify(telegramResult)}`);
            
            if (!telegramResult.ok) {
                return {
                    success: false,
                    error: 'Unable to verify membership. Please try again.',
                    errorCode: 'TELEGRAM_API_FAILED',
                    data: {
                        telegramResult: telegramResult,
                        verificationStatus: 'api_failed'
                    }
                };
            }
            
            // التحقق من حالة العضوية بشكل دقيق
            const memberStatus = telegramResult.result.status;
            const isMember = memberStatus === 'member' || 
                           memberStatus === 'administrator' || 
                           memberStatus === 'creator';
            
            console.log(`User ${userId} membership status: ${memberStatus}, isMember: ${isMember}`);
            
            if (!isMember) {
                return { 
                    success: false, 
                    error: 'You must join the channel first! Please join the channel and try again.',
                    errorCode: 'NOT_CHANNEL_MEMBER',
                    data: {
                        verificationStatus: 'not_member',
                        channelUsername: cleanChannelUsername,
                        currentStatus: memberStatus,
                        requiredStatus: ['member', 'administrator', 'creator']
                    }
                };
            }
            
            // المكافأة من الإعدادات
            const configResult = await handleGetConfig();
            const settings = configResult.data?.settings || {};
            const TASK_CHANNEL_REWARD = settings.taskChannelReward || 2000;
            
            // تحديث بيانات المهمة
            completedTasks[taskId] = {
                completedAt: Date.now(),
                channel: cleanChannelUsername,
                reward: TASK_CHANNEL_REWARD,
                status: 'completed',
                verifiedAt: Date.now()
            };
            
            const newBalance = (userData.dogsBalance || 0) + TASK_CHANNEL_REWARD;
            
            // تحديث المستخدم
            await handleDbUpdate(env, `users/${userId}`, { 
                completedTasks: completedTasks,
                dogsBalance: newBalance,
                lastTaskCompletion: Date.now()
            });
            
            // تحديث المهمة في قاعدة البيانات
            const taskResult = await handleDbGet(env, `tasks/${taskId}`);
            if (taskResult.success && taskResult.data) {
                const task = taskResult.data;
                if (task.remaining !== undefined && task.remaining > 0) {
                    await handleDbUpdate(env, `tasks/${taskId}`, { 
                        remaining: task.remaining - 1,
                        lastCompleted: Date.now(),
                        lastCompletedBy: userId,
                        completedCount: (task.completedCount || 0) + 1
                    });
                }
            }
            
            // تسجيل في السجل
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'earn',
                description: `Joined Telegram Channel: ${cleanChannelUsername}`,
                amount: TASK_CHANNEL_REWARD,
                currency: 'GLX',
                date: new Date().toISOString(),
                taskId: taskId,
                channel: cleanChannelUsername
            });
            
            // حفظ تفاصيل الإكمال
            await handleDbSet(env, `tasks/${taskId}/completions/${userId}`, {
                completedAt: Date.now(),
                reward: TASK_CHANNEL_REWARD,
                verified: true,
                channel: cleanChannelUsername,
                status: 'completed',
                userId: userId
            });
            
            return {
                success: true,
                data: {
                    verified: true,
                    reward: TASK_CHANNEL_REWARD,
                    newBalance: newBalance,
                    channel: cleanChannelUsername,
                    membershipStatus: memberStatus,
                    message: 'Successfully verified channel membership! Task completed.',
                    taskStatus: 'completed',
                    taskId: taskId,
                    completionTime: Date.now()
                }
            };
            
        } catch (apiError) {
            console.error('Telegram API call failed:', apiError);
            return { 
                success: false, 
                error: 'Unable to verify channel membership at this time. Please try again later.',
                errorCode: 'TELEGRAM_API_CALL_FAILED',
                data: {
                    errorDetails: apiError.message,
                    verificationStatus: 'api_error'
                }
            };
        }
        
    } catch (error) {
        console.error('Verify task channel error:', error);
        return {
            success: false,
            error: 'An unexpected error occurred. Please try again.',
            errorCode: 'VERIFY_TASK_CHANNEL_ERROR',
            data: {
                errorDetails: error.message,
                verificationStatus: 'error'
            }
        };
    }
}

// دالة جديدة لاختبار Telegram API
async function handleTestTelegramApi(env, userId, data) {
    try {
        const { channelUsername } = data;
        
        console.log(`Testing Telegram API for channel: ${channelUsername}, user: ${userId}`);
        
        const botToken = env.TELEGRAM_BOT_TOKEN || '7066931017:AAHwuXbgaKHNrHrbf6jaoC8LDk0lSCPimgI';
        
        if (!botToken) {
            return {
                success: false,
                error: 'Bot token not configured',
                errorCode: 'BOT_TOKEN_MISSING'
            };
        }
        
        // اختبار 1: الحصول على معلومات البوت
        const getMeUrl = `https://api.telegram.org/bot${botToken}/getMe`;
        const getMeResponse = await fetch(getMeUrl);
        const getMeResult = await getMeResponse.json();
        
        console.log('Bot info:', getMeResult);
        
        // اختبار 2: الحصول على معلومات القناة
        let cleanChannelUsername = channelUsername;
        
        if (cleanChannelUsername.includes('t.me/')) {
            cleanChannelUsername = cleanChannelUsername.split('t.me/')[1];
        }
        
        if (cleanChannelUsername.startsWith('@')) {
            cleanChannelUsername = cleanChannelUsername.substring(1);
        }
        
        const getChatUrl = `https://api.telegram.org/bot${botToken}/getChat`;
        const getChatResponse = await fetch(getChatUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: `@${cleanChannelUsername}`
            })
        });
        
        const getChatResult = await getChatResponse.json();
        
        console.log('Channel info:', getChatResult);
        
        // اختبار 3: التحقق من عضوية المستخدم
        const chatMemberUrl = `https://api.telegram.org/bot${botToken}/getChatMember`;
        let membershipResult = null;
        
        if (getChatResult.ok && getChatResult.result) {
            // استخدام numeric chat_id إذا كان متاحًا
            const numericChatId = getChatResult.result.id;
            
            const chatMemberResponse = await fetch(chatMemberUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: numericChatId,
                    user_id: parseInt(userId)
                })
            });
            
            membershipResult = await chatMemberResponse.json();
        } else {
            // المحاولة باستخدام username
            const chatMemberResponse = await fetch(chatMemberUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: `@${cleanChannelUsername}`,
                    user_id: parseInt(userId)
                })
            });
            
            membershipResult = await chatMemberResponse.json();
        }
        
        console.log('Membership check:', membershipResult);
        
        return {
            success: true,
            data: {
                botInfo: getMeResult,
                channelInfo: getChatResult,
                membershipCheck: membershipResult,
                debug: {
                    channelUsername: cleanChannelUsername,
                    userId: userId,
                    botTokenExists: !!botToken,
                    botTokenFirst10: botToken.substring(0, 10) + '...'
                }
            }
        };
        
    } catch (error) {
        console.error('Test Telegram API error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'TEST_TELEGRAM_API_ERROR',
            stack: error.stack
        };
    }
}

// دالة للتحقق من عضوية Telegram بشكل عام
async function handleVerifyTelegramMembership(env, userId, data) {
    try {
        const { channelUsername } = data;
        
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const botToken = env.TELEGRAM_BOT_TOKEN || '7066931017:AAHwuXbgaKHNrHrbf6jaoC8LDk0lSCPimgI';
        
        if (!botToken) {
            return { 
                success: false, 
                error: 'Bot token not configured',
                errorCode: 'BOT_TOKEN_MISSING'
            };
        }
        
        // تنظيف اسم القناة
        let cleanChannelUsername = channelUsername;
        
        if (cleanChannelUsername.includes('t.me/')) {
            cleanChannelUsername = cleanChannelUsername.split('t.me/')[1];
        }
        
        if (cleanChannelUsername.startsWith('@')) {
            cleanChannelUsername = cleanChannelUsername.substring(1);
        }
        
        const chatMemberUrl = `https://api.telegram.org/bot${botToken}/getChatMember`;
        
        const response = await fetch(chatMemberUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: `@${cleanChannelUsername}`,
                user_id: parseInt(userId)
            })
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            return { 
                success: false, 
                error: 'Failed to verify membership',
                errorCode: 'TELEGRAM_API_ERROR',
                details: errorText
            };
        }
        
        const result = await response.json();
        
        const isMember = result.ok && 
            (result.result.status === 'member' || 
             result.result.status === 'administrator' || 
             result.result.status === 'creator');
        
        return {
            success: true,
            data: {
                isMember: isMember,
                channelUsername: cleanChannelUsername,
                userId: userId,
                status: result.result.status,
                requiredStatus: ['member', 'administrator', 'creator']
            }
        };
        
    } catch (error) {
        console.error('Verify telegram membership error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_TELEGRAM_MEMBERSHIP_ERROR'
        };
    }
}

async function handleSpinSlots(env, userId) {
    try {
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        if ((userData.extraSpins || 0) <= 0) {
            return { 
                success: false, 
                error: 'No spins left',
                errorCode: 'NO_SPINS_AVAILABLE'
            };
        }
        
        const newSpins = (userData.extraSpins || 1) - 1;
        await handleDbUpdate(env, `users/${userId}`, { extraSpins: newSpins });
        
        const symbols = ['🌟', '🪐', '💫', '⭐', '🚀', '🌌'];
        const results = [
            symbols[Math.floor(Math.random() * symbols.length)],
            symbols[Math.floor(Math.random() * symbols.length)],
            symbols[Math.floor(Math.random() * symbols.length)]
        ];
        
        let winAmount = 0;
        const resultString = results.join('');
        
        if (resultString === '🌟🌟🌟') winAmount = 10000;
        else if (resultString === '🪐🪐🪐') winAmount = 5000;
        else if (resultString === '💫💫💫') winAmount = 2500;
        else if (resultString === '⭐⭐⭐') winAmount = 1200;
        else if (results[0] === '🌟' && results[1] === '🌟') winAmount = 700;
        else if (results[1] === '🌟' && results[2] === '🌟') winAmount = 700;
        else if (results[0] === results[1] || results[1] === results[2] || results[0] === results[2]) winAmount = 500;
        
        if (winAmount > 0) {
            const newBalance = userData.dogsBalance + winAmount;
            await handleDbUpdate(env, `users/${userId}`, { dogsBalance: newBalance });
            
            await handleDbPush(env, `users/${userId}/history`, {
                type: 'earn',
                description: `Galaxy Slots Win (${resultString})`,
                amount: winAmount,
                currency: 'GLX',
                date: new Date().toISOString()
            });
            
            // جلب بيانات المستخدم المحدثة
            const updatedUserResult = await handleDbGet(env, `users/${userId}`);
            const updatedUserData = updatedUserResult.data || userData;
            
            return {
                success: true,
                data: {
                    results: results,
                    winAmount: winAmount,
                    newBalance: updatedUserData.dogsBalance,
                    newSpins: newSpins
                }
            };
        } else {
            // جلب بيانات المستخدم المحدثة
            const updatedUserResult = await handleDbGet(env, `users/${userId}`);
            const updatedUserData = updatedUserResult.data || userData;
            
            return {
                success: true,
                data: {
                    results: results,
                    winAmount: 0,
                    newBalance: updatedUserData.dogsBalance,
                    newSpins: newSpins
                }
            };
        }
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'SPIN_SLOTS_ERROR'
        };
    }
}

async function handleAddExtraSpin(env, userId) {
    try {
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        const newSpins = (userData.extraSpins || 0) + 1;
        await handleDbUpdate(env, `users/${userId}`, { extraSpins: newSpins });
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: 'Extra Spin from Ad',
            amount: 1,
            currency: 'Spin',
            date: new Date().toISOString()
        });
        
        return {
            success: true,
            data: {
                newSpins: newSpins
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'ADD_EXTRA_SPIN_ERROR'
        };
    }
}

async function handleClaimDailyBonus(env, userId) {
    try {
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        const now = Date.now();
        const msInDay = 86400000;
        
        let streak = userData.dailyStreak || 0;
        const lastClaim = userData.lastDailyClaim || 0;
        
        if (now - lastClaim > 172800000) {
            streak = 0;
        }
        
        const rewards = [2000, 3000, 5000, 7000, 9000, 12000, 15000];
        const reward = rewards[Math.min(streak, rewards.length - 1)] || 100;
        
        const updates = {
            lastDailyClaim: now,
            dailyStreak: streak + 1,
            dogsBalance: userData.dogsBalance + reward
        };
        
        await handleDbUpdate(env, `users/${userId}`, updates);
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: `Daily Login Day ${streak + 1}`,
            amount: reward,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        return {
            success: true,
            data: {
                reward: reward,
                lastDailyClaim: now,
                dailyStreak: streak + 1,
                newBalance: updatedUserData.dogsBalance
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'CLAIM_DAILY_BONUS_ERROR'
        };
    }
}

async function handleGetTransactionHistory(env, userId, limit = 50) {
    try {
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const historyResult = await handleDbGet(env, `users/${userId}/history`);
        const historyData = historyResult.data || {};
        
        const historyArray = Object.values(historyData)
            .sort((a, b) => new Date(b.date) - new Date(a.date))
            .slice(0, limit);
        
        return {
            success: true,
            data: {
                history: historyArray
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_TRANSACTION_HISTORY_ERROR'
        };
    }
}

async function handleGetUserWithdrawals(env, userId) {
    try {
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const withdrawalsResult = await handleDbGet(env, 'withdrawals');
        const withdrawalsData = withdrawalsResult.data || {};
        
        const userWithdrawals = [];
        
        for (const [key, withdrawal] of Object.entries(withdrawalsData)) {
            if (withdrawal.userId === userId) {
                userWithdrawals.push({
                    key: key,
                    ...withdrawal
                });
            }
        }
        
        userWithdrawals.sort((a, b) => b.timestamp - a.timestamp);
        
        return {
            success: true,
            data: {
                withdrawals: userWithdrawals
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_USER_WITHDRAWALS_ERROR'
        };
    }
}

async function handleGetWithdrawalHistory(env) {
    try {
        const withdrawalsResult = await handleDbGet(env, 'withdrawals/completed');
        const withdrawalsData = withdrawalsResult.data || {};
        
        const withdrawals = [];
        
        for (const [key, withdrawal] of Object.entries(withdrawalsData)) {
            if (withdrawal.status === 'completed' || withdrawal.processed === true) {
                const userResult = await handleDbGet(env, `users/${withdrawal.userId}`);
                if (userResult.success && userResult.data) {
                    // تخطي المستخدمين المحظورين
                    if (userResult.data.isBlocked) continue;
                    
                    withdrawals.push({
                        ...withdrawal,
                        key: key,
                        name: userResult.data.name || 'Anonymous',
                        photoUrl: userResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png'
                    });
                }
            }
        }
        
        withdrawals.sort((a, b) => b.timestamp - a.timestamp);
        
        return {
            success: true,
            data: {
                withdrawals: withdrawals.slice(0, 50)
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_WITHDRAWAL_HISTORY_ERROR'
        };
    }
}

async function handleGetWithdrawalStats(env) {
    try {
        const withdrawalsResult = await handleDbGet(env, 'withdrawals');
        const withdrawalsData = withdrawalsResult.data || {};
        
        let completedCount = 0;
        let totalPaid = 0;
        let pendingCount = 0;
        
        for (const [key, withdrawal] of Object.entries(withdrawalsData)) {
            if (withdrawal.status === 'completed' || withdrawal.processed === true) {
                completedCount++;
                totalPaid += parseFloat(withdrawal.amount || 0);
            } else if (withdrawal.status === 'pending') {
                pendingCount++;
            }
        }
        
        return {
            success: true,
            data: {
                completedCount: completedCount,
                totalPaid: totalPaid.toFixed(4),
                pendingCount: pendingCount,
                totalWithdrawals: Object.keys(withdrawalsData).length
            }
        };
    } catch (error) {
        console.error('Get withdrawal stats error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_WITHDRAWAL_STATS_ERROR'
        };
    }
}

async function handleGetReferredUsers(env, userId) {
    try {
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        const referredUsers = userData.referredUsers || [];
        
        const referredUsersData = [];
        
        for (const referredUserId of referredUsers) {
            const referredUserResult = await handleDbGet(env, `users/${referredUserId}`);
            if (referredUserResult.success && referredUserResult.data) {
                referredUsersData.push({
                    userId: referredUserId,
                    name: referredUserResult.data.name || 'Anonymous User',
                    photoUrl: referredUserResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                    joinDate: referredUserResult.data.joinDate,
                    dogsBalance: referredUserResult.data.dogsBalance || 0
                });
            }
        }
        
        return {
            success: true,
            data: {
                referredUsers: referredUsersData
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_REFERRED_USERS_ERROR'
        };
    }
}

async function handleGetTasks(env, userId) {
    try {
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const tasksResult = await handleDbGet(env, 'tasks');
        const tasksData = tasksResult.data || {};
        
        const activeTasks = [];
        
        for (const [taskId, task] of Object.entries(tasksData)) {
            if (task.status === 'active' && (task.remaining === undefined || task.remaining > 0)) {
                activeTasks.push({
                    id: taskId,
                    ...task
                });
            }
        }
        
        return {
            success: true,
            data: {
                tasks: activeTasks
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_TASKS_ERROR'
        };
    }
}

async function handleVerifyTaskCompletion(env, userId, data) {
    try {
        const { taskId, reward, title } = data;
        
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        const taskResult = await handleDbGet(env, `tasks/${taskId}`);
        if (!taskResult.success || !taskResult.data) {
            return { 
                success: false, 
                error: 'Task not found',
                errorCode: 'TASK_NOT_FOUND'
            };
        }
        
        const task = taskResult.data;
        
        const completedTasks = userData.completedTasks || {};
        if (completedTasks[taskId]) {
            return { 
                success: false, 
                error: 'Task already completed',
                errorCode: 'TASK_ALREADY_COMPLETED'
            };
        }
        
        if (task.remaining !== undefined && task.remaining <= 0) {
            return { 
                success: false, 
                error: 'No rewards left for this task',
                errorCode: 'NO_TASK_REWARDS_LEFT'
            };
        }
        
        const rewardAmount = parseInt(reward);
        
        // التحقق من أن مكافأة المهمة تطابق القيمة المخزنة
        if (task.reward && rewardAmount !== task.reward) {
            return { 
                success: false, 
                error: `Invalid task reward: Expected ${task.reward}, got ${rewardAmount}`,
                errorCode: 'INVALID_TASK_REWARD'
            };
        }
        
        const newBalance = userData.dogsBalance + rewardAmount;
        
        const updates = {};
        if (task.remaining !== undefined) {
            updates.remaining = task.remaining - 1;
        }
        
        const userUpdates = {
            dogsBalance: newBalance
        };
        
        completedTasks[taskId] = true;
        userUpdates.completedTasks = completedTasks;
        
        await handleDbUpdate(env, `users/${userId}`, userUpdates);
        
        if (Object.keys(updates).length > 0) {
            await handleDbUpdate(env, `tasks/${taskId}`, updates);
        }
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: `Mission: ${title}`,
            amount: rewardAmount,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || userData;
        
        return {
            success: true,
            data: {
                newBalance: updatedUserData.dogsBalance
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_TASK_COMPLETION_ERROR'
        };
    }
}

async function handleReferral(env, userId, referrerId) {
    try {
        if (!referrerId || referrerId === userId) {
            return { 
                success: false, 
                error: 'Invalid referrer',
                errorCode: 'INVALID_REFERRER'
            };
        }
        
        // التحقق من حظر المستخدمين
        const userBlockCheck = await checkUserBlocked(env, userId);
        const referrerBlockCheck = await checkUserBlocked(env, referrerId);
        
        if ((userBlockCheck && userBlockCheck.isBlocked) || (referrerBlockCheck && referrerBlockCheck.isBlocked)) {
            return { 
                success: false, 
                error: 'Account blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    userBlocked: userBlockCheck ? userBlockCheck.isBlocked : false,
                    referrerBlocked: referrerBlockCheck ? referrerBlockCheck.isBlocked : false
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (userResult.success && userResult.data && userResult.data.referrer) {
            return { 
                success: false, 
                error: 'Already referred',
                errorCode: 'ALREADY_REFERRED'
            };
        }
        
        await handleDbUpdate(env, `users/${userId}`, { referrer: referrerId, joinDate: Date.now() });
        
        const referrerResult = await handleDbGet(env, `users/${referrerId}`);
        if (!referrerResult.success || !referrerResult.data) {
            return { 
                success: true, 
                data: { referred: true } 
            };
        }
        
        const referrerData = referrerResult.data;
        
        const referredUsers = referrerData.referredUsers || [];
        if (!referredUsers.includes(userId)) {
            referredUsers.push(userId);
        }
        
        const updates = {
            referredUsers: referredUsers,
            referrals: (referrerData.referrals || 0) + 1,
            dogsBalance: (referrerData.dogsBalance || 0) + 500
        };
        
        await handleDbUpdate(env, `users/${referrerId}`, updates);
        
        await handleDbPush(env, `users/${referrerId}/history`, {
            type: 'referral',
            description: 'Friend Invited',
            amount: 500,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        return {
            success: true,
            data: { referred: true }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'HANDLE_REFERRAL_ERROR'
        };
    }
}

async function handleAdClick(env, userId, adType, reward) {
    try {
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        const adCountField = `ads${adType.charAt(0).toUpperCase() + adType.slice(1)}`;
        const currentCount = userData[adCountField] || 0;
        
        const updates = {
            [adCountField]: currentCount + 1,
            adsWatched: (userData.adsWatched || 0) + 1,
            dogsBalance: (userData.dogsBalance || 0) + reward
        };
        
        await handleDbUpdate(env, `users/${userId}`, updates);
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'earn',
            description: `${adType} Ad Reward`,
            amount: reward,
            currency: 'GLX',
            date: new Date().toISOString()
        });
        
        // جلب بيانات المستخدم المحدثة
        const updatedUserResult = await handleDbGet(env, `users/${userId}`);
        const updatedUserData = updatedUserResult.data || { ...userData, ...updates };
        
        return {
            success: true,
            data: {
                [adCountField]: currentCount + 1,
                adsWatched: updates.adsWatched,
                newBalance: updatedUserData.dogsBalance
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'HANDLE_AD_CLICK_ERROR'
        };
    }
}

async function handleSubmitWithdrawal(env, userId, data) {
    try {
        const { method, account, amount, maskedAccount, memo } = data;
        
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const userData = userResult.data;
        
        if ((userData.tonBalance || 0) < amount) {
            return { 
                success: false, 
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON_BALANCE'
            };
        }
        
        const newBalance = (userData.tonBalance || 0) - amount;
        await handleDbUpdate(env, `users/${userId}`, { tonBalance: newBalance });
        
        const withdrawalId = `withdrawal_${Date.now()}`;
        const withdrawalData = {
            userId: userId,
            account: account,
            maskedAccount: maskedAccount || account,
            amount: amount,
            method: method,
            memo: memo || '',
            status: 'pending',
            timestamp: Date.now(),
            processed: false
        };
        
        await handleDbSet(env, `withdrawals/${withdrawalId}`, withdrawalData);
        
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'withdraw',
            description: `${method === 'ton' ? 'TON Wallet' : 'FaucetPay'} Withdrawal`,
            amount: amount,
            currency: 'TON',
            date: new Date().toISOString()
        });
        
        return {
            success: true,
            data: {
                newBalance: newBalance,
                withdrawalId: withdrawalId
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'SUBMIT_WITHDRAWAL_ERROR'
        };
    }
}

async function handleGetLeaderboard(env) {
    try {
        const usersResult = await handleDbGet(env, 'users');
        const usersData = usersResult.data || {};
        
        const users = [];
        
        for (const [userId, userData] of Object.entries(usersData)) {
            // تخطي المستخدمين المحظورين من المتصدرين
            if (userData.isBlocked) continue;
            
            users.push({
                userId: userId,
                name: userData.name || 'Anonymous',
                photoUrl: userData.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                dogsBalance: userData.dogsBalance || 0,
                referrals: userData.referrals || 0
            });
        }
        
        const byInvites = [...users].sort((a, b) => b.referrals - a.referrals);
        
        const byGLX = [...users].sort((a, b) => b.dogsBalance - a.dogsBalance);
        
        return {
            success: true,
            data: {
                byInvites: byInvites.slice(0, 50),
                byGLX: byGLX.slice(0, 50)
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_LEADERBOARD_ERROR'
        };
    }
}

// وظيفة جديدة: جلب بيانات المسابقة فقط
async function handleGetCompetitionData(env, userId = null) {
    try {
        // التحقق من الحظر إذا كان هناك معرف مستخدم
        if (userId) {
            const blockCheck = await checkUserBlocked(env, userId);
            if (blockCheck && blockCheck.isBlocked) {
                return { 
                    success: false, 
                    error: 'Your account has been blocked for violating system rules',
                    errorCode: 'ACCOUNT_BLOCKED',
                    data: { 
                        isBlocked: true,
                        blockDetails: blockCheck 
                    }
                };
            }
        }
        
        // أولاً: ضمان وجود مسابقة نشطة
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to load competition data',
                errorCode: 'COMPETITION_DATA_LOAD_ERROR'
            };
        }
        
        // جلب المتصدرين
        const userTickets = competitionData.userTickets || {};
        const leaderboard = [];
        
        for (const [uId, tickets] of Object.entries(userTickets)) {
            if (tickets > 0) {
                const userResult = await handleDbGet(env, `users/${uId}`);
                if (userResult.success && userResult.data) {
                    // تخطي المستخدمين المحظورين من المتصدرين
                    if (userResult.data.isBlocked) continue;
                    
                    leaderboard.push({
                        userId: uId,
                        name: userResult.data.name || 'Anonymous',
                        photoUrl: userResult.data.photoUrl || 'https://i.ibb.co/tTkJX1Qy/logo.png',
                        tickets: tickets
                    });
                }
            }
        }
        
        leaderboard.sort((a, b) => b.tickets - a.tickets);
        
        return {
            success: true,
            data: {
                competitionData: {
                    isActive: competitionData.isActive,
                    startTime: competitionData.startTime,
                    endTime: competitionData.endTime,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted,
                    isActiveNow: competitionData.isActiveNow
                },
                userTickets: userId ? competitionData.userTicketCount || 0 : 0,
                leaderboard: leaderboard.slice(0, 10)
            }
        };
    } catch (error) {
        console.error('Error getting competition data:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_COMPETITION_DATA_ERROR'
        };
    }
}

// وظيفة جديدة: جلب بيانات المستخدم المحدثة
async function handleGetUserData(env, userId) {
    try {
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        const userResult = await handleDbGet(env, `users/${userId}`);
        if (!userResult.success || !userResult.data) {
            return { 
                success: false, 
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        // جلب بيانات المسابقة الحالية للمستخدم
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to load competition data',
                errorCode: 'COMPETITION_DATA_LOAD_ERROR'
            };
        }
        
        // التأكد من تحديث حقل competitionTickets في بيانات المستخدم
        const currentUserTickets = competitionData.userTicketCount || 0;
        if (userResult.data.competitionTickets !== currentUserTickets) {
            await handleDbUpdate(env, `users/${userId}`, { 
                competitionTickets: currentUserTickets,
                lastTicketSync: Date.now()
            });
        }
        
        return {
            success: true,
            data: {
                userData: {
                    ...userResult.data,
                    competitionTickets: currentUserTickets
                },
                contest: {
                    yourTickets: currentUserTickets,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    isActive: competitionData.isActiveNow,
                    endTime: competitionData.endTime,
                    startTime: competitionData.startTime,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted
                }
            }
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_USER_DATA_ERROR'
        };
    }
}

// وظيفة جديدة: تحديث المسابقة يدويًا
async function handleRefreshCompetition(env) {
    try {
        const competitionData = await ensureAndGetCompetition(env);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to refresh competition',
                errorCode: 'REFRESH_COMPETITION_ERROR'
            };
        }
        
        return {
            success: true,
            data: {
                competitionData: {
                    isActive: competitionData.isActive,
                    startTime: competitionData.startTime,
                    endTime: competitionData.endTime,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    timeRemaining: competitionData.timeRemaining,
                    timeRemainingFormatted: competitionData.timeRemainingFormatted,
                    isActiveNow: competitionData.isActiveNow
                }
            }
        };
    } catch (error) {
        console.error('Error refreshing competition:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'REFRESH_COMPETITION_ERROR'
        };
    }
}

// وظيفة جديدة: مزامنة تذاكر المسابقة للمستخدم
async function handleSyncUserCompetitionTickets(env, userId) {
    try {
        // التحقق من الحظر
        const blockCheck = await checkUserBlocked(env, userId);
        if (blockCheck && blockCheck.isBlocked) {
            return { 
                success: false, 
                error: 'Your account has been blocked for violating system rules',
                errorCode: 'ACCOUNT_BLOCKED',
                data: { 
                    isBlocked: true,
                    blockDetails: blockCheck 
                }
            };
        }
        
        // جلب بيانات المسابقة الحالية
        const competitionData = await ensureAndGetCompetition(env, userId);
        
        if (!competitionData) {
            return {
                success: false,
                error: 'Failed to load competition data',
                errorCode: 'COMPETITION_DATA_LOAD_ERROR'
            };
        }
        
        const currentTickets = competitionData.userTicketCount || 0;
        
        // تحديث بيانات المستخدم
        await handleDbUpdate(env, `users/${userId}`, {
            competitionTickets: currentTickets,
            lastTicketSync: Date.now()
        });
        
        // جلب بيانات المستخدم المحدثة
        const userResult = await handleDbGet(env, `users/${userId}`);
        
        return {
            success: true,
            data: {
                competitionTickets: currentTickets,
                userData: userResult.data,
                contest: {
                    yourTickets: currentTickets,
                    totalTickets: competitionData.totalTickets || 0,
                    prizePool: competitionData.prizePool || 0,
                    isActive: competitionData.isActiveNow
                }
            }
        };
    } catch (error) {
        console.error('Error syncing user competition tickets:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'SYNC_USER_COMPETITION_TICKETS_ERROR'
        };
    }
}
