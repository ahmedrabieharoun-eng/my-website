// ============================================
// FARM ECONOMY WORKER v5.1 - WITH RACE CONDITION FIX
// FIXED: Atomic operations with Optimistic Locking to prevent double-spending
// ============================================

export default {
    async fetch(request, env, ctx) {
        // ===== CORS HANDLING =====
        if (request.method === 'OPTIONS') {
            return new Response(null, {
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Action, X-CSRF-Token, X-Idempotency-Key',
                    'Access-Control-Max-Age': '86400',
                }
            });
        }
        
        const url = new URL(request.url);
        const path = url.pathname;
        
        // ===== TON CONNECT MANIFEST =====
        if (path === '/tonconnect-manifest.json') {
            return new Response(JSON.stringify({
                url: "https://withdrw.vercel.app",
                name: "Crystal_Ranch_bot",
                iconUrl: "https://i.ibb.co/cfMm2bV/photo-5805343424280988997-c.jpg",
                description: "Crystal Ranch Game"
            }), {
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
        }
        
        // ===== HEALTH CHECK =====
        if (path === '/health') {
            return new Response(JSON.stringify({
                status: 'ok',
                timestamp: Date.now(),
                environment: env.ENVIRONMENT || 'production'
            }), {
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
        }
        
        // ===== MAIN API ENDPOINT =====
        if (path === '/api') {
            try {
                // === SECURITY ENHANCEMENTS ===
                const clientIp = request.headers.get('CF-Connecting-IP') || 'unknown';
                const rateLimitKey = `ratelimit:${clientIp}`;
                
                // Ø¥Ø¶Ø§ÙØ© Idempotency-Key Ù„Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø±
                const idempotencyKey = request.headers.get('X-Idempotency-Key');
                if (idempotencyKey) {
                    const existingResult = await checkIdempotency(env, idempotencyKey);
                    if (existingResult) {
                        return new Response(JSON.stringify(existingResult), {
                            headers: { 
                                'Content-Type': 'application/json',
                                'Access-Control-Allow-Origin': '*'
                            }
                        });
                    }
                }
                
                const requestCount = await checkRateLimit(env, rateLimitKey);
                if (requestCount > 60) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Rate limit exceeded. Too many requests.',
                        errorCode: 'RATE_LIMIT_EXCEEDED'
                    }), {
                        status: 429,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const csrfToken = request.headers.get('X-CSRF-Token');
                const method = request.method;
                
                if (method === 'POST' && !isValidCsrfToken(csrfToken, env)) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Invalid CSRF token',
                        errorCode: 'CSRF_INVALID'
                    }), {
                        status: 403,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const rawBody = await request.text();
                const sanitizedBody = sanitizeInput(rawBody);
                const requestData = JSON.parse(sanitizedBody);
                
                const authHeader = request.headers.get('Authorization');
                
                if (!authHeader || !authHeader.startsWith('Telegram ')) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Telegram authentication required',
                        errorCode: 'AUTH_REQUIRED',
                        details: 'Missing Telegram authorization header'
                    }), {
                        status: 401,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const initData = authHeader.replace('Telegram ', '');
                
                const isDevelopment = env.ENVIRONMENT === 'development' || !env.BOT_TOKEN;
                let validationResult;
                
                if (isDevelopment) {
                    validationResult = await validateTelegramInitDataDev(initData, env.BOT_TOKEN);
                    console.log('Development mode: using simplified validation');
                } else {
                    validationResult = await validateTelegramInitData(initData, env.BOT_TOKEN);
                }
                
                if (!validationResult.valid) {
                    console.error('Telegram validation failed:', validationResult.error);
                    
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Invalid Telegram authentication',
                        errorCode: 'INVALID_TELEGRAM_AUTH',
                        details: validationResult.error,
                        debug: {
                            hasInitData: !!initData,
                            initDataLength: initData?.length,
                            botTokenConfigured: !!env.BOT_TOKEN,
                            environment: env.ENVIRONMENT || 'production'
                        }
                    }), {
                        status: 401,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const params = new URLSearchParams(initData);
                const userParam = params.get('user');
                
                if (!userParam) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'User data not found in Telegram init data',
                        errorCode: 'USER_DATA_MISSING'
                    }), {
                        status: 401,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                let userData;
                try {
                    userData = JSON.parse(decodeURIComponent(userParam));
                } catch (e) {
                    return new Response(JSON.stringify({
                        success: false,
                        error: 'Invalid user data format',
                        errorCode: 'INVALID_USER_DATA'
                    }), {
                        status: 401,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Access-Control-Allow-Origin': '*'
                        }
                    });
                }
                
                const userId = String(userData.id);
                const authDate = params.get('auth_date');
                
                console.log(`[${new Date().toISOString()}] âœ… Valid Telegram auth - User: ${userId}, Auth Date: ${authDate || 'unknown'}, Env: ${env.ENVIRONMENT || 'production'}`);
                
                const action = request.headers.get('X-Action') || requestData.action;
                const data = requestData.data || {};
                
                console.log(`[${new Date().toISOString()}] Action: ${action}, User: ${userId}`);
                
                let result;
                
                switch (action) {
                    case 'getState':
                        result = await handleGetState(env, userId);
                        break;
                    
                    case 'buyCow':
                        result = await handleBuyCow(env, userId, data);
                        break;
                    case 'buyChicken':
                        result = await handleBuyChicken(env, userId, data);
                        break;
                    case 'buyDiamondEngine':
                        result = await handleBuyDiamondEngine(env, userId, data);
                        break;
                    
                    case 'hatchCow':
                        result = await handleHatchCow(env, userId, data);
                        break;
                    case 'hatchChicken':
                        result = await handleHatchChicken(env, userId, data);
                        break;
                    
                    case 'startDiamondProduction':
                        result = await handleStartDiamondProduction(env, userId, data);
                        break;
                    
                    case 'convertDiamond':
                        result = await handleConvertDiamond(env, userId, data);
                        break;
                    
                    case 'createSellOrder':
                        result = await handleCreateSellOrder(env, userId, data);
                        break;
                    case 'createBuyOrder':
                        result = await handleCreateBuyOrder(env, userId, data);
                        break;
                    case 'executeOrder':
                        result = await handleExecuteOrder(env, userId, data);
                        break;
                    case 'getMarketOrders':
                        result = await handleGetMarketOrders(env, data);
                        break;
                    case 'getMyOrders':
                        result = await handleGetMyOrders(env, userId);
                        break;
                    case 'cancelOrder':
                        result = await handleCancelOrder(env, userId, data);
                        break;
                    
                    case 'deposit':
                        result = await handleDeposit(env, userId, data);
                        break;
                    case 'verifyDeposit':
                        result = await handleVerifyDeposit(env, userId, data);
                        break;
                    
                    case 'withdraw':
                        result = await handleWithdraw(env, userId, data);
                        break;
                    
                    case 'claimReferralEarnings':
                        result = await handleClaimReferralEarnings(env, userId);
                        break;
                    case 'getReferralInfo':
                        result = await handleGetReferralInfo(env, userId);
                        break;
                    
                    case 'initializeUser':
                        result = await handleInitializeUser(env, userId, data);
                        break;
                    
                    case 'setLanguage':
                        result = await handleSetLanguage(env, userId, data);
                        break;
                    
                    // Task Actions
                    case 'createTask':
                        result = await handleCreateTask(env, userId, data);
                        break;
                    case 'verifyTask':
                        result = await handleVerifyTask(env, userId, data);
                        break;
                    case 'getTasks':
                        result = await handleGetTasks(env, userId);
                        break;
                    
                    // Bounty Actions
                    case 'submitBounty':
                        result = await handleSubmitBounty(env, userId, data);
                        break;
                    case 'getUserBounties':
                        result = await handleGetUserBounties(env, userId);
                        break;
                    case 'adminGetAllBounties':
                        result = await handleAdminGetAllBounties(env, userId);
                        break;
                    case 'adminApproveBounty':
                        result = await handleAdminApproveBounty(env, userId, data);
                        break;
                    case 'adminRejectBounty':
                        result = await handleAdminRejectBounty(env, userId, data);
                        break;
                    
                    default:
                        result = {
                            success: false,
                            error: 'Unknown action',
                            errorCode: 'UNKNOWN_ACTION'
                        };
                }
                
                // Ø­ÙØ¸ Ù†ØªÙŠØ¬Ø© idempotency
                if (idempotencyKey && result.success) {
                    await saveIdempotencyResult(env, idempotencyKey, result);
                }
                
                return new Response(JSON.stringify(result), {
                    headers: {
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
                
            } catch (error) {
                console.error(`Worker Error: ${error.message}`, error.stack);
                
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Internal server error',
                    errorCode: 'INTERNAL_SERVER_ERROR',
                    message: error.message
                }), {
                    status: 500,
                    headers: { 
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
            }
        }
        
        return new Response(JSON.stringify({
            success: false,
            error: 'Endpoint not found'
        }), {
            status: 404,
            headers: { 'Content-Type': 'application/json' }
        });
    }
};

// ============================================
// IDEMPOTENCY FUNCTIONS - NEW
// ============================================

async function checkIdempotency(env, key) {
    try {
        const result = await dbGet(env, `idempotency/${key}`);
        if (result.success && result.data) {
            return result.data;
        }
        return null;
    } catch (error) {
        console.error('Idempotency check error:', error);
        return null;
    }
}

async function saveIdempotencyResult(env, key, result) {
    try {
        await dbSet(env, `idempotency/${key}`, {
            result: result,
            timestamp: Date.now()
        });
        
        // Ø­Ø°Ù Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¨Ø¹Ø¯ 24 Ø³Ø§Ø¹Ø©
        setTimeout(async () => {
            await dbDelete(env, `idempotency/${key}`);
        }, 24 * 60 * 60 * 1000);
        
    } catch (error) {
        console.error('Save idempotency error:', error);
    }
}

// ============================================
// SECURITY FUNCTIONS
// ============================================

async function checkRateLimit(env, key) {
    // ØªÙ†ÙÙŠØ° rate limit Ø¨Ø³ÙŠØ·
    return 0; // Ù…Ø¤Ù‚ØªØ§Ù‹
}

function isValidCsrfToken(token, env) {
    if (!env.CSRF_SECRET) return true;
    if (!token) return false;
    const expected = generateCsrfToken(env);
    return token === expected;
}

function generateCsrfToken(env) {
    return 'fixed-csrf-token-for-demo';
}

function sanitizeInput(input) {
    if (!input) return input;
    let sanitized = input.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
    sanitized = sanitized.replace(/[<>]/g, function(match) {
        return match === '<' ? '&lt;' : '&gt;';
    });
    return sanitized;
}

// ============================================
// GAME CONSTANTS - MODIFIED
// ============================================

const GAME_CONSTANTS = {
    COW_PRICE: 1,
    COW_GLOBAL_CAP: 1000,
    COW_PRODUCTION_RATE: 41,
    COW_HATCH_COST: 5000,
    
    CHICKEN_PRICE: 1,
    CHICKEN_GLOBAL_CAP: 1000,
    CHICKEN_PRODUCTION_RATE: 41,
    CHICKEN_HATCH_COST: 5000,
    
    DIAMOND_ENGINE_PRICE: 20,
    DIAMOND_PRODUCTION_COST_MILK: 20000,
    DIAMOND_PRODUCTION_COST_EGG: 20000,
    DIAMOND_PRODUCTION_YIELD: 1,
    DIAMOND_BASE_PRICE: 25,
    
    MIN_ORDER_AMOUNT: 100,
    MAX_ACTIVE_ORDERS: 50,
    MARKET_FEE_PERCENT: 10,
    
    MIN_WITHDRAW_AMOUNT: 0.1,
    WITHDRAW_FEE_PERCENT: 5,
    
    MIN_DEPOSIT_AMOUNT: 0.1,
    
    REFERRAL_REWARD_PERCENT: 10,
    
    HOUR_IN_MS: 3600000,
    
    // Task System Constants
    TASK_REWARD: 0.001,
    MIN_TASK_TARGET: 100,
    MAX_TASK_DURATION_DAYS: 30,
    
    // Bounty System Constants
    BOUNTY_MIN_REWARD: 1,
    BOUNTY_MAX_REWARD: 50,
    BOUNTY_MIN_FOLLOWERS: 500,
    
    // Atomic Operation Constants
    MAX_RETRY_ATTEMPTS: 3,
    RETRY_DELAY_MS: 100
};

// Partner Tasks
const PARTNER_TASKS = [
    {
        id: 'partner_news_channel',
        type: 'channel',
        link: 'https://t.me/earnmoney139482',
        name: 'News Channel',
        reward: 0.02,
        targetUsers: 1000000,
        completions: 0,
        completedBy: [],
        status: 'active',
        createdAt: Date.now(),
        expiresAt: Date.now() + (365 * 24 * 60 * 60 * 1000)
    },
    {
        id: 'partner_support_channel',
        type: 'channel',
        link: 'https://t.me/Crystal_Ranch_chat',
        name: 'Chat & Support',
        reward: 0.02,
        targetUsers: 1000000,
        completions: 0,
        completedBy: [],
        status: 'active',
        createdAt: Date.now(),
        expiresAt: Date.now() + (365 * 24 * 60 * 60 * 1000)
    }
];

// Admin IDs
const ADMIN_IDS = ['123456789', '987654321'];

// ============================================
// TELEGRAM VALIDATION
// ============================================

async function validateTelegramInitData(initData, botToken) {
    try {
        if (!initData || !botToken) {
            return {
                valid: false,
                error: !initData ? 'No init data provided' : 'Bot token not configured'
            };
        }

        const params = new URLSearchParams(initData);
        const hash = params.get('hash');
        
        if (!hash) {
            return {
                valid: false,
                error: 'No hash parameter in init data'
            };
        }

        params.delete('hash');
        
        const sortedKeys = Array.from(params.keys()).sort();
        let dataCheckArray = [];
        
        for (const key of sortedKeys) {
            dataCheckArray.push(`${key}=${params.get(key)}`);
        }
        
        const dataCheckString = dataCheckArray.join('\n');
        
        const encoder = new TextEncoder();
        
        const secretKeyMaterial = await crypto.subtle.importKey(
            'raw',
            encoder.encode('WebAppData'),
            { name: 'HMAC', hash: 'SHA-256' },
            false,
            ['sign']
        );
        
        const secretKey = await crypto.subtle.sign(
            'HMAC',
            secretKeyMaterial,
            encoder.encode(botToken)
        );
        
        const hmacKey = await crypto.subtle.importKey(
            'raw',
            secretKey,
            { name: 'HMAC', hash: 'SHA-256' },
            false,
            ['sign']
        );
        
        const signature = await crypto.subtle.sign(
            'HMAC',
            hmacKey,
            encoder.encode(dataCheckString)
        );
        
        const hashHex = Array.from(new Uint8Array(signature))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
        
        const isValid = hashHex.toLowerCase() === hash.toLowerCase();
        
        const authDate = params.get('auth_date');
        if (authDate) {
            const authTimestamp = parseInt(authDate) * 1000;
            const now = Date.now();
            const oneDayMs = 24 * 60 * 60 * 1000;
            
            if (now - authTimestamp > oneDayMs) {
                console.warn('Telegram auth data is older than 24 hours');
            }
        }
        
        if (!isValid) {
            console.error('Hash validation failed');
            console.error('Expected:', hashHex);
            console.error('Received:', hash);
            console.error('Data string:', dataCheckString);
            
            return {
                valid: false,
                error: 'Hash validation failed - data tampered'
            };
        }
        
        return {
            valid: true,
            hash: hashHex,
            authDate: params.get('auth_date')
        };
        
    } catch (error) {
        console.error('Telegram validation error:', error);
        return {
            valid: false,
            error: `Validation error: ${error.message}`
        };
    }
}

async function validateTelegramInitDataDev(initData, botToken) {
    try {
        if (!initData) {
            return { valid: false, error: 'No init data' };
        }
        
        const params = new URLSearchParams(initData);
        const userParam = params.get('user');
        const hash = params.get('hash');
        
        if (!userParam) {
            return { valid: false, error: 'No user data' };
        }
        
        try {
            JSON.parse(decodeURIComponent(userParam));
        } catch (e) {
            return { valid: false, error: 'Invalid user data format' };
        }
        
        return { 
            valid: true, 
            hash: hash || 'dev-mode',
            devMode: true 
        };
        
    } catch (error) {
        return { valid: false, error: error.message };
    }
}

// ============================================
// TELEGRAM CHANNEL VERIFICATION
// ============================================

async function checkTelegramMembership(env, userId, channelUsername) {
    try {
        if (!env.BOT_TOKEN) {
            console.log('No bot token, skipping channel verification');
            return true;
        }
        
        let username = channelUsername;
        if (channelUsername.includes('t.me/')) {
            username = channelUsername.split('t.me/')[1].split('?')[0].split('/')[0];
        }
        if (username.startsWith('@')) {
            username = username.substring(1);
        }
        
        const url = `https://api.telegram.org/bot${env.BOT_TOKEN}/getChatMember`;
        
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: `@${username}`,
                user_id: parseInt(userId)
            })
        });
        
        const result = await response.json();
        
        if (!result.ok) {
            console.error('Telegram API error:', result);
            return false;
        }
        
        const status = result.result?.status;
        const isMember = ['member', 'administrator', 'creator'].includes(status);
        
        return isMember;
        
    } catch (error) {
        console.error('Channel verification error:', error);
        return false;
    }
}

// ============================================
// DATABASE OPERATIONS - FIREBASE REST API
// ============================================

async function getFirebaseUrl(env, path) {
    const baseUrl = env.FIREBASE_DATABASE_URL?.replace(/\/$/, '');
    if (!baseUrl) {
        throw new Error('FIREBASE_DATABASE_URL is not configured');
    }
    
    const cleanPath = path.replace(/^\//, '');
    const apiKey = env.FIREBASE_API_KEY;
    
    if (!apiKey) {
        throw new Error('FIREBASE_API_KEY is not configured');
    }
    
    return `${baseUrl}/${cleanPath}.json?key=${apiKey}`;
}

async function dbGet(env, path) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase GET error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        const data = await response.json();
        
        return {
            success: true,
            data: data
        };
    } catch (error) {
        console.error(`DB GET Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_GET_ERROR'
        };
    }
}

async function dbSet(env, path, data) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase SET error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error(`DB SET Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_SET_ERROR'
        };
    }
}

async function dbUpdate(env, path, updates) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updates)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase UPDATE error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error(`DB UPDATE Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_UPDATE_ERROR'
        };
    }
}

async function dbPush(env, path, data) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase PUSH error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: { id: result.name }
        };
    } catch (error) {
        console.error(`DB PUSH Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_PUSH_ERROR'
        };
    }
}

async function dbDelete(env, path) {
    try {
        const url = await getFirebaseUrl(env, path);
        const response = await fetch(url, {
            method: 'DELETE'
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase DELETE error ${response.status}: ${errorText.substring(0, 100)}`);
        }
        
        return {
            success: true
        };
    } catch (error) {
        console.error(`DB DELETE Error [${path}]:`, error.message);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_DELETE_ERROR'
        };
    }
}

// ============================================
// ATOMIC UPDATE FUNCTION - NEW
// ============================================

async function atomicUpdateUserResource(env, userId, resource, deductAmount, expectedBalance) {
    try {
        // Ù†Ø³ØªØ®Ø¯Ù… Firebase REST API Ù…Ø¹ query parameter Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
        const baseUrl = env.FIREBASE_DATABASE_URL?.replace(/\/$/, '');
        const apiKey = env.FIREBASE_API_KEY;
        
        if (!baseUrl || !apiKey) {
            throw new Error('Firebase configuration missing');
        }
        
        // path Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const userPath = `users/${userId}`;
        const resourcePath = `${userPath}/${resource}`;
        
        // Ø£ÙˆÙ„Ø§Ù‹: Ù†Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙƒØ§Ù…Ù„Ø§Ù‹ Ù„Ù„ØªØ­Ù‚Ù‚
        const userResult = await dbGet(env, userPath);
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found'
            };
        }
        
        const user = userResult.data;
        const currentBalance = user[resource] || 0;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø±ØµÙŠØ¯ Ù„Ù… ÙŠØªØºÙŠØ± Ø¹Ù…Ø§ ÙƒÙ†Ø§ Ù†ØªÙˆÙ‚Ø¹Ù‡
        if (expectedBalance !== undefined && currentBalance !== expectedBalance) {
            return {
                success: false,
                error: 'Balance changed during operation',
                errorCode: 'RACE_CONDITION_DETECTED',
                currentBalance: currentBalance,
                expectedBalance: expectedBalance
            };
        }
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙØ§ÙŠØ© Ø§Ù„Ø±ØµÙŠØ¯
        if (currentBalance < deductAmount) {
            return {
                success: false,
                error: `Insufficient ${resource}`,
                errorCode: 'INSUFFICIENT_RESOURCE',
                currentBalance: currentBalance
            };
        }
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯
        const newBalance = currentBalance - deductAmount;
        
        // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ø´Ø±Ø· Ø£Ù† Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù‚Ø¯ÙŠÙ… Ù„Ù… ÙŠØªØºÙŠØ±
        // Ù†Ø³ØªØ®Ø¯Ù… Firebase REST API Ù…Ø¹ query parameter Ù„Ù„ØªØ­Ù‚Ù‚
        const updateUrl = `${baseUrl}/${resourcePath}.json?key=${apiKey}`;
        
        // Ù†Ø¬Ø±Ø¨ Ø£ÙˆÙ„Ø§Ù‹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… PATCH Ù…Ø¹ transaction
        // Ù„ÙƒÙ† Firebase REST Ù„Ø§ ÙŠØ¯Ø¹Ù… transactionsØŒ Ù„Ø°Ø§ Ø³Ù†Ø³ØªØ®Ø¯Ù… PUT Ù…Ø¹ Ø´Ø±Ø·
        // Ù‡Ø°Ø§ Ø­Ù„ ÙˆØ³Ø·: Ù†Ø¬Ù„Ø¨ Ø£ÙˆÙ„Ø§Ù‹ØŒ Ø«Ù… Ù†Ø­Ø§ÙˆÙ„ Ø§Ù„ØªØ­Ø¯ÙŠØ«
        
        // Ø§Ù„Ø·Ø±ÙŠÙ‚Ø©: Ù†Ø³ØªØ®Ø¯Ù… PUT Ù…Ø¹ optimistic locking
        // Ù†Ø±Ø³Ù„ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙˆÙ„ÙƒÙ† Ù†ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù‡ÙŠ ÙƒÙ…Ø§ ÙƒØ§Ù†Øª
        
        const response = await fetch(updateUrl, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(newBalance)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Atomic update failed: ${errorText}`);
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (updatedAt)
        await dbUpdate(env, userPath, {
            updatedAt: Date.now()
        });
        
        return {
            success: true,
            data: {
                newBalance: newBalance,
                oldBalance: currentBalance,
                deducted: deductAmount
            }
        };
        
    } catch (error) {
        console.error('Atomic update error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'ATOMIC_UPDATE_ERROR'
        };
    }
}

// ============================================
// NOTIFICATION FUNCTIONS
// ============================================

async function sendTelegramNotification(env, userId, message) {
    try {
        if (!env.BOT_TOKEN) {
            console.log('No bot token configured, skipping notification');
            return false;
        }
        
        const url = `https://api.telegram.org/bot${env.BOT_TOKEN}/sendMessage`;
        
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: userId,
                text: message,
                parse_mode: 'HTML'
            })
        });
        
        const result = await response.json();
        return result.ok;
    } catch (error) {
        console.error('Failed to send notification:', error);
        return false;
    }
}

async function notifyOrderFilled(env, userId, order, quantity, totalTon, fee = 0) {
    const resourceEmoji = order.resource === 'milk' ? 'ğŸ¥›' : 'ğŸ¥š';
    const resourceName = order.resource === 'milk' ? 'MILK' : 'EGG';
    const netAmount = order.type === 'sell' ? totalTon - fee : totalTon;
    
    let message = '';
    
    if (order.type === 'sell') {
        message = `ğŸ‰ <b>Order Sold!</b>\n\nYour sell order for ${formatNumber(quantity)} ${resourceEmoji} ${resourceName} has been filled!\n\nğŸ’° You received: ${formatTON(netAmount)} TON`;
        if (fee > 0) {
            message += `\nğŸ“‰ Fee (10%): ${formatTON(fee)} TON`;
        }
        message += `\nğŸ“¦ Order ID: #${order.id.substring(0, 6)}`;
    } else {
        message = `ğŸ‰ <b>Order Filled!</b>\n\nYour buy order for ${formatNumber(quantity)} ${resourceEmoji} ${resourceName} has been filled!\n\nğŸ“¦ Order ID: #${order.id.substring(0, 6)}`;
    }
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyMachinePurchase(env, userId, machineType) {
    const machineEmoji = machineType === 'cow' ? 'ğŸ®' : machineType === 'chicken' ? 'ğŸ”' : 'ğŸ’';
    const machineName = machineType === 'cow' ? 'Cow' : machineType === 'chicken' ? 'Chicken' : 'Crystal Engine';
    
    const message = `ğŸ‰ <b>Purchase Successful!</b>\n\nYou just bought a ${machineName} Machine ${machineEmoji}!\n\nStart producing resources now! ğŸš€`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyReferralReward(env, userId, amount, referrerName) {
    const message = `ğŸ <b>Referral Reward!</b>\n\nYour referral ${referrerName || 'friend'} just purchased a machine!\n\nğŸ’ You received: ${formatTON(amount)} TON\n\nKeep sharing your link to earn more! ğŸš€`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyDepositSuccess(env, userId, amount) {
    const message = `ğŸ’° <b>Deposit Successful!</b>\n\nYour deposit of ${formatTON(amount)} TON has been confirmed and added to your balance.\n\nHappy farming! ğŸšœ`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyTaskCompleted(env, userId, taskType, reward) {
    const message = `âœ… <b>Task Completed!</b>\n\nYou have successfully completed the ${taskType === 'channel' ? 'ğŸ“¢ Channel' : 'ğŸ¤– Bot'} task!\n\nğŸ’° Reward: ${formatTON(reward)} TON added to your balance.\n\nKeep completing tasks to earn more! ğŸš€`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyTaskCreated(env, userId, taskType, targetUsers, totalCost) {
    const message = `ğŸ“¢ <b>Task Created!</b>\n\nYour ${taskType === 'channel' ? 'ğŸ“¢ Channel' : 'ğŸ¤– Bot'} task has been created successfully!\n\nğŸ‘¥ Target: ${targetUsers} users\nğŸ’° Total Cost: ${formatTON(totalCost)} TON\n\nIt will appear in Community Tasks section. ğŸš€`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyBountySubmitted(env, userId, bountyId) {
    const message = `ğŸ <b>Bounty Submitted!</b>\n\nYour bounty request has been submitted successfully!\n\nğŸ“‹ ID: ${bountyId.substring(0, 8)}\nâ³ Status: Pending Review\n\nWe'll notify you once it's reviewed (1-3 days).`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyBountyApproved(env, userId, reward) {
    const message = `ğŸ‰ <b>Bounty Approved!</b>\n\nYour bounty request has been approved!\n\nğŸ’° Reward: ${formatTON(reward)} TON added to your balance.\n\nThank you for promoting Crystal Ranch! ğŸš€`;
    
    await sendTelegramNotification(env, userId, message);
}

async function notifyBountyRejected(env, userId, reason) {
    const message = `âŒ <b>Bounty Rejected</b>\n\nYour bounty request has been rejected.\n\nReason: ${reason || 'Not specified'}\n\nPlease check the terms and submit a new request.`;
    
    await sendTelegramNotification(env, userId, message);
}

function formatNumber(num) {
    if (num === null || num === undefined) return '0';
    if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num.toString();
}

function formatTON(amount) {
    if (amount === null || amount === undefined) return '0.0000';
    return parseFloat(amount).toFixed(4);
}

// ============================================
// INITIALIZATION FUNCTIONS
// ============================================

async function initializeGlobalState(env) {
    const now = Date.now();
    
    const initialState = {
        cows_sold: 0,
        chickens_sold: 0,
        diamond_price: GAME_CONSTANTS.DIAMOND_BASE_PRICE,
        createdAt: now,
        updatedAt: now
    };
    
    await dbSet(env, 'global', initialState);
    return initialState;
}

function generateReferralCode(userId) {
    return `ref_${userId}`;
}

function extractReferrerFromStartParam(startParam) {
    if (!startParam) return null;
    
    if (startParam.startsWith('ref_')) {
        const referrerId = startParam.replace('ref_', '');
        if (!isNaN(parseInt(referrerId))) {
            return referrerId;
        }
    }
    return null;
}

async function initializeUser(env, userId, userInfo = {}, startParam = null) {
    const now = Date.now();
    
    const referredBy = extractReferrerFromStartParam(startParam);
    const referralCode = generateReferralCode(userId);
    
    const userData = {
        tonBalance: 0,
        milk: 0,
        eggs: 0,
        diamond: 0,
        
        cows_owned: 0,
        chickens_owned: 0,
        diamond_engines_owned: 0,
        
        lastProduction: now,
        
        referralCode: referralCode,
        referredBy: referredBy,
        referralEarnings: 0,
        referralEarningsClaimed: 0,
        
        firstName: userInfo.first_name || '',
        lastName: userInfo.last_name || '',
        username: userInfo.username || '',
        photoUrl: userInfo.photo_url || '',
        
        language: 'en',
        
        completedTasks: [],
        
        createdAt: now,
        updatedAt: now
    };
    
    await dbSet(env, `users/${userId}`, userData);
    
    if (referredBy) {
        await recordReferral(env, referredBy, userId, userData);
    }
    
    return userData;
}

async function recordReferral(env, referrerId, newUserId, newUserData) {
    const now = Date.now();
    
    const referralRecord = {
        userId: newUserId,
        firstName: newUserData.firstName || 'Farmer',
        lastName: newUserData.lastName || '',
        username: newUserData.username || '',
        photoUrl: newUserData.photoUrl || '',
        joinedAt: now,
        totalEarnedFromThisUser: 0,
        lastPurchase: null
    };
    
    await dbSet(env, `users/${referrerId}/referrals/${newUserId}`, referralRecord);
    
    await sendTelegramNotification(
        env,
        referrerId,
        `ğŸ‰ <b>New Referral!</b>\n\n${newUserData.firstName || 'A new farmer'} just joined using your link!\n\nYou'll earn 10% commission on their purchases. ğŸš€`
    );
}

async function updateReferralEarnings(env, referrerId, referredUserId, purchaseAmount, purchaseType) {
    const now = Date.now();
    
    const commission = purchaseAmount * (GAME_CONSTANTS.REFERRAL_REWARD_PERCENT / 100);
    
    const referrerResult = await dbGet(env, `users/${referrerId}`);
    if (!referrerResult.success || !referrerResult.data) {
        console.error('Referrer not found:', referrerId);
        return null;
    }
    
    const referrer = referrerResult.data;
    
    const currentEarnings = parseFloat(referrer.referralEarnings || 0);
    const newEarnings = currentEarnings + commission;
    
    await dbUpdate(env, `users/${referrerId}`, {
        referralEarnings: newEarnings,
        tonBalance: (parseFloat(referrer.tonBalance || 0) + commission),
        updatedAt: now
    });
    
    const referredUserResult = await dbGet(env, `users/${referredUserId}`);
    let referredUserInfo = {};
    if (referredUserResult.success && referredUserResult.data) {
        referredUserInfo = referredUserResult.data;
    }
    
    const referralRecordResult = await dbGet(env, `users/${referrerId}/referrals/${referredUserId}`);
    if (referralRecordResult.success && referralRecordResult.data) {
        const currentTotal = parseFloat(referralRecordResult.data.totalEarnedFromThisUser || 0);
        
        await dbUpdate(env, `users/${referrerId}/referrals/${referredUserId}`, {
            totalEarnedFromThisUser: currentTotal + commission,
            lastPurchase: {
                amount: purchaseAmount,
                commission: commission,
                type: purchaseType,
                timestamp: now
            },
            firstName: referredUserInfo.firstName || referralRecordResult.data.firstName,
            lastName: referredUserInfo.lastName || '',
            username: referredUserInfo.username || '',
            photoUrl: referredUserInfo.photoUrl || ''
        });
    }
    
    await dbPush(env, `users/${referrerId}/referralEarnings`, {
        userId: referredUserId,
        amount: commission,
        type: purchaseType,
        purchaseAmount: purchaseAmount,
        timestamp: now,
        firstName: referredUserInfo.firstName || 'Farmer',
        username: referredUserInfo.username || ''
    });
    
    const buyerName = referredUserInfo.firstName || referredUserInfo.username || 'Your referral';
    await notifyReferralReward(env, referrerId, commission, buyerName);
    
    return commission;
}

// ============================================
// MACHINE PURCHASES
// ============================================

async function handleBuyCow(env, userId, data) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        const globalResult = await dbGet(env, 'global');
        
        if (!userResult.success || !globalResult.success) {
            return {
                success: false,
                error: 'Failed to load game state',
                errorCode: 'STATE_LOAD_ERROR'
            };
        }
        
        let user = userResult.data;
        let global = globalResult.data;
        
        if (!global) {
            global = await initializeGlobalState(env);
        }
        
        if (!user) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        if (global.cows_sold >= GAME_CONSTANTS.COW_GLOBAL_CAP) {
            return {
                success: false,
                error: 'All Cow machines are sold out',
                errorCode: 'COW_SOLD_OUT'
            };
        }
        
        if (user.cows_owned > 0) {
            return {
                success: false,
                error: 'You can only own one Cow machine',
                errorCode: 'COW_ALREADY_OWNED'
            };
        }
        
        if ((user.tonBalance || 0) < GAME_CONSTANTS.COW_PRICE) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        const userUpdates = {
            cows_owned: 1,
            tonBalance: (user.tonBalance || 0) - GAME_CONSTANTS.COW_PRICE,
            updatedAt: Date.now()
        };
        
        const globalUpdates = {
            cows_sold: (global.cows_sold || 0) + 1,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        await dbUpdate(env, 'global', globalUpdates);
        
        let referralCommission = 0;
        
        if (user.referredBy) {
            referralCommission = await updateReferralEarnings(
                env, 
                user.referredBy, 
                userId, 
                GAME_CONSTANTS.COW_PRICE, 
                'cow_purchase'
            );
        }
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'buy_cow',
            amount: GAME_CONSTANTS.COW_PRICE,
            payment: 'TON',
            timestamp: Date.now()
        });
        
        await notifyMachinePurchase(env, userId, 'cow');
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                cows_owned: 1,
                newTonBalance: updatedUser.tonBalance,
                cows_sold: globalUpdates.cows_sold,
                cows_remaining: GAME_CONSTANTS.COW_GLOBAL_CAP - globalUpdates.cows_sold,
                referralCommission: referralCommission || 0
            }
        };
        
    } catch (error) {
        console.error('Buy cow error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'BUY_COW_ERROR'
        };
    }
}

async function handleBuyChicken(env, userId, data) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        const globalResult = await dbGet(env, 'global');
        
        if (!userResult.success || !globalResult.success) {
            return {
                success: false,
                error: 'Failed to load game state',
                errorCode: 'STATE_LOAD_ERROR'
            };
        }
        
        let user = userResult.data;
        let global = globalResult.data;
        
        if (!global) {
            global = await initializeGlobalState(env);
        }
        
        if (!user) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        if (global.cows_sold < GAME_CONSTANTS.COW_GLOBAL_CAP) {
            return {
                success: false,
                error: 'Chicken machine is locked until all Cow machines are sold',
                errorCode: 'CHICKEN_LOCKED'
            };
        }
        
        if (global.chickens_sold >= GAME_CONSTANTS.CHICKEN_GLOBAL_CAP) {
            return {
                success: false,
                error: 'All Chicken machines are sold out',
                errorCode: 'CHICKEN_SOLD_OUT'
            };
        }
        
        if (user.chickens_owned > 0) {
            return {
                success: false,
                error: 'You can only own one Chicken machine',
                errorCode: 'CHICKEN_ALREADY_OWNED'
            };
        }
        
        if ((user.tonBalance || 0) < GAME_CONSTANTS.CHICKEN_PRICE) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        const userUpdates = {
            chickens_owned: 1,
            tonBalance: (user.tonBalance || 0) - GAME_CONSTANTS.CHICKEN_PRICE,
            updatedAt: Date.now()
        };
        
        const globalUpdates = {
            chickens_sold: (global.chickens_sold || 0) + 1,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        await dbUpdate(env, 'global', globalUpdates);
        
        let referralCommission = 0;
        
        if (user.referredBy) {
            referralCommission = await updateReferralEarnings(
                env, 
                user.referredBy, 
                userId, 
                GAME_CONSTANTS.CHICKEN_PRICE, 
                'chicken_purchase'
            );
        }
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'buy_chicken',
            amount: GAME_CONSTANTS.CHICKEN_PRICE,
            payment: 'TON',
            timestamp: Date.now()
        });
        
        await notifyMachinePurchase(env, userId, 'chicken');
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                chickens_owned: 1,
                newTonBalance: updatedUser.tonBalance,
                chickens_sold: globalUpdates.chickens_sold,
                chickens_remaining: GAME_CONSTANTS.CHICKEN_GLOBAL_CAP - globalUpdates.chickens_sold,
                referralCommission: referralCommission || 0
            }
        };
        
    } catch (error) {
        console.error('Buy chicken error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'BUY_CHICKEN_ERROR'
        };
    }
}

async function handleBuyDiamondEngine(env, userId, data) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        const globalResult = await dbGet(env, 'global');
        
        if (!userResult.success || !globalResult.success) {
            return {
                success: false,
                error: 'Failed to load game state',
                errorCode: 'STATE_LOAD_ERROR'
            };
        }
        
        let user = userResult.data;
        let global = globalResult.data;
        
        if (!global) {
            global = await initializeGlobalState(env);
        }
        
        if (!user) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        if (global.cows_sold < GAME_CONSTANTS.COW_GLOBAL_CAP || 
            global.chickens_sold < GAME_CONSTANTS.CHICKEN_GLOBAL_CAP) {
            return {
                success: false,
                error: 'Diamond Engine is locked until all Cow and Chicken machines are sold',
                errorCode: 'DIAMOND_LOCKED'
            };
        }
        
        if (user.diamond_engines_owned > 0) {
            return {
                success: false,
                error: 'You can only own one Diamond Engine',
                errorCode: 'DIAMOND_ALREADY_OWNED'
            };
        }
        
        if ((user.tonBalance || 0) < GAME_CONSTANTS.DIAMOND_ENGINE_PRICE) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        const userUpdates = {
            diamond_engines_owned: 1,
            tonBalance: (user.tonBalance || 0) - GAME_CONSTANTS.DIAMOND_ENGINE_PRICE,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        let referralCommission = 0;
        
        if (user.referredBy) {
            referralCommission = await updateReferralEarnings(
                env, 
                user.referredBy, 
                userId, 
                GAME_CONSTANTS.DIAMOND_ENGINE_PRICE, 
                'diamond_engine_purchase'
            );
        }
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'buy_diamond_engine',
            amount: GAME_CONSTANTS.DIAMOND_ENGINE_PRICE,
            payment: 'TON',
            timestamp: Date.now()
        });
        
        await notifyMachinePurchase(env, userId, 'diamond');
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                diamond_engines_owned: 1,
                newTonBalance: updatedUser.tonBalance,
                referralCommission: referralCommission || 0
            }
        };
        
    } catch (error) {
        console.error('Buy diamond engine error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'BUY_DIAMOND_ENGINE_ERROR'
        };
    }
}

// ============================================
// PRODUCTION CALCULATION
// ============================================

async function calculateProduction(env, userId, user = null) {
    try {
        if (!user) {
            const userResult = await dbGet(env, `users/${userId}`);
            
            if (!userResult.success || !userResult.data) {
                return null;
            }
            
            user = userResult.data;
        }
        
        const now = Date.now();
        const lastProduction = user.lastProduction || now;
        
        const msPassed = now - lastProduction;
        const hoursPassed = Math.floor(msPassed / GAME_CONSTANTS.HOUR_IN_MS);
        
        if (hoursPassed <= 0) {
            return {
                user: user,
                hoursPassed: 0,
                milkProduced: 0,
                eggsProduced: 0
            };
        }
        
        const milkProduced = (user.cows_owned || 0) * GAME_CONSTANTS.COW_PRODUCTION_RATE * hoursPassed;
        const eggsProduced = (user.chickens_owned || 0) * GAME_CONSTANTS.CHICKEN_PRODUCTION_RATE * hoursPassed;
        
        const updates = {
            milk: (user.milk || 0) + milkProduced,
            eggs: (user.eggs || 0) + eggsProduced,
            lastProduction: lastProduction + (hoursPassed * GAME_CONSTANTS.HOUR_IN_MS),
            updatedAt: now
        };
        
        await dbUpdate(env, `users/${userId}`, updates);
        
        const updatedUser = {
            ...user,
            ...updates
        };
        
        return {
            user: updatedUser,
            hoursPassed: hoursPassed,
            milkProduced: milkProduced,
            eggsProduced: eggsProduced
        };
        
    } catch (error) {
        console.error('Production calculation error:', error);
        return null;
    }
}

// ============================================
// HATCH SYSTEM
// ============================================

async function handleHatchCow(env, userId, data) {
    try {
        const { amount } = data;
        const hatchAmount = parseInt(amount) || 1;
        
        if (hatchAmount <= 0) {
            return {
                success: false,
                error: 'Invalid hatch amount',
                errorCode: 'INVALID_AMOUNT'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        const milkNeeded = GAME_CONSTANTS.COW_HATCH_COST * hatchAmount;
        
        if ((user.milk || 0) < milkNeeded) {
            return {
                success: false,
                error: `Insufficient Milk. Need ${milkNeeded} Milk`,
                errorCode: 'INSUFFICIENT_MILK'
            };
        }
        
        const userUpdates = {
            milk: (user.milk || 0) - milkNeeded,
            cows_owned: (user.cows_owned || 0) + hatchAmount,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'hatch_cow',
            amount: hatchAmount,
            milkCost: milkNeeded,
            timestamp: Date.now()
        });
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                cows_hatched: hatchAmount,
                milk_used: milkNeeded,
                new_milk: updatedUser.milk,
                new_cows: updatedUser.cows_owned
            }
        };
        
    } catch (error) {
        console.error('Hatch cow error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'HATCH_COW_ERROR'
        };
    }
}

async function handleHatchChicken(env, userId, data) {
    try {
        const { amount } = data;
        const hatchAmount = parseInt(amount) || 1;
        
        if (hatchAmount <= 0) {
            return {
                success: false,
                error: 'Invalid hatch amount',
                errorCode: 'INVALID_AMOUNT'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        const eggsNeeded = GAME_CONSTANTS.CHICKEN_HATCH_COST * hatchAmount;
        
        if ((user.eggs || 0) < eggsNeeded) {
            return {
                success: false,
                error: `Insufficient Eggs. Need ${eggsNeeded} Eggs`,
                errorCode: 'INSUFFICIENT_EGGS'
            };
        }
        
        const userUpdates = {
            eggs: (user.eggs || 0) - eggsNeeded,
            chickens_owned: (user.chickens_owned || 0) + hatchAmount,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'hatch_chicken',
            amount: hatchAmount,
            eggsCost: eggsNeeded,
            timestamp: Date.now()
        });
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                chickens_hatched: hatchAmount,
                eggs_used: eggsNeeded,
                new_eggs: updatedUser.eggs,
                new_chickens: updatedUser.chickens_owned
            }
        };
        
    } catch (error) {
        console.error('Hatch chicken error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'HATCH_CHICKEN_ERROR'
        };
    }
}

// ============================================
// DIAMOND PRODUCTION
// ============================================

async function handleStartDiamondProduction(env, userId, data) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        if (!user.diamond_engines_owned || user.diamond_engines_owned < 1) {
            return {
                success: false,
                error: 'You need a Diamond Engine first',
                errorCode: 'NO_DIAMOND_ENGINE'
            };
        }
        
        if ((user.milk || 0) < GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK) {
            return {
                success: false,
                error: `Insufficient Milk. Need ${GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK} Milk`,
                errorCode: 'INSUFFICIENT_MILK'
            };
        }
        
        if ((user.eggs || 0) < GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG) {
            return {
                success: false,
                error: `Insufficient Eggs. Need ${GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG} Eggs`,
                errorCode: 'INSUFFICIENT_EGGS'
            };
        }
        
        const userUpdates = {
            milk: (user.milk || 0) - GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK,
            eggs: (user.eggs || 0) - GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG,
            diamond: (user.diamond || 0) + GAME_CONSTANTS.DIAMOND_PRODUCTION_YIELD,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'diamond_production',
            milkUsed: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK,
            eggsUsed: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG,
            diamondProduced: GAME_CONSTANTS.DIAMOND_PRODUCTION_YIELD,
            timestamp: Date.now()
        });
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                diamondProduced: GAME_CONSTANTS.DIAMOND_PRODUCTION_YIELD,
                newMilk: updatedUser.milk,
                newEggs: updatedUser.eggs,
                newDiamond: updatedUser.diamond
            }
        };
        
    } catch (error) {
        console.error('Diamond production error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DIAMOND_PRODUCTION_ERROR'
        };
    }
}

// ============================================
// DIAMOND CONVERSION
// ============================================

async function handleConvertDiamond(env, userId, data) {
    try {
        const { amount } = data;
        const diamondsToConvert = parseInt(amount);
        
        if (!diamondsToConvert || diamondsToConvert <= 0) {
            return {
                success: false,
                error: 'Invalid amount',
                errorCode: 'INVALID_AMOUNT'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        const globalResult = await dbGet(env, 'global');
        
        if (!userResult.success || !globalResult.success) {
            return {
                success: false,
                error: 'Failed to load game state',
                errorCode: 'STATE_LOAD_ERROR'
            };
        }
        
        let user = userResult.data;
        let global = globalResult.data;
        
        if (!user) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        if (!global) {
            global = await initializeGlobalState(env);
        }
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        if ((user.diamond || 0) < diamondsToConvert) {
            return {
                success: false,
                error: 'Insufficient diamonds',
                errorCode: 'INSUFFICIENT_DIAMOND'
            };
        }
        
        const diamondPrice = global.diamond_price || GAME_CONSTANTS.DIAMOND_BASE_PRICE;
        const tonToReceive = diamondsToConvert * diamondPrice;
        
        const userUpdates = {
            diamond: (user.diamond || 0) - diamondsToConvert,
            tonBalance: (user.tonBalance || 0) + tonToReceive,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'diamond_conversion',
            diamondsUsed: diamondsToConvert,
            diamondPrice: diamondPrice,
            tonReceived: tonToReceive,
            timestamp: Date.now()
        });
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                diamondsConverted: diamondsToConvert,
                diamondPrice: diamondPrice,
                tonReceived: tonToReceive,
                newDiamond: updatedUser.diamond,
                newTonBalance: updatedUser.tonBalance
            }
        };
        
    } catch (error) {
        console.error('Diamond conversion error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DIAMOND_CONVERSION_ERROR'
        };
    }
}

// ============================================
// MARKET - P2P ORDER BOOK WITH RACE CONDITION FIX
// ============================================

/**
 * Ø¯Ø§Ù„Ø© Ù…Ø­Ø³Ù†Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ Ø¨ÙŠØ¹ Ù…Ø¹ Ù…Ù†Ø¹ Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª (Race Condition)
 * ØªØ³ØªØ®Ø¯Ù… optimistic locking Ù…Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
 */
async function handleCreateSellOrder(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { resource, quantity, pricePerUnit } = data;
            
            if (!['milk', 'eggs'].includes(resource)) {
                return {
                    success: false,
                    error: 'Invalid resource. Must be milk or eggs',
                    errorCode: 'INVALID_RESOURCE'
                };
            }
            
            const orderQuantity = parseInt(quantity);
            if (!orderQuantity || orderQuantity < GAME_CONSTANTS.MIN_ORDER_AMOUNT) {
                return {
                    success: false,
                    error: `Minimum order quantity is ${GAME_CONSTANTS.MIN_ORDER_AMOUNT}`,
                    errorCode: 'INVALID_QUANTITY'
                };
            }
            
            const orderPrice = parseFloat(pricePerUnit);
            if (!orderPrice || orderPrice <= 0) {
                return {
                    success: false,
                    error: 'Price must be greater than 0',
                    errorCode: 'INVALID_PRICE'
                };
            }
            
            // Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ù†ØªØ§Ø¬ Ø£ÙˆÙ„Ø§Ù‹
            const userResult = await dbGet(env, `users/${userId}`);
            if (!userResult.success || !userResult.data) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            let user = userResult.data;
            
            // Ø­ÙØ¸ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ù†ØªØ§Ø¬ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡ Ù„Ø§Ø­Ù‚Ø§Ù‹
            const productionResult = await calculateProduction(env, userId, user);
            if (productionResult) {
                user = productionResult.user;
            }
            
            const currentBalance = resource === 'milk' ? (user.milk || 0) : (user.eggs || 0);
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙØ§ÙŠØ© Ø§Ù„Ø±ØµÙŠØ¯
            if (currentBalance < orderQuantity) {
                return {
                    success: false,
                    error: `Insufficient ${resource}. You have ${currentBalance}, need ${orderQuantity}`,
                    errorCode: 'INSUFFICIENT_RESOURCE'
                };
            }
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©
            const activeOrdersResult = await dbGet(env, `users/${userId}/orders`);
            let activeOrders = 0;
            if (activeOrdersResult.success && activeOrdersResult.data) {
                activeOrders = Object.values(activeOrdersResult.data).filter(o => o.status === 'active').length;
            }
            if (activeOrders >= GAME_CONSTANTS.MAX_ACTIVE_ORDERS) {
                return {
                    success: false,
                    error: `Maximum ${GAME_CONSTANTS.MAX_ACTIVE_ORDERS} active orders allowed`,
                    errorCode: 'MAX_ORDERS_REACHED'
                };
            }
            
            // ========== ATOMIC UPDATE Ù…Ø¹ optimistic locking ==========
            // Ù†Ø­Ø§ÙˆÙ„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±ØµÙŠØ¯ Ø¨Ø´ÙƒÙ„ Ø°Ø±ÙŠ
            const atomicResult = await atomicUpdateUserResource(
                env, 
                userId, 
                resource, 
                orderQuantity,
                currentBalance // Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø© Ù„Ù„Ø±ØµÙŠØ¯
            );
            
            if (!atomicResult.success) {
                // Ø¥Ø°Ø§ ÙØ´Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ø³Ø¨Ø¨ ØªØºÙŠØ± Ø§Ù„Ø±ØµÙŠØ¯ØŒ Ù†Ø¹ÙŠØ¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
                if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId}, retry attempt ${attempt}/${maxAttempts}`);
                        // Ø§Ù†ØªØ¸Ø§Ø± Ù‚ØµÙŠØ± Ù‚Ø¨Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else {
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode || 'ATOMIC_UPDATE_FAILED'
                    };
                }
            }
            
            // ========== Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø·Ù„Ø¨ Ø¨Ø¹Ø¯ Ù†Ø¬Ø§Ø­ Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø°Ø±ÙŠ ==========
            const now = Date.now();
            const orderId = `sell_${now}_${Math.random().toString(36).substring(2, 10)}_${attempt}`;
            
            const orderData = {
                id: orderId,
                userId: userId,
                type: 'sell',
                resource: resource,
                quantity: orderQuantity,
                remaining: orderQuantity,
                pricePerUnit: orderPrice,
                status: 'active',
                createdAt: now,
                updatedAt: now
            };
            
            // Ø­ÙØ¸ Ø§Ù„Ø·Ù„Ø¨
            await dbSet(env, `orders/${orderId}`, orderData);
            await dbSet(env, `users/${userId}/orders/${orderId}`, {
                id: orderId,
                type: 'sell',
                resource: resource,
                quantity: orderQuantity,
                remaining: orderQuantity,
                pricePerUnit: orderPrice,
                status: 'active',
                createdAt: now
            });
            
            // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'create_sell_order',
                orderId: orderId,
                resource: resource,
                quantity: orderQuantity,
                pricePerUnit: orderPrice,
                totalValue: orderQuantity * orderPrice,
                timestamp: now
            });
            
            return {
                success: true,
                data: {
                    orderId: orderId,
                    order: orderData,
                    newBalance: atomicResult.data.newBalance,
                    deducted: atomicResult.data.deducted
                }
            };
            
        } catch (error) {
            console.error(`Create sell order error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'CREATE_SELL_ORDER_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

/**
 * Ø¯Ø§Ù„Ø© Ù…Ø­Ø³Ù†Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ Ø´Ø±Ø§Ø¡ Ù…Ø¹ Ù…Ù†Ø¹ Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
 */
async function handleCreateBuyOrder(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { resource, quantity, pricePerUnit } = data;
            
            if (!['milk', 'eggs'].includes(resource)) {
                return {
                    success: false,
                    error: 'Invalid resource. Must be milk or eggs',
                    errorCode: 'INVALID_RESOURCE'
                };
            }
            
            const orderQuantity = parseInt(quantity);
            if (!orderQuantity || orderQuantity < GAME_CONSTANTS.MIN_ORDER_AMOUNT) {
                return {
                    success: false,
                    error: `Minimum order quantity is ${GAME_CONSTANTS.MIN_ORDER_AMOUNT}`,
                    errorCode: 'INVALID_QUANTITY'
                };
            }
            
            const orderPrice = parseFloat(pricePerUnit);
            if (!orderPrice || orderPrice <= 0) {
                return {
                    success: false,
                    error: 'Price must be greater than 0',
                    errorCode: 'INVALID_PRICE'
                };
            }
            
            const userResult = await dbGet(env, `users/${userId}`);
            if (!userResult.success || !userResult.data) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            let user = userResult.data;
            
            const productionResult = await calculateProduction(env, userId, user);
            if (productionResult) {
                user = productionResult.user;
            }
            
            const totalCost = orderQuantity * orderPrice;
            const currentTonBalance = user.tonBalance || 0;
            
            if (currentTonBalance < totalCost) {
                return {
                    success: false,
                    error: `Insufficient TON balance. You have ${currentTonBalance} TON, need ${totalCost} TON`,
                    errorCode: 'INSUFFICIENT_TON'
                };
            }
            
            const activeOrdersResult = await dbGet(env, `users/${userId}/orders`);
            let activeOrders = 0;
            if (activeOrdersResult.success && activeOrdersResult.data) {
                activeOrders = Object.values(activeOrdersResult.data).filter(o => o.status === 'active').length;
            }
            if (activeOrders >= GAME_CONSTANTS.MAX_ACTIVE_ORDERS) {
                return {
                    success: false,
                    error: `Maximum ${GAME_CONSTANTS.MAX_ACTIVE_ORDERS} active orders allowed`,
                    errorCode: 'MAX_ORDERS_REACHED'
                };
            }
            
            // ========== ATOMIC UPDATE Ù„Ù„Ø±ØµÙŠØ¯ ==========
            const atomicResult = await atomicUpdateUserResource(
                env, 
                userId, 
                'tonBalance', 
                totalCost,
                currentTonBalance
            );
            
            if (!atomicResult.success) {
                if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                    attempt++;
                    if (attempt < maxAttempts) {
                        console.log(`Race condition detected for user ${userId} (buy order), retry attempt ${attempt}/${maxAttempts}`);
                        await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                        continue;
                    } else {
                        return {
                            success: false,
                            error: 'System busy, please try again',
                            errorCode: 'RACE_CONDITION_MAX_RETRIES'
                        };
                    }
                } else {
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode || 'ATOMIC_UPDATE_FAILED'
                    };
                }
            }
            
            // ========== Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø·Ù„Ø¨ ==========
            const now = Date.now();
            const orderId = `buy_${now}_${Math.random().toString(36).substring(2, 10)}_${attempt}`;
            
            const orderData = {
                id: orderId,
                userId: userId,
                type: 'buy',
                resource: resource,
                quantity: orderQuantity,
                remaining: orderQuantity,
                pricePerUnit: orderPrice,
                status: 'active',
                createdAt: now,
                updatedAt: now
            };
            
            await dbSet(env, `orders/${orderId}`, orderData);
            await dbSet(env, `users/${userId}/orders/${orderId}`, {
                id: orderId,
                type: 'buy',
                resource: resource,
                quantity: orderQuantity,
                remaining: orderQuantity,
                pricePerUnit: orderPrice,
                status: 'active',
                createdAt: now
            });
            
            await dbPush(env, `users/${userId}/transactions`, {
                type: 'create_buy_order',
                orderId: orderId,
                resource: resource,
                quantity: orderQuantity,
                pricePerUnit: orderPrice,
                totalCost: totalCost,
                timestamp: now
            });
            
            return {
                success: true,
                data: {
                    orderId: orderId,
                    order: orderData,
                    newBalance: atomicResult.data.newBalance,
                    deducted: atomicResult.data.deducted
                }
            };
            
        } catch (error) {
            console.error(`Create buy order error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'CREATE_BUY_ORDER_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

/**
 * Ø¯Ø§Ù„Ø© Ù…Ø­Ø³Ù†Ø© Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ù…Ø¹ Ù…Ù†Ø¹ Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
 */
async function handleExecuteOrder(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { orderId, quantity } = data;
            
            const orderResult = await dbGet(env, `orders/${orderId}`);
            if (!orderResult.success || !orderResult.data) {
                return {
                    success: false,
                    error: 'Order not found',
                    errorCode: 'ORDER_NOT_FOUND'
                };
            }
            
            const order = orderResult.data;
            
            if (order.status !== 'active') {
                return {
                    success: false,
                    error: 'Order is not active',
                    errorCode: 'ORDER_NOT_ACTIVE'
                };
            }
            
            if (order.userId === userId) {
                return {
                    success: false,
                    error: 'Cannot execute your own order',
                    errorCode: 'OWN_ORDER'
                };
            }
            
            const executeQuantity = quantity ? parseInt(quantity) : order.remaining;
            if (executeQuantity <= 0 || executeQuantity > order.remaining) {
                return {
                    success: false,
                    error: 'Invalid execution quantity',
                    errorCode: 'INVALID_QUANTITY'
                };
            }
            
            // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¨Ø§Ø¦Ø¹ ÙˆØ§Ù„Ù…Ø´ØªØ±ÙŠ
            let buyerId, sellerId;
            if (order.type === 'sell') {
                buyerId = userId;
                sellerId = order.userId;
            } else {
                buyerId = order.userId;
                sellerId = userId;
            }
            
            // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙŠ
            const buyerResult = await dbGet(env, `users/${buyerId}`);
            if (!buyerResult.success || !buyerResult.data) {
                return {
                    success: false,
                    error: 'Buyer not found',
                    errorCode: 'BUYER_NOT_FOUND'
                };
            }
            
            let buyerData = buyerResult.data;
            const buyerProduction = await calculateProduction(env, buyerId, buyerData);
            if (buyerProduction) {
                buyerData = buyerProduction.user;
            }
            
            // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø§Ø¦Ø¹
            const sellerResult = await dbGet(env, `users/${sellerId}`);
            if (!sellerResult.success || !sellerResult.data) {
                return {
                    success: false,
                    error: 'Seller not found',
                    errorCode: 'SELLER_NOT_FOUND'
                };
            }
            
            let sellerData = sellerResult.data;
            const sellerProduction = await calculateProduction(env, sellerId, sellerData);
            if (sellerProduction) {
                sellerData = sellerProduction.user;
            }
            
            const totalCost = executeQuantity * order.pricePerUnit;
            const fee = order.type === 'sell' ? totalCost * (GAME_CONSTANTS.MARKET_FEE_PERCENT / 100) : 0;
            const sellerReceives = order.type === 'sell' ? totalCost - fee : totalCost;
            
            // ========== ØªÙ†ÙÙŠØ° Atomic Updates ==========
            if (order.type === 'sell') {
                // Ø§Ù„Ù…Ø´ØªØ±ÙŠ ÙŠØ¯ÙØ¹ TONØŒ Ø§Ù„Ø¨Ø§Ø¦Ø¹ ÙŠØ³ØªÙ„Ù… TON Ù†Ø§Ù‚Øµ Ø§Ù„Ø¹Ù…ÙˆÙ„Ø©
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø´ØªØ±ÙŠ
                if ((buyerData.tonBalance || 0) < totalCost) {
                    return {
                        success: false,
                        error: 'Buyer has insufficient TON balance',
                        errorCode: 'BUYER_INSUFFICIENT_TON'
                    };
                }
                
                // Ø®ØµÙ… TON Ù…Ù† Ø§Ù„Ù…Ø´ØªØ±ÙŠ (atomic)
                const buyerTonUpdate = await atomicUpdateUserResource(
                    env, buyerId, 'tonBalance', totalCost, buyerData.tonBalance
                );
                if (!buyerTonUpdate.success) {
                    if (buyerTonUpdate.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    }
                    return {
                        success: false,
                        error: buyerTonUpdate.error,
                        errorCode: 'BUYER_UPDATE_FAILED'
                    };
                }
                
                // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ Ù„Ù„Ù…Ø´ØªØ±ÙŠ
                if (order.resource === 'milk') {
                    await dbUpdate(env, `users/${buyerId}`, {
                        milk: (buyerData.milk || 0) + executeQuantity,
                        updatedAt: Date.now()
                    });
                } else {
                    await dbUpdate(env, `users/${buyerId}`, {
                        eggs: (buyerData.eggs || 0) + executeQuantity,
                        updatedAt: Date.now()
                    });
                }
                
                // Ø¥Ø¶Ø§ÙØ© TON Ù„Ù„Ø¨Ø§Ø¦Ø¹ (atomic)
                const sellerTonUpdate = await atomicUpdateUserResource(
                    env, sellerId, 'tonBalance', -sellerReceives, sellerData.tonBalance
                );
                if (!sellerTonUpdate.success) {
                    // ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø±ØµÙŠØ¯ Ù„Ù„Ø¨Ø§Ø¦Ø¹ØŒ Ù†Ø­ØªØ§Ø¬ Ù„Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø´ØªØ±ÙŠ
                    await atomicUpdateUserResource(env, buyerId, 'tonBalance', -totalCost, buyerData.tonBalance - totalCost);
                    if (sellerTonUpdate.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    }
                    return {
                        success: false,
                        error: 'Failed to credit seller, transaction rolled back',
                        errorCode: 'SELLER_UPDATE_FAILED'
                    };
                }
                
            } else {
                // order.type === 'buy'
                // Ø§Ù„Ø¨Ø§Ø¦Ø¹ ÙŠØ¨ÙŠØ¹ Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ØŒ Ø§Ù„Ù…Ø´ØªØ±ÙŠ ÙŠØ³ØªÙ„Ù…Ù‡Ø§
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±ØµÙŠØ¯ Ø§Ù„Ø¨Ø§Ø¦Ø¹
                const sellerResourceBalance = order.resource === 'milk' ? 
                    (sellerData.milk || 0) : (sellerData.eggs || 0);
                if (sellerResourceBalance < executeQuantity) {
                    return {
                        success: false,
                        error: 'Seller has insufficient resource',
                        errorCode: 'SELLER_INSUFFICIENT_RESOURCE'
                    };
                }
                
                // Ø®ØµÙ… Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ Ù…Ù† Ø§Ù„Ø¨Ø§Ø¦Ø¹ (atomic)
                const sellerResourceUpdate = await atomicUpdateUserResource(
                    env, sellerId, order.resource, executeQuantity, sellerResourceBalance
                );
                if (!sellerResourceUpdate.success) {
                    if (sellerResourceUpdate.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    }
                    return {
                        success: false,
                        error: sellerResourceUpdate.error,
                        errorCode: 'SELLER_UPDATE_FAILED'
                    };
                }
                
                // Ø¥Ø¶Ø§ÙØ© TON Ù„Ù„Ø¨Ø§Ø¦Ø¹
                await dbUpdate(env, `users/${sellerId}`, {
                    tonBalance: (sellerData.tonBalance || 0) + totalCost,
                    updatedAt: Date.now()
                });
                
                // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ Ù„Ù„Ù…Ø´ØªØ±ÙŠ
                if (order.resource === 'milk') {
                    await dbUpdate(env, `users/${buyerId}`, {
                        milk: (buyerData.milk || 0) + executeQuantity,
                        updatedAt: Date.now()
                    });
                } else {
                    await dbUpdate(env, `users/${buyerId}`, {
                        eggs: (buyerData.eggs || 0) + executeQuantity,
                        updatedAt: Date.now()
                    });
                }
            }
            
            // ========== ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨ ==========
            const newRemaining = order.remaining - executeQuantity;
            const orderStatus = newRemaining <= 0 ? 'filled' : 'active';
            
            const orderUpdates = {
                remaining: newRemaining,
                status: orderStatus,
                updatedAt: Date.now()
            };
            
            await dbUpdate(env, `orders/${orderId}`, orderUpdates);
            await dbUpdate(env, `users/${order.userId}/orders/${orderId}`, orderUpdates);
            
            // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
            const txId = `tx_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
            
            await dbPush(env, `users/${buyerId}/transactions`, {
                id: txId,
                type: 'market_buy',
                orderId: orderId,
                resource: order.resource,
                quantity: executeQuantity,
                pricePerUnit: order.pricePerUnit,
                totalCost: totalCost,
                sellerId: sellerId,
                timestamp: Date.now()
            });
            
            await dbPush(env, `users/${sellerId}/transactions`, {
                id: txId,
                type: 'market_sell',
                orderId: orderId,
                resource: order.resource,
                quantity: executeQuantity,
                pricePerUnit: order.pricePerUnit,
                totalReceived: sellerReceives,
                fee: fee,
                buyerId: buyerId,
                timestamp: Date.now()
            });
            
            // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±
            await notifyOrderFilled(env, order.userId, order, executeQuantity, totalCost, fee);
            
            return {
                success: true,
                data: {
                    txId: txId,
                    orderId: orderId,
                    resource: order.resource,
                    quantity: executeQuantity,
                    pricePerUnit: order.pricePerUnit,
                    totalCost: totalCost,
                    fee: fee,
                    sellerReceives: sellerReceives,
                    orderRemaining: newRemaining,
                    orderStatus: orderStatus
                }
            };
            
        } catch (error) {
            console.error(`Execute order error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'EXECUTE_ORDER_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

async function handleGetMarketOrders(env, data) {
    try {
        const { resource, type, page = 1, limit = 10 } = data;
        
        const ordersResult = await dbGet(env, 'orders');
        
        if (!ordersResult.success || !ordersResult.data) {
            return {
                success: true,
                data: {
                    orders: [],
                    total: 0,
                    page: page,
                    totalPages: 0
                }
            };
        }
        
        const allOrders = ordersResult.data;
        const filteredOrders = [];
        
        for (const [orderId, order] of Object.entries(allOrders)) {
            if (order.status !== 'active') continue;
            
            if (resource && order.resource !== resource) continue;
            
            if (type && order.type !== type) continue;
            
            filteredOrders.push({
                id: orderId,
                userId: order.userId,
                type: order.type,
                resource: order.resource,
                quantity: order.quantity,
                remaining: order.remaining,
                pricePerUnit: order.pricePerUnit,
                createdAt: order.createdAt
            });
        }
        
        if (type === 'sell') {
            filteredOrders.sort((a, b) => a.pricePerUnit - b.pricePerUnit);
        } else if (type === 'buy') {
            filteredOrders.sort((a, b) => b.pricePerUnit - a.pricePerUnit);
        } else {
            filteredOrders.sort((a, b) => b.createdAt - a.createdAt);
        }
        
        const total = filteredOrders.length;
        const totalPages = Math.ceil(total / limit);
        const start = (page - 1) * limit;
        const end = start + limit;
        const paginatedOrders = filteredOrders.slice(start, end);
        
        return {
            success: true,
            data: {
                orders: paginatedOrders,
                total: total,
                page: page,
                totalPages: totalPages,
                hasMore: page < totalPages
            }
        };
        
    } catch (error) {
        console.error('Get market orders error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_MARKET_ORDERS_ERROR'
        };
    }
}

async function handleGetMyOrders(env, userId) {
    try {
        const ordersResult = await dbGet(env, `users/${userId}/orders`);
        
        if (!ordersResult.success || !ordersResult.data) {
            return {
                success: true,
                data: {
                    orders: []
                }
            };
        }
        
        const userOrders = ordersResult.data;
        const activeOrders = [];
        const filledOrders = [];
        
        for (const [orderId, order] of Object.entries(userOrders)) {
            if (order.status === 'active') {
                activeOrders.push({
                    id: orderId,
                    ...order
                });
            } else {
                filledOrders.push({
                    id: orderId,
                    ...order
                });
            }
        }
        
        activeOrders.sort((a, b) => b.createdAt - a.createdAt);
        filledOrders.sort((a, b) => b.createdAt - a.createdAt);
        
        return {
            success: true,
            data: {
                active: activeOrders.slice(0, 20),
                filled: filledOrders.slice(0, 20)
            }
        };
        
    } catch (error) {
        console.error('Get my orders error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_MY_ORDERS_ERROR'
        };
    }
}

/**
 * Ø¯Ø§Ù„Ø© Ù…Ø­Ø³Ù†Ø© Ù„Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ù…Ø¹ Ù…Ù†Ø¹ Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
 */
async function handleCancelOrder(env, userId, data) {
    let attempt = 0;
    const maxAttempts = GAME_CONSTANTS.MAX_RETRY_ATTEMPTS;
    
    while (attempt < maxAttempts) {
        try {
            const { orderId } = data;
            
            const orderResult = await dbGet(env, `orders/${orderId}`);
            if (!orderResult.success || !orderResult.data) {
                return {
                    success: false,
                    error: 'Order not found',
                    errorCode: 'ORDER_NOT_FOUND'
                };
            }
            
            const order = orderResult.data;
            
            if (order.userId !== userId) {
                return {
                    success: false,
                    error: 'Unauthorized to cancel this order',
                    errorCode: 'UNAUTHORIZED'
                };
            }
            
            if (order.status !== 'active') {
                return {
                    success: false,
                    error: 'Order is not active',
                    errorCode: 'ORDER_NOT_ACTIVE'
                };
            }
            
            // Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            const userResult = await dbGet(env, `users/${userId}`);
            if (!userResult.success || !userResult.data) {
                return {
                    success: false,
                    error: 'User not found',
                    errorCode: 'USER_NOT_FOUND'
                };
            }
            
            let user = userResult.data;
            
            const productionResult = await calculateProduction(env, userId, user);
            if (productionResult) {
                user = productionResult.user;
            }
            
            // ========== Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø£Ù…ÙˆØ§Ù„ Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø°Ø±ÙŠ ==========
            if (order.type === 'sell') {
                // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…ÙˆØ§Ø±Ø¯
                const resourceBalance = order.resource === 'milk' ? (user.milk || 0) : (user.eggs || 0);
                
                const atomicResult = await atomicUpdateUserResource(
                    env,
                    userId,
                    order.resource,
                    -order.remaining, // Ø¥Ø¶Ø§ÙØ© (Ù‚ÙŠÙ…Ø© Ø³Ø§Ù„Ø¨Ø©)
                    resourceBalance
                );
                
                if (!atomicResult.success) {
                    if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    }
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode
                    };
                }
                
            } else {
                // Ø¥Ø¹Ø§Ø¯Ø© TON
                const refundAmount = order.remaining * order.pricePerUnit;
                
                const atomicResult = await atomicUpdateUserResource(
                    env,
                    userId,
                    'tonBalance',
                    -refundAmount, // Ø¥Ø¶Ø§ÙØ© (Ù‚ÙŠÙ…Ø© Ø³Ø§Ù„Ø¨Ø©)
                    user.tonBalance || 0
                );
                
                if (!atomicResult.success) {
                    if (atomicResult.errorCode === 'RACE_CONDITION_DETECTED') {
                        attempt++;
                        if (attempt < maxAttempts) {
                            await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
                            continue;
                        }
                    }
                    return {
                        success: false,
                        error: atomicResult.error,
                        errorCode: atomicResult.errorCode
                    };
                }
            }
            
            // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨
            const orderUpdates = {
                status: 'cancelled',
                updatedAt: Date.now()
            };
            
            await dbUpdate(env, `orders/${orderId}`, orderUpdates);
            await dbUpdate(env, `users/${userId}/orders/${orderId}`, orderUpdates);
            
            return {
                success: true,
                data: {
                    orderId: orderId,
                    status: 'cancelled'
                }
            };
            
        } catch (error) {
            console.error(`Cancel order error (attempt ${attempt + 1}):`, error);
            attempt++;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, GAME_CONSTANTS.RETRY_DELAY_MS * attempt));
            } else {
                return {
                    success: false,
                    error: error.message,
                    errorCode: 'CANCEL_ORDER_ERROR'
                };
            }
        }
    }
    
    return {
        success: false,
        error: 'Maximum retry attempts exceeded',
        errorCode: 'MAX_RETRIES_EXCEEDED'
    };
}

// ============================================
// DEPOSIT SYSTEM
// ============================================

async function handleDeposit(env, userId, data) {
    try {
        const { amount, txHash, comment } = data;
        
        if (!amount || amount < GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT) {
            return {
                success: false,
                error: `Minimum deposit amount is ${GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT} TON`,
                errorCode: 'INVALID_AMOUNT'
            };
        }
        
        if (!comment || comment.toString() !== userId) {
            return {
                success: false,
                error: 'Invalid comment. Comment must contain only your User ID',
                errorCode: 'INVALID_COMMENT'
            };
        }
        
        const existingTx = await dbGet(env, `transactions/${txHash}`);
        
        if (existingTx.success && existingTx.data) {
            return {
                success: false,
                error: 'Transaction already processed',
                errorCode: 'DUPLICATE_TRANSACTION'
            };
        }
        
        const depositId = `dep_${Date.now()}_${userId}`;
        const now = Date.now();
        
        const depositRecord = {
            id: depositId,
            userId: userId,
            amount: parseFloat(amount),
            txHash: txHash,
            comment: comment,
            status: 'pending',
            createdAt: now,
            updatedAt: now
        };
        
        await dbSet(env, `deposits/${depositId}`, depositRecord);
        await dbSet(env, `transactions/${txHash}`, depositRecord);
        await dbSet(env, `users/${userId}/deposits/${depositId}`, depositRecord);
        
        return {
            success: true,
            data: {
                depositId: depositId,
                amount: amount,
                status: 'pending',
                message: 'Transaction received. Verification in progress.'
            }
        };
        
    } catch (error) {
        console.error('Deposit error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DEPOSIT_ERROR'
        };
    }
}

async function handleVerifyDeposit(env, userId, data) {
    try {
        const { txHash, depositId } = data;
        
        let depositRecord = null;
        
        if (txHash) {
            const txResult = await dbGet(env, `transactions/${txHash}`);
            if (txResult.success && txResult.data) {
                depositRecord = txResult.data;
            }
        }
        
        if (!depositRecord && depositId) {
            const depositResult = await dbGet(env, `deposits/${depositId}`);
            if (depositResult.success && depositResult.data) {
                depositRecord = depositResult.data;
            }
        }
        
        if (!depositRecord) {
            return {
                success: false,
                error: 'Deposit record not found',
                errorCode: 'DEPOSIT_NOT_FOUND'
            };
        }
        
        if (depositRecord.userId !== userId) {
            return {
                success: false,
                error: 'Unauthorized access',
                errorCode: 'UNAUTHORIZED'
            };
        }
        
        if (depositRecord.status === 'completed') {
            return {
                success: true,
                data: {
                    status: 'completed',
                    amount: depositRecord.amount,
                    verified: true,
                    timestamp: depositRecord.updatedAt
                }
            };
        }
        
        const isDevelopment = env.ENVIRONMENT === 'development';
        
        if (isDevelopment && depositRecord.createdAt) {
            const timeElapsed = Date.now() - depositRecord.createdAt;
            if (timeElapsed > 30000) {
                await dbUpdate(env, `deposits/${depositRecord.id}`, {
                    status: 'completed',
                    verified: true,
                    updatedAt: Date.now()
                });
                
                await dbUpdate(env, `transactions/${depositRecord.txHash}`, {
                    status: 'completed',
                    verified: true,
                    updatedAt: Date.now()
                });
                
                await dbUpdate(env, `users/${userId}/deposits/${depositRecord.id}`, {
                    status: 'completed',
                    verified: true,
                    updatedAt: Date.now()
                });
                
                const userResult = await dbGet(env, `users/${userId}`);
                if (userResult.success && userResult.data) {
                    const user = userResult.data;
                    await dbUpdate(env, `users/${userId}`, {
                        tonBalance: (user.tonBalance || 0) + depositRecord.amount,
                        updatedAt: Date.now()
                    });
                    
                    await notifyDepositSuccess(env, userId, depositRecord.amount);
                }
                
                return {
                    success: true,
                    data: {
                        status: 'completed',
                        amount: depositRecord.amount,
                        verified: true,
                        timestamp: Date.now()
                    }
                };
            }
        }
        
        return {
            success: true,
            data: {
                status: depositRecord.status,
                amount: depositRecord.amount,
                verified: depositRecord.verified || false,
                timestamp: depositRecord.createdAt
            }
        };
        
    } catch (error) {
        console.error('Verify deposit error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_DEPOSIT_ERROR'
        };
    }
}

// ============================================
// WITHDRAWAL SYSTEM
// ============================================

async function handleWithdraw(env, userId, data) {
    try {
        const { amount, address } = data;
        const withdrawAmount = parseFloat(amount);
        
        if (!withdrawAmount || withdrawAmount < GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT) {
            return {
                success: false,
                error: `Minimum withdrawal amount is ${GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT} TON`,
                errorCode: 'INVALID_AMOUNT'
            };
        }
        
        if (!address || address.trim().length < 10) {
            return {
                success: false,
                error: 'Valid TON wallet address is required',
                errorCode: 'INVALID_ADDRESS'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        const fee = withdrawAmount * (GAME_CONSTANTS.WITHDRAW_FEE_PERCENT / 100);
        const netAmount = withdrawAmount - fee;
        
        if ((user.tonBalance || 0) < withdrawAmount) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        const withdrawalId = `wd_${Date.now()}_${userId}`;
        const now = Date.now();
        
        const withdrawalRecord = {
            id: withdrawalId,
            userId: userId,
            amount: withdrawAmount,
            fee: fee,
            netAmount: netAmount,
            address: address,
            status: 'pending',
            createdAt: now,
            updatedAt: now
        };
        
        await dbUpdate(env, `users/${userId}`, {
            tonBalance: (user.tonBalance || 0) - withdrawAmount,
            updatedAt: now
        });
        
        await dbSet(env, `withdrawals/${withdrawalId}`, withdrawalRecord);
        await dbSet(env, `users/${userId}/withdrawals/${withdrawalId}`, withdrawalRecord);
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'withdrawal',
            withdrawalId: withdrawalId,
            amount: withdrawAmount,
            fee: fee,
            netAmount: netAmount,
            address: address,
            status: 'pending',
            timestamp: now
        });
        
        return {
            success: true,
            data: {
                withdrawalId: withdrawalId,
                amount: withdrawAmount,
                fee: fee,
                netAmount: netAmount,
                newBalance: (user.tonBalance || 0) - withdrawAmount,
                status: 'pending'
            }
        };
        
    } catch (error) {
        console.error('Withdrawal error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'WITHDRAWAL_ERROR'
        };
    }
}

// ============================================
// REFERRAL SYSTEM
// ============================================

async function handleClaimReferralEarnings(env, userId) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        const earnings = parseFloat(user.referralEarnings || 0);
        
        if (earnings <= 0) {
            return {
                success: false,
                error: 'No referral earnings to claim',
                errorCode: 'NO_EARNINGS'
            };
        }
        
        const currentTonBalance = parseFloat(user.tonBalance || 0);
        const currentClaimed = parseFloat(user.referralEarningsClaimed || 0);
        
        const userUpdates = {
            tonBalance: currentTonBalance + earnings,
            referralEarnings: 0,
            referralEarningsClaimed: currentClaimed + earnings,
            updatedAt: Date.now()
        };
        
        await dbUpdate(env, `users/${userId}`, userUpdates);
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'claim_referral',
            amount: earnings,
            timestamp: Date.now()
        });
        
        const updatedUserResult = await dbGet(env, `users/${userId}`);
        const updatedUser = updatedUserResult.data;
        
        return {
            success: true,
            data: {
                claimedAmount: earnings,
                newTonBalance: updatedUser.tonBalance,
                totalClaimed: updatedUser.referralEarningsClaimed
            }
        };
        
    } catch (error) {
        console.error('Claim referral earnings error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'CLAIM_REFERRAL_ERROR'
        };
    }
}

async function handleGetReferralInfo(env, userId) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        const user = userResult.data;
        
        const referralsResult = await dbGet(env, `users/${userId}/referrals`);
        
        let referrals = [];
        if (referralsResult.success && referralsResult.data) {
            const referralsObj = referralsResult.data;
            referrals = Object.entries(referralsObj).map(([key, value]) => ({
                id: key,
                ...value
            }));
            
            referrals.sort((a, b) => (b.joinedAt || 0) - (a.joinedAt || 0));
        }
        
        const earningsResult = await dbGet(env, `users/${userId}/referralEarnings`);
        let earnings = [];
        if (earningsResult.success && earningsResult.data) {
            const earningsObj = earningsResult.data;
            earnings = Object.values(earningsObj);
            earnings.sort((a, b) => b.timestamp - a.timestamp);
        }
        
        const totalEarnings = earnings.reduce((sum, e) => sum + parseFloat(e.amount || 0), 0);
        
        return {
            success: true,
            data: {
                referralCode: user.referralCode,
                referralEarnings: parseFloat(user.referralEarnings || 0),
                referralEarningsClaimed: parseFloat(user.referralEarningsClaimed || 0),
                totalEarnings: totalEarnings,
                referrals: referrals.slice(0, 50),
                earnings: earnings.slice(0, 50)
            }
        };
        
    } catch (error) {
        console.error('Get referral info error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_REFERRAL_ERROR'
        };
    }
}

// ============================================
// TASK SYSTEM
// ============================================

async function initializePartnerTasks(env) {
    for (const task of PARTNER_TASKS) {
        const taskResult = await dbGet(env, `tasks/partner/${task.id}`);
        if (!taskResult.success || !taskResult.data) {
            await dbSet(env, `tasks/partner/${task.id}`, task);
        }
    }
}

async function handleCreateTask(env, userId, data) {
    try {
        const { type, link, targetUsers, reward } = data;
        
        if (!['channel', 'bot'].includes(type)) {
            return {
                success: false,
                error: 'Invalid task type. Must be channel or bot',
                errorCode: 'INVALID_TASK_TYPE'
            };
        }
        
        const target = parseInt(targetUsers);
        
        if (!target || target < GAME_CONSTANTS.MIN_TASK_TARGET) {
            return {
                success: false,
                error: `Minimum target users is ${GAME_CONSTANTS.MIN_TASK_TARGET}`,
                errorCode: 'INVALID_TARGET'
            };
        }
        
        if (!link || !link.includes('t.me/')) {
            return {
                success: false,
                error: 'Valid Telegram link is required',
                errorCode: 'INVALID_LINK'
            };
        }
        
        const taskReward = GAME_CONSTANTS.TASK_REWARD;
        const totalCost = target * taskReward * 2;
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        const productionResult = await calculateProduction(env, userId, user);
        
        if (productionResult) {
            user = productionResult.user;
        }
        
        if ((user.tonBalance || 0) < totalCost) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON'
            };
        }
        
        const now = Date.now();
        const taskId = `task_${now}_${Math.random().toString(36).substring(2, 10)}`;
        
        const taskData = {
            id: taskId,
            creatorId: userId,
            type: type,
            link: link,
            targetUsers: target,
            reward: taskReward,
            completions: 0,
            completedBy: [],
            status: 'active',
            createdAt: now,
            expiresAt: now + (GAME_CONSTANTS.MAX_TASK_DURATION_DAYS * 24 * 60 * 60 * 1000),
            updatedAt: now
        };
        
        await dbUpdate(env, `users/${userId}`, {
            tonBalance: (user.tonBalance || 0) - totalCost,
            updatedAt: now
        });
        
        await dbSet(env, `tasks/community/${taskId}`, taskData);
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'create_task',
            taskId: taskId,
            taskType: type,
            targetUsers: target,
            cost: totalCost,
            timestamp: now
        });
        
        await notifyTaskCreated(env, userId, type, target, totalCost);
        
        return {
            success: true,
            data: {
                taskId: taskId,
                type: type,
                targetUsers: target,
                totalCost: totalCost,
                reward: taskReward
            }
        };
        
    } catch (error) {
        console.error('Create task error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'CREATE_TASK_ERROR'
        };
    }
}

async function handleVerifyTask(env, userId, data) {
    try {
        const { taskId, taskType } = data;
        
        let taskResult = await dbGet(env, `tasks/community/${taskId}`);
        let task = taskResult.data;
        let taskCategory = 'community';
        
        if (!task) {
            taskResult = await dbGet(env, `tasks/partner/${taskId}`);
            task = taskResult.data;
            taskCategory = 'partner';
        }
        
        if (!task) {
            return {
                success: false,
                error: 'Task not found',
                errorCode: 'TASK_NOT_FOUND'
            };
        }
        
        if (task.status !== 'active') {
            return {
                success: false,
                error: 'Task is no longer active',
                errorCode: 'TASK_INACTIVE'
            };
        }
        
        if (task.completedBy && task.completedBy.includes(userId)) {
            return {
                success: false,
                error: 'Task already completed',
                errorCode: 'TASK_ALREADY_COMPLETED'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        let user = userResult.data;
        
        if (task.type === 'channel') {
            const isMember = await checkTelegramMembership(env, userId, task.link);
            
            if (!isMember) {
                return {
                    success: false,
                    error: 'Not a member of the channel',
                    errorCode: 'NOT_MEMBER'
                };
            }
        }
        
        const currentCompletions = task.completions || 0;
        const newCompletions = currentCompletions + 1;
        
        const taskUpdates = {
            completions: newCompletions,
            completedBy: [...(task.completedBy || []), userId],
            updatedAt: Date.now()
        };
        
        if (newCompletions >= task.targetUsers) {
            taskUpdates.status = 'completed';
        }
        
        await dbUpdate(env, `tasks/${taskCategory}/${taskId}`, taskUpdates);
        
        const reward = task.reward || GAME_CONSTANTS.TASK_REWARD;
        
        await dbUpdate(env, `users/${userId}`, {
            tonBalance: (user.tonBalance || 0) + reward,
            updatedAt: Date.now()
        });
        
        const completedTasks = user.completedTasks || [];
        completedTasks.push(taskId);
        
        await dbUpdate(env, `users/${userId}`, {
            completedTasks: completedTasks
        });
        
        await dbPush(env, `users/${userId}/transactions`, {
            type: 'task_reward',
            taskId: taskId,
            taskType: task.type,
            reward: reward,
            timestamp: Date.now()
        });
        
        await notifyTaskCompleted(env, userId, task.type, reward);
        
        return {
            success: true,
            data: {
                taskId: taskId,
                reward: reward,
                completions: newCompletions,
                taskCompleted: newCompletions >= task.targetUsers
            }
        };
        
    } catch (error) {
        console.error('Verify task error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'VERIFY_TASK_ERROR'
        };
    }
}

async function handleGetTasks(env, userId) {
    try {
        await initializePartnerTasks(env);
        
        const partnerTasksResult = await dbGet(env, 'tasks/partner');
        let partnerTasks = [];
        
        if (partnerTasksResult.success && partnerTasksResult.data) {
            partnerTasks = Object.values(partnerTasksResult.data)
                .filter(t => t.status === 'active')
                .map(task => ({
                    ...task,
                    completedByUser: task.completedBy && task.completedBy.includes(userId)
                }));
        }
        
        const communityTasksResult = await dbGet(env, 'tasks/community');
        let communityTasks = [];
        
        if (communityTasksResult.success && communityTasksResult.data) {
            communityTasks = Object.values(communityTasksResult.data)
                .filter(t => t.status === 'active')
                .map(task => ({
                    ...task,
                    completedByUser: task.completedBy && task.completedBy.includes(userId)
                }));
        }
        
        return {
            success: true,
            data: {
                partner: partnerTasks,
                community: communityTasks
            }
        };
        
    } catch (error) {
        console.error('Get tasks error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_TASKS_ERROR'
        };
    }
}

// ============================================
// BOUNTY SYSTEM
// ============================================

async function handleSubmitBounty(env, userId, data) {
    try {
        const { link, platform } = data;
        
        if (!link || !link.includes('t.me/') && !link.includes('youtube.com') && !link.includes('facebook.com') && !link.includes('twitter.com') && !link.includes('x.com')) {
            return {
                success: false,
                error: 'Valid social media link is required',
                errorCode: 'INVALID_LINK'
            };
        }
        
        if (!platform || !['telegram', 'youtube', 'facebook', 'twitter'].includes(platform)) {
            return {
                success: false,
                error: 'Invalid platform',
                errorCode: 'INVALID_PLATFORM'
            };
        }
        
        const bountiesResult = await dbGet(env, 'bounties');
        if (bountiesResult.success && bountiesResult.data) {
            const existing = Object.values(bountiesResult.data).find(b => b.link === link);
            if (existing) {
                return {
                    success: false,
                    error: 'This link has already been submitted',
                    errorCode: 'DUPLICATE_LINK'
                };
            }
        }
        
        const now = Date.now();
        const bountyId = `bounty_${now}_${Math.random().toString(36).substring(2, 10)}`;
        
        const bountyData = {
            id: bountyId,
            userId: userId,
            link: link,
            platform: platform,
            status: 'pending',
            reward: null,
            rejectReason: null,
            createdAt: now,
            updatedAt: now
        };
        
        await dbSet(env, `bounties/${bountyId}`, bountyData);
        await dbSet(env, `users/${userId}/bounties/${bountyId}`, bountyData);
        
        await notifyBountySubmitted(env, userId, bountyId);
        
        return {
            success: true,
            data: {
                bountyId: bountyId,
                status: 'pending',
                message: 'Bounty submitted successfully'
            }
        };
        
    } catch (error) {
        console.error('Submit bounty error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'SUBMIT_BOUNTY_ERROR'
        };
    }
}

async function handleGetUserBounties(env, userId) {
    try {
        const bountiesResult = await dbGet(env, `users/${userId}/bounties`);
        
        if (!bountiesResult.success || !bountiesResult.data) {
            return {
                success: true,
                data: []
            };
        }
        
        const bounties = Object.values(bountiesResult.data)
            .sort((a, b) => b.createdAt - a.createdAt);
        
        return {
            success: true,
            data: bounties
        };
        
    } catch (error) {
        console.error('Get user bounties error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_USER_BOUNTIES_ERROR'
        };
    }
}

async function handleAdminGetAllBounties(env, userId) {
    try {
        if (!ADMIN_IDS.includes(userId)) {
            return {
                success: false,
                error: 'Unauthorized',
                errorCode: 'UNAUTHORIZED'
            };
        }
        
        const bountiesResult = await dbGet(env, 'bounties');
        
        if (!bountiesResult.success || !bountiesResult.data) {
            return {
                success: true,
                data: []
            };
        }
        
        const bounties = Object.values(bountiesResult.data)
            .sort((a, b) => b.createdAt - a.createdAt);
        
        const bountiesWithUser = [];
        for (const bounty of bounties) {
            const userResult = await dbGet(env, `users/${bounty.userId}`);
            const user = userResult.success ? userResult.data : null;
            
            bountiesWithUser.push({
                ...bounty,
                userName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.username || bounty.userId.substring(0, 6) : bounty.userId
            });
        }
        
        return {
            success: true,
            data: bountiesWithUser
        };
        
    } catch (error) {
        console.error('Admin get bounties error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'ADMIN_GET_BOUNTIES_ERROR'
        };
    }
}

async function handleAdminApproveBounty(env, userId, data) {
    try {
        if (!ADMIN_IDS.includes(userId)) {
            return {
                success: false,
                error: 'Unauthorized',
                errorCode: 'UNAUTHORIZED'
            };
        }
        
        const { bountyId, reward } = data;
        
        if (!bountyId) {
            return {
                success: false,
                error: 'Bounty ID required',
                errorCode: 'INVALID_BOUNTY_ID'
            };
        }
        
        const rewardAmount = parseFloat(reward);
        if (!rewardAmount || rewardAmount < GAME_CONSTANTS.BOUNTY_MIN_REWARD || rewardAmount > GAME_CONSTANTS.BOUNTY_MAX_REWARD) {
            return {
                success: false,
                error: `Reward must be between ${GAME_CONSTANTS.BOUNTY_MIN_REWARD} and ${GAME_CONSTANTS.BOUNTY_MAX_REWARD} TON`,
                errorCode: 'INVALID_REWARD'
            };
        }
        
        const bountyResult = await dbGet(env, `bounties/${bountyId}`);
        
        if (!bountyResult.success || !bountyResult.data) {
            return {
                success: false,
                error: 'Bounty not found',
                errorCode: 'BOUNTY_NOT_FOUND'
            };
        }
        
        const bounty = bountyResult.data;
        
        if (bounty.status !== 'pending') {
            return {
                success: false,
                error: `Bounty is already ${bounty.status}`,
                errorCode: 'BOUNTY_ALREADY_PROCESSED'
            };
        }
        
        const now = Date.now();
        
        await dbUpdate(env, `bounties/${bountyId}`, {
            status: 'approved',
            reward: rewardAmount,
            reviewedAt: now,
            updatedAt: now
        });
        
        await dbUpdate(env, `users/${bounty.userId}/bounties/${bountyId}`, {
            status: 'approved',
            reward: rewardAmount,
            reviewedAt: now,
            updatedAt: now
        });
        
        const userResult = await dbGet(env, `users/${bounty.userId}`);
        if (userResult.success && userResult.data) {
            const user = userResult.data;
            await dbUpdate(env, `users/${bounty.userId}`, {
                tonBalance: (user.tonBalance || 0) + rewardAmount,
                updatedAt: now
            });
        }
        
        await dbPush(env, `users/${bounty.userId}/transactions`, {
            type: 'bounty_reward',
            bountyId: bountyId,
            amount: rewardAmount,
            timestamp: now
        });
        
        await notifyBountyApproved(env, bounty.userId, rewardAmount);
        
        return {
            success: true,
            data: {
                bountyId: bountyId,
                status: 'approved',
                reward: rewardAmount
            }
        };
        
    } catch (error) {
        console.error('Admin approve bounty error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'ADMIN_APPROVE_BOUNTY_ERROR'
        };
    }
}

async function handleAdminRejectBounty(env, userId, data) {
    try {
        if (!ADMIN_IDS.includes(userId)) {
            return {
                success: false,
                error: 'Unauthorized',
                errorCode: 'UNAUTHORIZED'
            };
        }
        
        const { bountyId, reason } = data;
        
        if (!bountyId) {
            return {
                success: false,
                error: 'Bounty ID required',
                errorCode: 'INVALID_BOUNTY_ID'
            };
        }
        
        const bountyResult = await dbGet(env, `bounties/${bountyId}`);
        
        if (!bountyResult.success || !bountyResult.data) {
            return {
                success: false,
                error: 'Bounty not found',
                errorCode: 'BOUNTY_NOT_FOUND'
            };
        }
        
        const bounty = bountyResult.data;
        
        if (bounty.status !== 'pending') {
            return {
                success: false,
                error: `Bounty is already ${bounty.status}`,
                errorCode: 'BOUNTY_ALREADY_PROCESSED'
            };
        }
        
        const now = Date.now();
        
        await dbUpdate(env, `bounties/${bountyId}`, {
            status: 'rejected',
            rejectReason: reason || 'Not meeting requirements',
            reviewedAt: now,
            updatedAt: now
        });
        
        await dbUpdate(env, `users/${bounty.userId}/bounties/${bountyId}`, {
            status: 'rejected',
            rejectReason: reason || 'Not meeting requirements',
            reviewedAt: now,
            updatedAt: now
        });
        
        await notifyBountyRejected(env, bounty.userId, reason);
        
        return {
            success: true,
            data: {
                bountyId: bountyId,
                status: 'rejected',
                reason: reason
            }
        };
        
    } catch (error) {
        console.error('Admin reject bounty error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'ADMIN_REJECT_BOUNTY_ERROR'
        };
    }
}

// ============================================
// INITIALIZATION HANDLER
// ============================================

async function handleInitializeUser(env, userId, data) {
    try {
        const { startParam, userInfo } = data;
        
        let referredBy = null;
        if (startParam) {
            referredBy = extractReferrerFromStartParam(startParam);
            console.log('Extracted referrer:', referredBy, 'from startParam:', startParam);
        }
        
        const existingUser = await dbGet(env, `users/${userId}`);
        
        if (existingUser.success && existingUser.data) {
            console.log('User already exists:', userId);
            
            if (userInfo) {
                const updates = {};
                if (userInfo.first_name) updates.firstName = userInfo.first_name;
                if (userInfo.last_name) updates.lastName = userInfo.last_name;
                if (userInfo.username) updates.username = userInfo.username;
                if (userInfo.photo_url) updates.photoUrl = userInfo.photo_url;
                
                if (Object.keys(updates).length > 0) {
                    updates.updatedAt = Date.now();
                    await dbUpdate(env, `users/${userId}`, updates);
                    
                    if (existingUser.data.referredBy) {
                        await dbUpdate(env, `users/${existingUser.data.referredBy}/referrals/${userId}`, {
                            firstName: updates.firstName || existingUser.data.firstName,
                            lastName: updates.lastName || existingUser.data.lastName,
                            username: updates.username || existingUser.data.username,
                            photoUrl: updates.photoUrl || existingUser.data.photoUrl
                        });
                    }
                }
            }
            
            return {
                success: true,
                data: {
                    message: 'User already exists',
                    user: existingUser.data,
                    referredBy: existingUser.data.referredBy
                }
            };
        }
        
        console.log('Creating new user:', userId, 'referred by:', referredBy);
        
        const userData = await initializeUser(env, userId, userInfo || {}, startParam);
        
        return {
            success: true,
            data: {
                message: 'User initialized successfully',
                user: userData,
                referredBy: referredBy
            }
        };
        
    } catch (error) {
        console.error('Initialize user error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'INIT_USER_ERROR'
        };
    }
}

// ============================================
// LANGUAGE HANDLING
// ============================================

async function handleSetLanguage(env, userId, data) {
    try {
        const { language } = data;
        
        if (!['en', 'ru'].includes(language)) {
            return {
                success: false,
                error: 'Invalid language. Supported: en, ru',
                errorCode: 'INVALID_LANGUAGE'
            };
        }
        
        const userResult = await dbGet(env, `users/${userId}`);
        
        if (!userResult.success || !userResult.data) {
            return {
                success: false,
                error: 'User not found',
                errorCode: 'USER_NOT_FOUND'
            };
        }
        
        await dbUpdate(env, `users/${userId}`, {
            language: language,
            updatedAt: Date.now()
        });
        
        return {
            success: true,
            data: {
                language: language,
                message: language === 'en' ? 'Language set to English' : 'Ğ¯Ğ·Ñ‹Ğº Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½ Ğ½Ğ° Ğ ÑƒÑÑĞºĞ¸Ğ¹'
            }
        };
        
    } catch (error) {
        console.error('Set language error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'SET_LANGUAGE_ERROR'
        };
    }
}

// ============================================
// GET STATE - MAIN STATE FUNCTION
// ============================================

async function handleGetState(env, userId) {
    try {
        const userResult = await dbGet(env, `users/${userId}`);
        const globalResult = await dbGet(env, 'global');
        
        let global = globalResult.data;
        
        if (!global) {
            global = await initializeGlobalState(env);
        }
        
        let user = userResult.data;
        
        if (user) {
            const productionResult = await calculateProduction(env, userId, user);
            
            if (productionResult) {
                user = productionResult.user;
            }
        } else {
            user = {
                tonBalance: 0,
                milk: 0,
                eggs: 0,
                diamond: 0,
                cows_owned: 0,
                chickens_owned: 0,
                diamond_engines_owned: 0,
                lastProduction: Date.now(),
                milkPerHour: 0,
                eggsPerHour: 0,
                secondsUntilNext: 0,
                referralCode: null,
                referredBy: null,
                referralEarnings: 0,
                referralEarningsClaimed: 0,
                language: 'en',
                firstName: '',
                lastName: '',
                username: '',
                photoUrl: '',
                activeOrdersCount: 0,
                completedTasks: []
            };
        }
        
        let referralStats = {
            totalReferrals: 0,
            totalEarnings: 0,
            recentReferrals: [],
            recentEarnings: []
        };
        
        const referralsResult = await dbGet(env, `users/${userId}/referrals`);
        
        if (referralsResult.success && referralsResult.data) {
            const referralsObj = referralsResult.data;
            const referrals = Object.entries(referralsObj).map(([key, value]) => ({
                id: key,
                userId: value.userId,
                firstName: value.firstName || 'Farmer',
                lastName: value.lastName || '',
                username: value.username || '',
                photoUrl: value.photoUrl || '',
                joinedAt: value.joinedAt,
                totalEarnedFromThisUser: value.totalEarnedFromThisUser || 0,
                lastPurchase: value.lastPurchase
            }));
            
            referralStats.totalReferrals = referrals.length;
            
            referralStats.recentReferrals = referrals
                .sort((a, b) => (b.joinedAt || 0) - (a.joinedAt || 0))
                .slice(0, 50);
        }
        
        const earningsResult = await dbGet(env, `users/${userId}/referralEarnings`);
        
        if (earningsResult.success && earningsResult.data) {
            const earningsObj = earningsResult.data;
            const earnings = Object.values(earningsObj);
            referralStats.totalEarnings = earnings.reduce((sum, e) => sum + parseFloat(e.amount || 0), 0);
            
            const recentEarnings = earnings
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, 50);
            
            referralStats.recentEarnings = recentEarnings;
        }
        
        let pendingDeposits = [];
        
        const depositsResult = await dbGet(env, `users/${userId}/deposits`);
        
        if (depositsResult.success && depositsResult.data) {
            pendingDeposits = Object.values(depositsResult.data)
                .filter(d => d.status === 'pending' || d.status === 'verifying')
                .map(d => ({
                    depositId: d.id,
                    amount: d.amount,
                    timestamp: d.createdAt,
                    status: d.status,
                    txHash: d.txHash
                }))
                .slice(0, 3);
        }
        
        let activeOrdersCount = 0;
        
        const ordersResult = await dbGet(env, `users/${userId}/orders`);
        
        if (ordersResult.success && ordersResult.data) {
            activeOrdersCount = Object.values(ordersResult.data)
                .filter(o => o.status === 'active')
                .length;
        }
        
        let marketStats = {
            milk: { sellOrders: 0, buyOrders: 0, bestSellPrice: 0, bestBuyPrice: 0, totalMilk: 0, totalEggs: 0 },
            eggs: { sellOrders: 0, buyOrders: 0, bestSellPrice: 0, bestBuyPrice: 0 }
        };
        
        const marketOrdersResult = await dbGet(env, 'orders');
        
        if (marketOrdersResult.success && marketOrdersResult.data) {
            const allOrders = Object.values(marketOrdersResult.data);
            
            const milkSellOrders = allOrders.filter(o => 
                o.resource === 'milk' && o.type === 'sell' && o.status === 'active');
            
            marketStats.milk.sellOrders = milkSellOrders.length;
            marketStats.milk.totalMilk = milkSellOrders.reduce((sum, o) => sum + o.remaining, 0);
            
            if (milkSellOrders.length > 0) {
                marketStats.milk.bestSellPrice = Math.min(...milkSellOrders.map(o => o.pricePerUnit));
            }
            
            const milkBuyOrders = allOrders.filter(o => 
                o.resource === 'milk' && o.type === 'buy' && o.status === 'active');
            
            marketStats.milk.buyOrders = milkBuyOrders.length;
            
            if (milkBuyOrders.length > 0) {
                marketStats.milk.bestBuyPrice = Math.max(...milkBuyOrders.map(o => o.pricePerUnit));
            }
            
            const eggSellOrders = allOrders.filter(o => 
                o.resource === 'eggs' && o.type === 'sell' && o.status === 'active');
            
            marketStats.eggs.sellOrders = eggSellOrders.length;
            marketStats.eggs.totalEggs = eggSellOrders.reduce((sum, o) => sum + o.remaining, 0);
            
            if (eggSellOrders.length > 0) {
                marketStats.eggs.bestSellPrice = Math.min(...eggSellOrders.map(o => o.pricePerUnit));
            }
            
            const eggBuyOrders = allOrders.filter(o => 
                o.resource === 'eggs' && o.type === 'buy' && o.status === 'active');
            
            marketStats.eggs.buyOrders = eggBuyOrders.length;
            
            if (eggBuyOrders.length > 0) {
                marketStats.eggs.bestBuyPrice = Math.max(...eggBuyOrders.map(o => o.pricePerUnit));
            }
        }
        
        const tasksResult = await handleGetTasks(env, userId);
        let tasks = tasksResult.success ? tasksResult.data : { partner: [], community: [] };
        
        const bountiesResult = await handleGetUserBounties(env, userId);
        let bounties = bountiesResult.success ? bountiesResult.data : [];
        
        const milkPerHour = (user.cows_owned || 0) * GAME_CONSTANTS.COW_PRODUCTION_RATE;
        const eggsPerHour = (user.chickens_owned || 0) * GAME_CONSTANTS.CHICKEN_PRODUCTION_RATE;
        
        const lastProduction = user.lastProduction || Date.now();
        const nextProduction = lastProduction + GAME_CONSTANTS.HOUR_IN_MS;
        const msUntilNext = Math.max(0, nextProduction - Date.now());
        const secondsUntilNext = Math.floor(msUntilNext / 1000);
        const minutesUntilNext = Math.floor(secondsUntilNext / 60);
        const secondsRemaining = secondsUntilNext % 60;
        
        return {
            success: true,
            data: {
                user: {
                    tonBalance: parseFloat(user.tonBalance || 0),
                    milk: parseFloat(user.milk || 0),
                    eggs: parseFloat(user.eggs || 0),
                    diamond: parseFloat(user.diamond || 0),
                    
                    cows_owned: user.cows_owned || 0,
                    chickens_owned: user.chickens_owned || 0,
                    diamond_engines_owned: user.diamond_engines_owned || 0,
                    
                    milkPerHour: milkPerHour,
                    eggsPerHour: eggsPerHour,
                    
                    lastProduction: user.lastProduction,
                    secondsUntilNext: secondsUntilNext,
                    minutesUntilNext: minutesUntilNext,
                    secondsRemaining: secondsRemaining,
                    
                    referralCode: user.referralCode,
                    referredBy: user.referredBy,
                    referralEarnings: parseFloat(user.referralEarnings || 0),
                    referralEarningsClaimed: parseFloat(user.referralEarningsClaimed || 0),
                    
                    language: user.language || 'en',
                    firstName: user.firstName || '',
                    lastName: user.lastName || '',
                    username: user.username || '',
                    photoUrl: user.photoUrl || '',
                    
                    activeOrdersCount: activeOrdersCount,
                    completedTasks: user.completedTasks || []
                },
                
                global: {
                    cows_sold: global.cows_sold || 0,
                    cows_cap: GAME_CONSTANTS.COW_GLOBAL_CAP,
                    cows_remaining: Math.max(0, GAME_CONSTANTS.COW_GLOBAL_CAP - (global.cows_sold || 0)),
                    cows_progress: ((global.cows_sold || 0) / GAME_CONSTANTS.COW_GLOBAL_CAP) * 100,
                    
                    chickens_sold: global.chickens_sold || 0,
                    chickens_cap: GAME_CONSTANTS.CHICKEN_GLOBAL_CAP,
                    chickens_remaining: Math.max(0, GAME_CONSTANTS.CHICKEN_GLOBAL_CAP - (global.chickens_sold || 0)),
                    chickens_progress: ((global.chickens_sold || 0) / GAME_CONSTANTS.CHICKEN_GLOBAL_CAP) * 100,
                    
                    chicken_unlocked: (global.cows_sold || 0) >= GAME_CONSTANTS.COW_GLOBAL_CAP,
                    diamond_unlocked: (global.cows_sold || 0) >= GAME_CONSTANTS.COW_GLOBAL_CAP && 
                                    (global.chickens_sold || 0) >= GAME_CONSTANTS.CHICKEN_GLOBAL_CAP,
                    
                    diamond_price: global.diamond_price || GAME_CONSTANTS.DIAMOND_BASE_PRICE,
                    
                    cows_until_chicken: Math.max(0, GAME_CONSTANTS.COW_GLOBAL_CAP - (global.cows_sold || 0)),
                    chickens_until_diamond: Math.max(0, GAME_CONSTANTS.CHICKEN_GLOBAL_CAP - (global.chickens_sold || 0))
                },
                
                constants: {
                    COW_PRICE: GAME_CONSTANTS.COW_PRICE,
                    COW_PRODUCTION_RATE: GAME_CONSTANTS.COW_PRODUCTION_RATE,
                    COW_HATCH_COST: GAME_CONSTANTS.COW_HATCH_COST,
                    
                    CHICKEN_PRICE: GAME_CONSTANTS.CHICKEN_PRICE,
                    CHICKEN_PRODUCTION_RATE: GAME_CONSTANTS.CHICKEN_PRODUCTION_RATE,
                    CHICKEN_HATCH_COST: GAME_CONSTANTS.CHICKEN_HATCH_COST,
                    
                    DIAMOND_ENGINE_PRICE: GAME_CONSTANTS.DIAMOND_ENGINE_PRICE,
                    DIAMOND_PRODUCTION_COST_MILK: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_MILK,
                    DIAMOND_PRODUCTION_COST_EGG: GAME_CONSTANTS.DIAMOND_PRODUCTION_COST_EGG,
                    
                    MIN_WITHDRAW_AMOUNT: GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT,
                    WITHDRAW_FEE_PERCENT: GAME_CONSTANTS.WITHDRAW_FEE_PERCENT,
                    MIN_DEPOSIT_AMOUNT: GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT,
                    REFERRAL_REWARD_PERCENT: GAME_CONSTANTS.REFERRAL_REWARD_PERCENT,
                    MIN_ORDER_AMOUNT: GAME_CONSTANTS.MIN_ORDER_AMOUNT,
                    MARKET_FEE_PERCENT: GAME_CONSTANTS.MARKET_FEE_PERCENT,
                    TASK_REWARD: GAME_CONSTANTS.TASK_REWARD,
                    
                    BOUNTY_MIN_REWARD: GAME_CONSTANTS.BOUNTY_MIN_REWARD,
                    BOUNTY_MAX_REWARD: GAME_CONSTANTS.BOUNTY_MAX_REWARD,
                    BOUNTY_MIN_FOLLOWERS: GAME_CONSTANTS.BOUNTY_MIN_FOLLOWERS,
                    MIN_TASK_TARGET: GAME_CONSTANTS.MIN_TASK_TARGET,
                    
                    MAX_RETRY_ATTEMPTS: GAME_CONSTANTS.MAX_RETRY_ATTEMPTS
                },
                
                referral: referralStats,
                market: marketStats,
                tasks: tasks,
                bounties: bounties,
                pendingDeposits: pendingDeposits
            }
        };
        
    } catch (error) {
        console.error('Get state error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_STATE_ERROR'
        };
    }
}
