// SquidPEPE Game Engine - Complete Version with Deposit/Withdraw
export default {
    async fetch(request, env, ctx) {
        // إعداد CORS
        if (request.method === 'OPTIONS') {
            return new Response(null, {
                headers: {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type, X-User-ID, X-Telegram-Data, X-Action, Authorization',
                }
            });
        }
        
        const url = new URL(request.url);
        const path = url.pathname;
        
        // التحقق من المسار
        if (path !== '/api' && path !== '/getDepositInfo' && path !== '/process-deposit') {
            return new Response(JSON.stringify({
                success: false,
                error: 'Invalid endpoint'
            }), {
                status: 404,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        // معالجة طلب معلومات الإيداع (القديم - للتوافق)
        if (path === '/getDepositInfo') {
            return handleGetDepositInfo(request, env);
        }
        
        // معالجة إيداع من الـ watcher
        if (path === '/process-deposit') {
            return handleProcessDeposit(request, env);
        }
        
        // للمسار /api - التحقق من المصادقة أولاً
        try {
            // استخراج بيانات Telegram من Authorization header
            const authHeader = request.headers.get('Authorization');
            
            // التحقق من وجود header المصادقة
            if (!authHeader?.startsWith('Telegram ')) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Telegram authentication required',
                    errorCode: 'AUTH_REQUIRED',
                    message: 'يجب فتح اللعبة داخل تطبيق Telegram'
                }), {
                    status: 401,
                    headers: { 
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
            }
            
            const initData = authHeader.replace('Telegram ', '');
            
            // التحقق من بيانات Telegram باستخدام HMAC
            if (!validateTelegramInitData(initData, env.BOT_TOKEN)) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'Invalid Telegram authentication',
                    errorCode: 'INVALID_TELEGRAM_AUTH',
                    message: 'مصادقة Telegram غير صالحة'
                }), {
                    status: 401,
                    headers: { 
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
            }
            
            // استخراج userId من بيانات Telegram
            const params = new URLSearchParams(initData);
            const userParam = params.get('user');
            if (!userParam) {
                return new Response(JSON.stringify({
                    success: false,
                    error: 'User data not found',
                    errorCode: 'USER_DATA_MISSING'
                }), {
                    status: 401,
                    headers: { 
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    }
                });
            }
            
            const userData = JSON.parse(decodeURIComponent(userParam));
            const userId = String(userData.id);
            
            // استخراج البيانات من الطلب
            const requestData = await request.json();
            const action = request.headers.get('X-Action') || requestData.action;
            const data = requestData.data || {};
            
            console.log(`Request received: action=${action}, userId=${userId}`);
            
            // معالجة الإجراءات
            let result;
            switch (action) {
                case 'getState':
                    result = await handleGetState(env, userId);
                    break;
                    
                case 'mintSquids':
                    result = await handleMintSquids(env, userId, data);
                    break;
                    
                case 'hatchSquids':
                    result = await handleHatchSquids(env, userId, data);
                    break;
                    
                case 'createOrder':
                    result = await handleCreateOrder(env, userId, data);
                    break;
                    
                case 'buyOrder':
                    result = await handleBuyOrder(env, userId, data);
                    break;
                    
                case 'withdrawTON':
                    result = await handleWithdrawTON(env, userId, data);
                    break;
                    
                case 'deposit/init':
                    result = await handleInitDeposit(env, userId, data);
                    break;
                    
                case 'checkDeposit':
                    result = await handleCheckDeposit(env, userId, data);
                    break;
                    
                case 'initializeUser':
                    result = await initializeUserHandler(env, userId, data);
                    break;
                    
                default:
                    result = {
                        success: false,
                        error: 'Unknown action',
                        errorCode: 'UNKNOWN_ACTION'
                    };
            }
            
            // إرجاع النتيجة
            return new Response(JSON.stringify(result), {
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
            
        } catch (error) {
            console.error('Worker error:', error);
            
            return new Response(JSON.stringify({
                success: false,
                error: 'Internal server error',
                errorCode: 'INTERNAL_SERVER_ERROR',
                details: error.message
            }), {
                status: 500,
                headers: { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                }
            });
        }
    }
};

// ==================== Global Constants ====================

const GAME_CONSTANTS = {
    MINT_RATE: 3000, // 1 TON = 3000 Squids
    MINT_GLOBAL_CAP: 90000000, // 90 مليون سكويد كحد أقصى للـ Mint
    DAILY_EGG_CAP: 30000000, // 30 مليون بيضة يومياً كحد أقصى
    MIN_HATCH_AMOUNT: 100, // الحد الأدنى للفقس
    HATCH_FEE_PERCENT: 5, // رسوم الحرف 5%
    MARKET_SELLER_FEE_PERCENT: 5, // رسوم البائع 5% TON
    MARKET_BUYER_FEE_PERCENT: 5, // رسوم المشتري 5% Eggs
    MIN_WITHDRAW_AMOUNT: 0.1, // الحد الأدنى للسحب 0.1 TON
    WITHDRAW_FEE_PERCENT: 5, // رسوم السحب 5%
    REFERRAL_MINT_REWARD_PERCENT: 10, // 10% من TON للمُحيل
    REFERRAL_HATCH_REWARD_PERCENT: 5, // 5% من البيض للمُحيل
    MIN_ORDER_AMOUNT: 100, // الحد الأدنى للطلب في السوق
    MIN_DEPOSIT_AMOUNT: 0.1 // الحد الأدنى للإيداع
};

// ==================== Main Handlers ====================

// Get Game State
async function handleGetState(env, userId) {
    try {
        const [globalState, userState] = await Promise.all([
            handleDbGet(env, 'game/global'),
            handleDbGet(env, `users/${userId}`)
        ]);
        
        const global = globalState.data || await initializeGlobalState(env);
        const user = userState.data || await initializeUser(env, userId);
        
        // مزامنة البيض المنتج
        const syncedUser = await syncEggs(user, global, env, userId);
        
        // حساب البيض المتاحة اليوم
        const eggProduction = calculateDailyEggProduction(global);
        const availableEggs = Math.max(0, eggProduction - (global.totalEggsToday || 0));
        
        // حساب نسبة المستخدم من البيض المتاحة
        const userSquids = syncedUser.squids || 0;
        const totalSquids = global.totalSquids || 1;
        const userEggShare = userSquids / totalSquids;
        const userDailyEggs = Math.floor(availableEggs * userEggShare);
        
        // حساب إنتاج البيض اليومي للمستخدم
        const eggsPerDay = Math.floor(eggProduction * userEggShare);
        
        // تحديث إذا كان الوقت مر
        const now = Date.now();
        if (now - (syncedUser.lastEggCalc || 0) > 60000) {
            await updateUserEggs(env, userId, syncedUser);
        }
        
        return {
            success: true,
            data: {
                user: {
                    squids: syncedUser.squids || 0,
                    eggs: syncedUser.eggs || 0,
                    tonBalance: syncedUser.tonBalance || 0,
                    mintUsed: syncedUser.mintUsed || false,
                    mintedSquids: syncedUser.mintedSquids || 0,
                    referralCode: syncedUser.referralCode || generateReferralCode(userId),
                    referredBy: syncedUser.referredBy || null,
                    eggsPerDay: eggsPerDay,
                    lastEggCalc: syncedUser.lastEggCalc || now
                },
                global: {
                    totalSquids: global.totalSquids || 0,
                    mintedSoFar: global.mintedSoFar || 0,
                    dailyEggCap: GAME_CONSTANTS.DAILY_EGG_CAP,
                    totalEggsToday: global.totalEggsToday || 0,
                    lastDailyReset: global.lastDailyReset || now,
                    eggProduction: eggProduction,
                    availableEggs: availableEggs
                },
                constants: GAME_CONSTANTS,
                marketStats: await getMarketStats(env)
            }
        };
    } catch (error) {
        console.error('Get state error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'GET_STATE_ERROR'
        };
    }
}

// Mint Squids
async function handleMintSquids(env, userId, data) {
    try {
        const { referredBy } = data;
        
        // التحقق من أن المستخدم لم يسبق له الـ Mint
        const userResult = await handleDbGet(env, `users/${userId}`);
        const user = userResult.data || await initializeUser(env, userId);
        
        if (user.mintUsed) {
            return {
                success: false,
                error: 'You can only mint once per account',
                errorCode: 'MINT_ALREADY_USED'
            };
        }
        
        // التحقق من الحد العالمي
        const globalResult = await handleDbGet(env, 'game/global');
        const global = globalResult.data || await initializeGlobalState(env);
        
        const squidsToMint = GAME_CONSTANTS.MINT_RATE;
        if (global.mintedSoFar + squidsToMint > GAME_CONSTANTS.MINT_GLOBAL_CAP) {
            return {
                success: false,
                error: 'Global mint cap reached',
                errorCode: 'GLOBAL_MINT_CAP_REACHED'
            };
        }
        
        // تحديث المستخدم
        const userUpdates = {
            squids: (user.squids || 0) + squidsToMint,
            mintUsed: true,
            mintedSquids: squidsToMint,
            lastUpdated: Date.now()
        };
        
        // إعداد الإحالة إذا كانت موجودة
        let referralReward = 0;
        if (referredBy && referredBy !== userId) {
            const referrerResult = await handleDbGet(env, `users/${referredBy}`);
            if (referrerResult.success && referrerResult.data) {
                const referrer = referrerResult.data;
                referralReward = 1 * (GAME_CONSTANTS.REFERRAL_MINT_REWARD_PERCENT / 100);
                
                // تحديث المُحيل
                await handleDbUpdate(env, `users/${referredBy}`, {
                    tonBalance: (referrer.tonBalance || 0) + referralReward,
                    lastUpdated: Date.now()
                });
                
                // تسجيل الإحالة
                await handleDbPush(env, `users/${referredBy}/referrals`, {
                    userId: userId,
                    type: 'mint',
                    reward: referralReward,
                    timestamp: Date.now()
                });
                
                userUpdates.referredBy = referredBy;
            }
        }
        
        // تحديث العالم
        const globalUpdates = {
            totalSquids: (global.totalSquids || 0) + squidsToMint,
            mintedSoFar: (global.mintedSoFar || 0) + squidsToMint,
            lastUpdated: Date.now()
        };
        
        // تطبيق التحديثات
        await Promise.all([
            handleDbUpdate(env, `users/${userId}`, userUpdates),
            handleDbUpdate(env, 'game/global', globalUpdates)
        ]);
        
        // تسجيل العملية
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'mint',
            amount: squidsToMint,
            referralReward: referralReward,
            timestamp: Date.now()
        });
        
        return {
            success: true,
            data: {
                mintedSquids: squidsToMint,
                newSquids: userUpdates.squids,
                referralReward: referralReward,
                globalMinted: globalUpdates.mintedSoFar
            }
        };
    } catch (error) {
        console.error('Mint squids error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'MINT_SQUIDS_ERROR'
        };
    }
}

// Hatch Squids from Eggs
async function handleHatchSquids(env, userId, data) {
    try {
        const { amount } = data;
        const eggsToHatch = parseInt(amount);
        
        // التحقق من البيانات
        if (!eggsToHatch || eggsToHatch < GAME_CONSTANTS.MIN_HATCH_AMOUNT) {
            return {
                success: false,
                error: `Minimum hatch amount is ${GAME_CONSTANTS.MIN_HATCH_AMOUNT} eggs`,
                errorCode: 'INVALID_HATCH_AMOUNT'
            };
        }
        
        // جلب بيانات المستخدم والعالم
        const [userResult, globalResult] = await Promise.all([
            handleDbGet(env, `users/${userId}`),
            handleDbGet(env, 'game/global')
        ]);
        
        const user = userResult.data || await initializeUser(env, userId);
        const global = globalResult.data || await initializeGlobalState(env);
        
        // مزامنة البيض أولاً
        const syncedUser = await syncEggs(user, global, env, userId);
        
        // التحقق من الرصيد الكافي
        const userEggs = syncedUser.eggs || 0;
        if (userEggs < eggsToHatch) {
            return {
                success: false,
                error: 'Insufficient eggs',
                errorCode: 'INSUFFICIENT_EGGS'
            };
        }
        
        // حساب الرسوم والإنتاج (5% رسوم)
        const fee = Math.ceil(eggsToHatch * (GAME_CONSTANTS.HATCH_FEE_PERCENT / 100));
        const totalEggsNeeded = eggsToHatch + fee;
        
        // التحقق مرة أخرى مع الرسوم
        if (userEggs < totalEggsNeeded) {
            return {
                success: false,
                error: `Need ${totalEggsNeeded} eggs (including ${fee} fee)`,
                errorCode: 'INSUFFICIENT_EGGS_WITH_FEE'
            };
        }
        
        // تحديث المستخدم
        const userUpdates = {
            eggs: userEggs - totalEggsNeeded,
            squids: (syncedUser.squids || 0) + eggsToHatch,
            lastEggCalc: Date.now(),
            lastUpdated: Date.now()
        };
        
        // تحديث العالم
        const globalUpdates = {
            totalSquids: (global.totalSquids || 0) + eggsToHatch,
            totalEggsToday: (global.totalEggsToday || 0) + totalEggsNeeded,
            lastUpdated: Date.now()
        };
        
        // مكافأة الإحالة
        let referralReward = 0;
        if (syncedUser.referredBy) {
            const referrerResult = await handleDbGet(env, `users/${syncedUser.referredBy}`);
            if (referrerResult.success && referrerResult.data) {
                const referrer = referrerResult.data;
                referralReward = eggsToHatch * (GAME_CONSTANTS.REFERRAL_HATCH_REWARD_PERCENT / 100);
                
                // تحديث بيض المُحيل
                const syncedReferrer = await syncEggs(referrer, global, env, syncedUser.referredBy);
                
                await handleDbUpdate(env, `users/${syncedUser.referredBy}`, {
                    eggs: (syncedReferrer.eggs || 0) + referralReward,
                    lastEggCalc: Date.now(),
                    lastUpdated: Date.now()
                });
                
                // تسجيل الإحالة
                await handleDbPush(env, `users/${syncedUser.referredBy}/referrals`, {
                    userId: userId,
                    type: 'hatch',
                    eggsReward: referralReward,
                    timestamp: Date.now()
                });
            }
        }
        
        // تطبيق التحديثات
        await Promise.all([
            handleDbUpdate(env, `users/${userId}`, userUpdates),
            handleDbUpdate(env, 'game/global', globalUpdates)
        ]);
        
        // تسجيل العملية
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'hatch',
            eggsUsed: eggsToHatch,
            fee: fee,
            squidsProduced: eggsToHatch,
            referralReward: referralReward,
            timestamp: Date.now()
        });
        
        return {
            success: true,
            data: {
                eggsUsed: eggsToHatch,
                fee: fee,
                squidsProduced: eggsToHatch,
                newSquids: userUpdates.squids,
                newEggs: userUpdates.eggs,
                referralReward: referralReward,
                totalSquids: globalUpdates.totalSquids
            }
        };
    } catch (error) {
        console.error('Hatch squids error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'HATCH_SQUIDS_ERROR'
        };
    }
}

// Create Market Order
async function handleCreateOrder(env, userId, data) {
    try {
        const { type, price, amount } = data;
        
        // التحقق من البيانات
        if (!['sell', 'buy'].includes(type)) {
            return {
                success: false,
                error: 'Invalid order type. Must be "sell" or "buy"',
                errorCode: 'INVALID_ORDER_TYPE'
            };
        }
        
        if (!price || parseFloat(price) <= 0) {
            return {
                success: false,
                error: 'Invalid price',
                errorCode: 'INVALID_PRICE'
            };
        }
        
        const orderAmount = parseInt(amount);
        if (!orderAmount || orderAmount < GAME_CONSTANTS.MIN_ORDER_AMOUNT) {
            return {
                success: false,
                error: `Minimum order amount is ${GAME_CONSTANTS.MIN_ORDER_AMOUNT}`,
                errorCode: 'INVALID_ORDER_AMOUNT'
            };
        }
        
        // جلب بيانات المستخدم والعالم
        const [userResult, globalResult] = await Promise.all([
            handleDbGet(env, `users/${userId}`),
            handleDbGet(env, 'game/global')
        ]);
        
        const user = userResult.data || await initializeUser(env, userId);
        const global = globalResult.data || await initializeGlobalState(env);
        
        // مزامنة البيض أولاً
        const syncedUser = await syncEggs(user, global, env, userId);
        
        // التحقق من الرصيد الكافي
        if (type === 'sell') {
            // بيع بيض
            if ((syncedUser.eggs || 0) < orderAmount) {
                return {
                    success: false,
                    error: 'Insufficient eggs',
                    errorCode: 'INSUFFICIENT_EGGS'
                };
            }
        } else {
            // شراء بيض
            const totalCost = orderAmount * parseFloat(price);
            if ((syncedUser.tonBalance || 0) < totalCost) {
                return {
                    success: false,
                    error: 'Insufficient TON balance',
                    errorCode: 'INSUFFICIENT_TON_BALANCE'
                };
            }
        }
        
        // تجميد الأصول وإنشاء الطلب
        const orderId = `order_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        const orderData = {
            id: orderId,
            userId: userId,
            type: type,
            price: parseFloat(price),
            amount: orderAmount,
            remaining: orderAmount,
            status: 'active',
            createdAt: Date.now(),
            lastUpdated: Date.now()
        };
        
        // حفظ الطلب
        await handleDbSet(env, `market/orders/${orderId}`, orderData);
        
        // تجميد الأصول
        const userUpdates = {};
        if (type === 'sell') {
            userUpdates.eggs = (syncedUser.eggs || 0) - orderAmount;
        } else {
            userUpdates.tonBalance = (syncedUser.tonBalance || 0) - (orderAmount * parseFloat(price));
        }
        userUpdates.lastUpdated = Date.now();
        
        await handleDbUpdate(env, `users/${userId}`, userUpdates);
        
        // تسجيل الطلب المجمد
        await handleDbSet(env, `users/${userId}/frozenAssets/${orderId}`, {
            type: type,
            amount: orderAmount,
            price: parseFloat(price),
            frozenAt: Date.now()
        });
        
        return {
            success: true,
            data: {
                orderId: orderId,
                order: orderData,
                newBalance: type === 'sell' ? userUpdates.eggs : userUpdates.tonBalance
            }
        };
    } catch (error) {
        console.error('Create order error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'CREATE_ORDER_ERROR'
        };
    }
}

// Buy from Market Order
async function handleBuyOrder(env, userId, data) {
    try {
        const { orderId, amount } = data;
        
        // جلب بيانات الطلب
        const orderResult = await handleDbGet(env, `market/orders/${orderId}`);
        if (!orderResult.success || !orderResult.data) {
            return {
                success: false,
                error: 'Order not found',
                errorCode: 'ORDER_NOT_FOUND'
            };
        }
        
        const order = orderResult.data;
        
        // التحقق من حالة الطلب
        if (order.status !== 'active') {
            return {
                success: false,
                error: 'Order is not active',
                errorCode: 'ORDER_NOT_ACTIVE'
            };
        }
        
        if (order.type !== 'sell') {
            return {
                success: false,
                error: 'Can only buy from sell orders',
                errorCode: 'INVALID_ORDER_TYPE'
            };
        }
        
        const buyAmount = parseInt(amount) || order.remaining;
        if (buyAmount > order.remaining) {
            return {
                success: false,
                error: 'Order does not have enough remaining',
                errorCode: 'INSUFFICIENT_ORDER_AMOUNT'
            };
        }
        
        // جلب بيانات المشتري والبائع والعالم
        const [buyerResult, sellerResult, globalResult] = await Promise.all([
            handleDbGet(env, `users/${userId}`),
            handleDbGet(env, `users/${order.userId}`),
            handleDbGet(env, 'game/global')
        ]);
        
        const buyer = buyerResult.data || await initializeUser(env, userId);
        const seller = sellerResult.data || await initializeUser(env, order.userId);
        const global = globalResult.data || await initializeGlobalState(env);
        
        // مزامنة البيض للبائع
        const syncedSeller = await syncEggs(seller, global, env, order.userId);
        
        // حساب التكلفة والرسوم
        const totalCost = buyAmount * order.price;
        const sellerFee = totalCost * (GAME_CONSTANTS.MARKET_SELLER_FEE_PERCENT / 100);
        const buyerFee = buyAmount * (GAME_CONSTANTS.MARKET_BUYER_FEE_PERCENT / 100);
        
        const sellerReceives = totalCost - sellerFee;
        const buyerReceives = buyAmount - buyerFee;
        
        // التحقق من رصيد المشتري
        if ((buyer.tonBalance || 0) < totalCost) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON_BALANCE'
            };
        }
        
        // تنفيذ الصفقة
        const sellerUpdates = {
            tonBalance: (syncedSeller.tonBalance || 0) + sellerReceives,
            lastUpdated: Date.now()
        };
        
        const buyerUpdates = {
            tonBalance: (buyer.tonBalance || 0) - totalCost,
            eggs: (buyer.eggs || 0) + buyerReceives,
            lastUpdated: Date.now()
        };
        
        // تحديث الطلب
        const newRemaining = order.remaining - buyAmount;
        const orderUpdates = {
            remaining: newRemaining,
            status: newRemaining > 0 ? 'active' : 'filled',
            lastUpdated: Date.now()
        };
        
        // تطبيق التحديثات
        await Promise.all([
            handleDbUpdate(env, `users/${order.userId}`, sellerUpdates),
            handleDbUpdate(env, `users/${userId}`, buyerUpdates),
            handleDbUpdate(env, `market/orders/${orderId}`, orderUpdates)
        ]);
        
        // تحرير الأصول المجمدة للبائع إذا اكتمل الطلب
        if (newRemaining <= 0) {
            await handleDbSet(env, `users/${order.userId}/frozenAssets/${orderId}`, null);
        }
        
        // تسجيل المعاملة
        const txId = `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        await Promise.all([
            // سجل المشتري
            handleDbPush(env, `users/${userId}/history`, {
                type: 'market_buy',
                orderId: orderId,
                eggsBought: buyerReceives,
                tonPaid: totalCost,
                buyerFee: buyerFee,
                sellerId: order.userId,
                timestamp: Date.now(),
                txId: txId
            }),
            
            // سجل البائع
            handleDbPush(env, `users/${order.userId}/history`, {
                type: 'market_sell',
                orderId: orderId,
                eggsSold: buyAmount,
                tonReceived: sellerReceives,
                sellerFee: sellerFee,
                buyerId: userId,
                timestamp: Date.now(),
                txId: txId
            })
        ]);
        
        return {
            success: true,
            data: {
                txId: txId,
                eggsBought: buyerReceives,
                tonPaid: totalCost,
                fees: {
                    buyerFee: buyerFee,
                    sellerFee: sellerFee
                },
                newBuyerBalance: buyerUpdates.tonBalance,
                newBuyerEggs: buyerUpdates.eggs,
                newSellerBalance: sellerUpdates.tonBalance,
                orderRemaining: newRemaining,
                orderStatus: orderUpdates.status
            }
        };
    } catch (error) {
        console.error('Buy order error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'BUY_ORDER_ERROR'
        };
    }
}

// Withdraw TON
async function handleWithdrawTON(env, userId, data) {
    try {
        const { amount, address } = data;
        const withdrawAmount = parseFloat(amount);
        
        // التحقق من البيانات
        if (!withdrawAmount || withdrawAmount < GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT) {
            return {
                success: false,
                error: `Minimum withdrawal amount is ${GAME_CONSTANTS.MIN_WITHDRAW_AMOUNT} TON`,
                errorCode: 'INVALID_WITHDRAW_AMOUNT'
            };
        }
        
        if (!address || address.trim().length === 0) {
            return {
                success: false,
                error: 'TON address is required',
                errorCode: 'ADDRESS_REQUIRED'
            };
        }
        
        // جلب بيانات المستخدم
        const userResult = await handleDbGet(env, `users/${userId}`);
        const user = userResult.data || await initializeUser(env, userId);
        
        // حساب الرسوم والمبلغ النهائي
        const fee = withdrawAmount * (GAME_CONSTANTS.WITHDRAW_FEE_PERCENT / 100);
        const netAmount = withdrawAmount - fee;
        
        // التحقق من الرصيد الكافي (بما في ذلك الرسوم)
        if ((user.tonBalance || 0) < withdrawAmount) {
            return {
                success: false,
                error: 'Insufficient TON balance',
                errorCode: 'INSUFFICIENT_TON_BALANCE'
            };
        }
        
        // تحديث رصيد المستخدم
        const userUpdates = {
            tonBalance: (user.tonBalance || 0) - withdrawAmount,
            lastUpdated: Date.now()
        };
        
        await handleDbUpdate(env, `users/${userId}`, userUpdates);
        
        // تسجيل طلب السحب
        const withdrawalId = `withdraw_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        const withdrawalData = {
            id: withdrawalId,
            userId: userId,
            amount: withdrawAmount,
            fee: fee,
            netAmount: netAmount,
            address: address,
            status: 'pending',
            createdAt: Date.now(),
            lastUpdated: Date.now()
        };
        
        await handleDbSet(env, `withdrawals/pending/${withdrawalId}`, withdrawalData);
        
        // تسجيل في السجل
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'withdraw_request',
            amount: withdrawAmount,
            fee: fee,
            netAmount: netAmount,
            address: address,
            status: 'pending',
            timestamp: Date.now(),
            withdrawalId: withdrawalId
        });
        
        return {
            success: true,
            data: {
                withdrawalId: withdrawalId,
                amount: withdrawAmount,
                fee: fee,
                netAmount: netAmount,
                newBalance: userUpdates.tonBalance,
                message: 'Withdrawal request submitted. Will be processed within 24 hours.'
            }
        };
    } catch (error) {
        console.error('Withdraw TON error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'WITHDRAW_TON_ERROR'
        };
    }
}

// ==================== New Deposit/Withdraw Handlers ====================

// Initialize Deposit (New Method)
async function handleInitDeposit(env, userId, data) {
    try {
        const { amount, wallet_address } = data;
        
        // Validate amount
        if (!amount || amount < GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT) {
            return {
                success: false,
                error: `Minimum deposit amount is ${GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT} TON`,
                errorCode: 'MIN_DEPOSIT_AMOUNT'
            };
        }
        
        // Validate wallet address
        if (!wallet_address || wallet_address.length < 10) {
            return {
                success: false,
                error: 'Invalid wallet address',
                errorCode: 'INVALID_WALLET_ADDRESS'
            };
        }
        
        // Generate unique comment
        const comment = `deposit_${userId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        // Get deposit address from environment
        const depositAddress = env.DEPOSIT_WALLET_ADDRESS || "UQBnwSS4Kox3ZZmF69KxWLfvfCc2-dLV8sT5nJe-aV7HfCyG";
        
        // Store pending deposit
        const depositId = `deposit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const depositData = {
            id: depositId,
            userId: userId,
            amount: parseFloat(amount),
            walletAddress: wallet_address,
            depositAddress: depositAddress,
            comment: comment,
            status: 'pending',
            createdAt: Date.now(),
            lastUpdated: Date.now()
        };
        
        await handleDbSet(env, `deposits/pending/${depositId}`, depositData);
        
        // Also store by user for easy retrieval
        await handleDbPush(env, `users/${userId}/pendingDeposits`, {
            depositId: depositId,
            amount: amount,
            comment: comment,
            createdAt: Date.now()
        });
        
        return {
            success: true,
            data: {
                address: depositAddress,
                amount: amount,
                comment: comment,
                depositId: depositId
            }
        };
        
    } catch (error) {
        console.error('Init deposit error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'INIT_DEPOSIT_ERROR'
        };
    }
}

// Check Deposit Status
async function handleCheckDeposit(env, userId, data) {
    try {
        const { depositId } = data;
        
        if (!depositId) {
            return {
                success: false,
                error: 'Deposit ID is required',
                errorCode: 'DEPOSIT_ID_REQUIRED'
            };
        }
        
        // Get deposit record
        const depositResult = await handleDbGet(env, `deposits/pending/${depositId}`);
        if (!depositResult.success || !depositResult.data) {
            return {
                success: false,
                error: 'Deposit not found',
                errorCode: 'DEPOSIT_NOT_FOUND'
            };
        }
        
        const deposit = depositResult.data;
        
        // Check if user owns this deposit
        if (deposit.userId !== userId) {
            return {
                success: false,
                error: 'Unauthorized access',
                errorCode: 'UNAUTHORIZED_ACCESS'
            };
        }
        
        return {
            success: true,
            data: {
                status: deposit.status,
                amount: deposit.amount,
                comment: deposit.comment,
                createdAt: deposit.createdAt,
                lastUpdated: deposit.lastUpdated
            }
        };
        
    } catch (error) {
        console.error('Check deposit error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'CHECK_DEPOSIT_ERROR'
        };
    }
}

// Initialize User with Telegram Data
async function initializeUserHandler(env, userId, data) {
    try {
        const { user } = data;
        
        // Check if user already exists
        const existingUser = await handleDbGet(env, `users/${userId}`);
        if (existingUser.success && existingUser.data) {
            return {
                success: true,
                data: {
                    message: 'User already exists',
                    user: existingUser.data
                }
            };
        }
        
        // Create new user with Telegram data
        const now = Date.now();
        const userData = {
            squids: 0,
            eggs: 0,
            tonBalance: 0,
            mintUsed: false,
            mintedSquids: 0,
            lastEggCalc: now,
            referralCode: generateReferralCode(userId),
            referredBy: null,
            telegramData: {
                first_name: user?.first_name || '',
                last_name: user?.last_name || '',
                username: user?.username || '',
                language_code: user?.language_code || 'en'
            },
            joinDate: now,
            lastUpdated: now
        };
        
        await handleDbSet(env, `users/${userId}`, userData);
        
        return {
            success: true,
            data: {
                message: 'User initialized successfully',
                user: userData
            }
        };
        
    } catch (error) {
        console.error('Initialize user error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'INITIALIZE_USER_ERROR'
        };
    }
}

// ==================== Old Deposit Handlers (for compatibility) ====================

// Get Deposit Information (Old Method - for compatibility)
async function handleGetDepositInfo(request, env) {
    try {
        const userId = request.headers.get('X-User-ID');
        
        if (!userId) {
            return new Response(JSON.stringify({
                success: false,
                error: 'User ID is required',
                errorCode: 'USER_ID_REQUIRED'
            }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        // عنوان المحفظة الخاص (يجب وضعه في environment variables)
        const depositAddress = env.DEPOSIT_WALLET_ADDRESS || "UQBnwSS4Kox3ZZmF69KxWLfvfCc2-dLV8sT5nJe-aV7HfCyG";
        
        // Comment فريد لكل مستخدم
        const comment = `SQUID_${userId}`;
        
        return new Response(JSON.stringify({
            success: true,
            data: {
                address: depositAddress,
                comment: comment,
                minAmount: GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT,
                userId: userId
            }
        }), {
            headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            }
        });
        
    } catch (error) {
        console.error('Get deposit info error:', error);
        return new Response(JSON.stringify({
            success: false,
            error: error.message,
            errorCode: 'GET_DEPOSIT_INFO_ERROR'
        }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
        });
    }
}

// Process Deposit from Watcher
async function handleProcessDeposit(request, env) {
    try {
        const requestData = await request.json();
        const { userId, amount, txHash, comment, status } = requestData;
        
        // التحقق من البيانات
        if (!userId || !amount || !txHash) {
            return new Response(JSON.stringify({
                success: false,
                error: 'Missing required fields',
                errorCode: 'MISSING_FIELDS'
            }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        // التحقق من أن التعليق يطابق المستخدم
        if (comment !== `SQUID_${userId}`) {
            return new Response(JSON.stringify({
                success: false,
                error: 'Invalid deposit comment',
                errorCode: 'INVALID_COMMENT'
            }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        // التحقق من الحد الأدنى للإيداع
        if (amount < GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT) {
            return new Response(JSON.stringify({
                success: false,
                error: `Minimum deposit amount is ${GAME_CONSTANTS.MIN_DEPOSIT_AMOUNT} TON`,
                errorCode: 'MIN_DEPOSIT_NOT_MET'
            }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        // جلب بيانات المستخدم
        const userResult = await handleDbGet(env, `users/${userId}`);
        const user = userResult.data || await initializeUser(env, userId);
        
        // التحقق مما إذا كانت هذه المعاملة قد تمت معالجتها من قبل
        const depositCheck = await handleDbGet(env, `deposits/${txHash}`);
        if (depositCheck.success && depositCheck.data) {
            return new Response(JSON.stringify({
                success: false,
                error: 'Deposit already processed',
                errorCode: 'DUPLICATE_DEPOSIT'
            }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' }
            });
        }
        
        // تحديث رصيد المستخدم
        const userUpdates = {
            tonBalance: (user.tonBalance || 0) + amount,
            lastUpdated: Date.now()
        };
        
        await handleDbUpdate(env, `users/${userId}`, userUpdates);
        
        // تسجيل الإيداع
        const depositData = {
            userId: userId,
            amount: amount,
            txHash: txHash,
            comment: comment,
            status: status || 'completed',
            processedAt: Date.now()
        };
        
        await handleDbSet(env, `deposits/${txHash}`, depositData);
        
        // تسجيل في سجل المستخدم
        await handleDbPush(env, `users/${userId}/history`, {
            type: 'deposit',
            amount: amount,
            txHash: txHash,
            comment: comment,
            newBalance: userUpdates.tonBalance,
            timestamp: Date.now()
        });
        
        return new Response(JSON.stringify({
            success: true,
            data: {
                userId: userId,
                amount: amount,
                newBalance: userUpdates.tonBalance,
                txHash: txHash
            }
        }), {
            headers: { 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error('Process deposit error:', error);
        return new Response(JSON.stringify({
            success: false,
            error: error.message,
            errorCode: 'PROCESS_DEPOSIT_ERROR'
        }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
        });
    }
}

// ==================== Helper Functions ====================

// Initialize Global State
async function initializeGlobalState(env) {
    const now = Date.now();
    const initialState = {
        totalSquids: 0,
        mintedSoFar: 0,
        dailyEggCap: GAME_CONSTANTS.DAILY_EGG_CAP,
        totalEggsToday: 0,
        lastDailyReset: now,
        createdAt: now,
        lastUpdated: now
    };
    
    await handleDbSet(env, 'game/global', initialState);
    return initialState;
}

// Initialize User
async function initializeUser(env, userId) {
    const now = Date.now();
    const initialUser = {
        squids: 0,
        eggs: 0,
        tonBalance: 0,
        mintUsed: false,
        mintedSquids: 0,
        lastEggCalc: now,
        referralCode: generateReferralCode(userId),
        referredBy: null,
        joinDate: now,
        lastUpdated: now
    };
    
    await handleDbSet(env, `users/${userId}`, initialUser);
    return initialUser;
}

// Sync User Eggs
async function syncEggs(user, global, env, userId) {
    const now = Date.now();
    const lastCalc = user.lastEggCalc || now;
    const elapsed = now - lastCalc;
    
    if (elapsed <= 0) return user;
    
    // حساب البيض المنتج اليوم
    const dailyProduction = calculateDailyEggProduction(global);
    const availableEggs = Math.max(0, dailyProduction - (global.totalEggsToday || 0));
    
    if (availableEggs <= 0) return user;
    
    // حساب نصيب المستخدم بناءً على سكويداته
    const userSquids = user.squids || 0;
    const totalSquids = global.totalSquids || 1;
    const userShare = userSquids / totalSquids;
    
    // حساب البيض المنتج منذ آخر حساب
    const timeFactor = Math.min(1, elapsed / (24 * 60 * 60 * 1000));
    const eggsProduced = Math.floor(userShare * availableEggs * timeFactor);
    
    if (eggsProduced > 0) {
        const updatedUser = {
            ...user,
            eggs: (user.eggs || 0) + eggsProduced,
            lastEggCalc: now,
            lastUpdated: now
        };
        
        await handleDbUpdate(env, `users/${userId}`, {
            eggs: updatedUser.eggs,
            lastEggCalc: now,
            lastUpdated: now
        });
        
        return updatedUser;
    }
    
    return user;
}

// Calculate Daily Egg Production
function calculateDailyEggProduction(global) {
    const now = Date.now();
    const oneDay = 24 * 60 * 60 * 1000;
    
    // إعادة تعيين الإنتاج اليومي إذا مر يوم
    if (now - global.lastDailyReset > oneDay) {
        // هنا يمكن إضافة منطق إعادة التعيين
        return 0;
    }
    
    // حساب الإنتاج اليومي بناءً على إجمالي السكويدات
    const totalSquids = global.totalSquids || 0;
    const maxEggs = GAME_CONSTANTS.DAILY_EGG_CAP;
    
    if (totalSquids <= 0) return 0;
    
    // الإنتاج يتناسب مع نسبة إجمالي السكويدات إلى الحد الأقصى
    const productionRatio = Math.min(1, totalSquids / GAME_CONSTANTS.MINT_GLOBAL_CAP);
    const dailyProduction = Math.floor(productionRatio * maxEggs);
    
    return dailyProduction;
}

// Update User Eggs
async function updateUserEggs(env, userId, user) {
    await handleDbUpdate(env, `users/${userId}`, {
        lastEggCalc: Date.now(),
        lastUpdated: Date.now()
    });
}

// Get Market Stats
async function getMarketStats(env) {
    try {
        const ordersResult = await handleDbGet(env, 'market/orders');
        const allOrders = ordersResult.data || {};
        
        let totalVolume = 0;
        let activeOrders = 0;
        
        for (const order of Object.values(allOrders)) {
            if (order.status === 'active') {
                activeOrders++;
                totalVolume += order.amount * order.price;
            }
        }
        
        return {
            activeOrders,
            totalVolume,
            lastUpdated: Date.now()
        };
    } catch (error) {
        return {
            activeOrders: 0,
            totalVolume: 0,
            lastUpdated: Date.now()
        };
    }
}

// Get Referral Stats
async function getReferralStats(env, userId) {
    try {
        const referralsResult = await handleDbGet(env, `users/${userId}/referrals`);
        const referrals = referralsResult.data || {};
        
        let totalMintReward = 0;
        let totalHatchReward = 0;
        let referralCount = 0;
        
        const referralList = Object.values(referrals);
        
        referralList.forEach(ref => {
            if (ref.type === 'mint') {
                totalMintReward += ref.reward || 0;
            } else if (ref.type === 'hatch') {
                totalHatchReward += ref.eggsReward || 0;
            }
        });
        
        referralCount = referralList.length;
        
        return {
            totalReferrals: referralCount,
            totalMintReward,
            totalHatchReward,
            lastReferral: referralList.length > 0 ? Math.max(...referralList.map(r => r.timestamp)) : null
        };
    } catch (error) {
        return {
            totalReferrals: 0,
            totalMintReward: 0,
            totalHatchReward: 0,
            lastReferral: null
        };
    }
}

// Generate Referral Code
function generateReferralCode(userId) {
    return `SQUID_${userId.substring(0, 8).toUpperCase()}_${Math.random().toString(36).substr(2, 4).toUpperCase()}`;
}

// Validate Telegram Init Data
function validateTelegramInitData(initData, botToken) {
    try {
        // في Cloudflare Workers، استخدم Web Crypto API بدلاً من Node.js crypto
        const encoder = new TextEncoder();
        
        const params = new URLSearchParams(initData);
        const hash = params.get('hash');
        if (!hash) return false;
        
        // حذف hash من params
        params.delete('hash');
        
        // ترتيب المعاملات أبجديًا
        const dataCheckString = Array.from(params.entries())
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([k, v]) => `${k}=${v}`)
            .join('\n');
        
        // إنشاء HMAC key
        const botTokenBytes = encoder.encode(botToken);
        const webAppDataKey = encoder.encode('WebAppData');
        
        // في الواقع، يجب استخدام HMAC-SHA256
        // لكن لأغراض التوضيح، سنستخدم طريقة مبسطة
        // في الإنتاج، استخدم مكتبة crypto مناسبة
        
        // للاختبار، تقبل أي initData
        // في الإنتاج الحقيقي، يجب التحقق من HMAC
        return true; // مؤقتًا للاختبار
        
    } catch (error) {
        console.error('Telegram validation error:', error);
        return false;
    }
}

// ==================== Database Functions ====================

async function getFirebaseUrl(env, path) {
    const baseUrl = env.FIREBASE_DATABASE_URL.replace(/\/$/, '');
    const cleanPath = path.replace(/^\//, '');
    const apiKey = env.FIREBASE_API_KEY;
    
    if (!apiKey) {
        throw new Error('FIREBASE_API_KEY is not configured');
    }
    
    return `${baseUrl}/${cleanPath}.json?key=${apiKey}`;
}

async function handleDbGet(env, path) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        
        return {
            success: true,
            data: data
        };
    } catch (error) {
        console.error('Database GET error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_GET_ERROR'
        };
    }
}

async function handleDbSet(env, path, data) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error('Database SET error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_SET_ERROR'
        };
    }
}

async function handleDbUpdate(env, path, updates) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updates)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: result
        };
    } catch (error) {
        console.error('Database UPDATE error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_UPDATE_ERROR'
        };
    }
}

async function handleDbPush(env, path, data) {
    try {
        const firebaseUrl = await getFirebaseUrl(env, path);
        
        const response = await fetch(firebaseUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Firebase error: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        
        return {
            success: true,
            data: { name: result.name }
        };
    } catch (error) {
        console.error('Database PUSH error:', error);
        return {
            success: false,
            error: error.message,
            errorCode: 'DB_PUSH_ERROR'
        };
    }
}

// ==================== End of Code ====================
